/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import $protobuf from "protobufjs/minimal.js";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const immudb = $root.immudb = (() => {

    /**
     * Namespace immudb.
     * @exports immudb
     * @namespace
     */
    const immudb = {};

    immudb.schema = (function() {

        /**
         * Namespace schema.
         * @memberof immudb
         * @namespace
         */
        const schema = {};

        schema.Key = (function() {

            /**
             * Properties of a Key.
             * @memberof immudb.schema
             * @interface IKey
             * @property {Uint8Array|null} [key] Key key
             */

            /**
             * Constructs a new Key.
             * @memberof immudb.schema
             * @classdesc Represents a Key.
             * @implements IKey
             * @constructor
             * @param {immudb.schema.IKey=} [properties] Properties to set
             */
            function Key(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Key key.
             * @member {Uint8Array} key
             * @memberof immudb.schema.Key
             * @instance
             */
            Key.prototype.key = $util.newBuffer([]);

            /**
             * Creates a new Key instance using the specified properties.
             * @function create
             * @memberof immudb.schema.Key
             * @static
             * @param {immudb.schema.IKey=} [properties] Properties to set
             * @returns {immudb.schema.Key} Key instance
             */
            Key.create = function create(properties) {
                return new Key(properties);
            };

            /**
             * Encodes the specified Key message. Does not implicitly {@link immudb.schema.Key.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.Key
             * @static
             * @param {immudb.schema.IKey} message Key message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Key.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
                return writer;
            };

            /**
             * Encodes the specified Key message, length delimited. Does not implicitly {@link immudb.schema.Key.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.Key
             * @static
             * @param {immudb.schema.IKey} message Key message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Key.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Key message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.Key
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.Key} Key
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Key.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.Key();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.key = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Key message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.Key
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.Key} Key
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Key.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Key message.
             * @function verify
             * @memberof immudb.schema.Key
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Key.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                        return "key: buffer expected";
                return null;
            };

            /**
             * Creates a Key message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.Key
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.Key} Key
             */
            Key.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.Key)
                    return object;
                let message = new $root.immudb.schema.Key();
                if (object.key != null)
                    if (typeof object.key === "string")
                        $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                    else if (object.key.length >= 0)
                        message.key = object.key;
                return message;
            };

            /**
             * Creates a plain object from a Key message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.Key
             * @static
             * @param {immudb.schema.Key} message Key
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Key.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.key = "";
                    else {
                        object.key = [];
                        if (options.bytes !== Array)
                            object.key = $util.newBuffer(object.key);
                    }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                return object;
            };

            /**
             * Converts this Key to JSON.
             * @function toJSON
             * @memberof immudb.schema.Key
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Key.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Key
             * @function getTypeUrl
             * @memberof immudb.schema.Key
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Key.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.Key";
            };

            return Key;
        })();

        schema.Permission = (function() {

            /**
             * Properties of a Permission.
             * @memberof immudb.schema
             * @interface IPermission
             * @property {string|null} [database] Permission database
             * @property {number|null} [permission] Permission permission
             */

            /**
             * Constructs a new Permission.
             * @memberof immudb.schema
             * @classdesc Represents a Permission.
             * @implements IPermission
             * @constructor
             * @param {immudb.schema.IPermission=} [properties] Properties to set
             */
            function Permission(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Permission database.
             * @member {string} database
             * @memberof immudb.schema.Permission
             * @instance
             */
            Permission.prototype.database = "";

            /**
             * Permission permission.
             * @member {number} permission
             * @memberof immudb.schema.Permission
             * @instance
             */
            Permission.prototype.permission = 0;

            /**
             * Creates a new Permission instance using the specified properties.
             * @function create
             * @memberof immudb.schema.Permission
             * @static
             * @param {immudb.schema.IPermission=} [properties] Properties to set
             * @returns {immudb.schema.Permission} Permission instance
             */
            Permission.create = function create(properties) {
                return new Permission(properties);
            };

            /**
             * Encodes the specified Permission message. Does not implicitly {@link immudb.schema.Permission.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.Permission
             * @static
             * @param {immudb.schema.IPermission} message Permission message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Permission.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.database);
                if (message.permission != null && Object.hasOwnProperty.call(message, "permission"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.permission);
                return writer;
            };

            /**
             * Encodes the specified Permission message, length delimited. Does not implicitly {@link immudb.schema.Permission.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.Permission
             * @static
             * @param {immudb.schema.IPermission} message Permission message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Permission.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Permission message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.Permission
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.Permission} Permission
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Permission.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.Permission();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.database = reader.string();
                            break;
                        }
                    case 2: {
                            message.permission = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Permission message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.Permission
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.Permission} Permission
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Permission.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Permission message.
             * @function verify
             * @memberof immudb.schema.Permission
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Permission.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isString(message.database))
                        return "database: string expected";
                if (message.permission != null && message.hasOwnProperty("permission"))
                    if (!$util.isInteger(message.permission))
                        return "permission: integer expected";
                return null;
            };

            /**
             * Creates a Permission message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.Permission
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.Permission} Permission
             */
            Permission.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.Permission)
                    return object;
                let message = new $root.immudb.schema.Permission();
                if (object.database != null)
                    message.database = String(object.database);
                if (object.permission != null)
                    message.permission = object.permission >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a Permission message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.Permission
             * @static
             * @param {immudb.schema.Permission} message Permission
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Permission.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.database = "";
                    object.permission = 0;
                }
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                if (message.permission != null && message.hasOwnProperty("permission"))
                    object.permission = message.permission;
                return object;
            };

            /**
             * Converts this Permission to JSON.
             * @function toJSON
             * @memberof immudb.schema.Permission
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Permission.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Permission
             * @function getTypeUrl
             * @memberof immudb.schema.Permission
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Permission.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.Permission";
            };

            return Permission;
        })();

        schema.User = (function() {

            /**
             * Properties of a User.
             * @memberof immudb.schema
             * @interface IUser
             * @property {Uint8Array|null} [user] User user
             * @property {Array.<immudb.schema.IPermission>|null} [permissions] User permissions
             * @property {string|null} [createdby] User createdby
             * @property {string|null} [createdat] User createdat
             * @property {boolean|null} [active] User active
             */

            /**
             * Constructs a new User.
             * @memberof immudb.schema
             * @classdesc Represents a User.
             * @implements IUser
             * @constructor
             * @param {immudb.schema.IUser=} [properties] Properties to set
             */
            function User(properties) {
                this.permissions = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * User user.
             * @member {Uint8Array} user
             * @memberof immudb.schema.User
             * @instance
             */
            User.prototype.user = $util.newBuffer([]);

            /**
             * User permissions.
             * @member {Array.<immudb.schema.IPermission>} permissions
             * @memberof immudb.schema.User
             * @instance
             */
            User.prototype.permissions = $util.emptyArray;

            /**
             * User createdby.
             * @member {string} createdby
             * @memberof immudb.schema.User
             * @instance
             */
            User.prototype.createdby = "";

            /**
             * User createdat.
             * @member {string} createdat
             * @memberof immudb.schema.User
             * @instance
             */
            User.prototype.createdat = "";

            /**
             * User active.
             * @member {boolean} active
             * @memberof immudb.schema.User
             * @instance
             */
            User.prototype.active = false;

            /**
             * Creates a new User instance using the specified properties.
             * @function create
             * @memberof immudb.schema.User
             * @static
             * @param {immudb.schema.IUser=} [properties] Properties to set
             * @returns {immudb.schema.User} User instance
             */
            User.create = function create(properties) {
                return new User(properties);
            };

            /**
             * Encodes the specified User message. Does not implicitly {@link immudb.schema.User.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.User
             * @static
             * @param {immudb.schema.IUser} message User message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            User.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.user != null && Object.hasOwnProperty.call(message, "user"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.user);
                if (message.permissions != null && message.permissions.length)
                    for (let i = 0; i < message.permissions.length; ++i)
                        $root.immudb.schema.Permission.encode(message.permissions[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.createdby != null && Object.hasOwnProperty.call(message, "createdby"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.createdby);
                if (message.createdat != null && Object.hasOwnProperty.call(message, "createdat"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.createdat);
                if (message.active != null && Object.hasOwnProperty.call(message, "active"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.active);
                return writer;
            };

            /**
             * Encodes the specified User message, length delimited. Does not implicitly {@link immudb.schema.User.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.User
             * @static
             * @param {immudb.schema.IUser} message User message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            User.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a User message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.User
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.User} User
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            User.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.User();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.user = reader.bytes();
                            break;
                        }
                    case 3: {
                            if (!(message.permissions && message.permissions.length))
                                message.permissions = [];
                            message.permissions.push($root.immudb.schema.Permission.decode(reader, reader.uint32()));
                            break;
                        }
                    case 4: {
                            message.createdby = reader.string();
                            break;
                        }
                    case 5: {
                            message.createdat = reader.string();
                            break;
                        }
                    case 6: {
                            message.active = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a User message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.User
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.User} User
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            User.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a User message.
             * @function verify
             * @memberof immudb.schema.User
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            User.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.user != null && message.hasOwnProperty("user"))
                    if (!(message.user && typeof message.user.length === "number" || $util.isString(message.user)))
                        return "user: buffer expected";
                if (message.permissions != null && message.hasOwnProperty("permissions")) {
                    if (!Array.isArray(message.permissions))
                        return "permissions: array expected";
                    for (let i = 0; i < message.permissions.length; ++i) {
                        let error = $root.immudb.schema.Permission.verify(message.permissions[i]);
                        if (error)
                            return "permissions." + error;
                    }
                }
                if (message.createdby != null && message.hasOwnProperty("createdby"))
                    if (!$util.isString(message.createdby))
                        return "createdby: string expected";
                if (message.createdat != null && message.hasOwnProperty("createdat"))
                    if (!$util.isString(message.createdat))
                        return "createdat: string expected";
                if (message.active != null && message.hasOwnProperty("active"))
                    if (typeof message.active !== "boolean")
                        return "active: boolean expected";
                return null;
            };

            /**
             * Creates a User message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.User
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.User} User
             */
            User.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.User)
                    return object;
                let message = new $root.immudb.schema.User();
                if (object.user != null)
                    if (typeof object.user === "string")
                        $util.base64.decode(object.user, message.user = $util.newBuffer($util.base64.length(object.user)), 0);
                    else if (object.user.length >= 0)
                        message.user = object.user;
                if (object.permissions) {
                    if (!Array.isArray(object.permissions))
                        throw TypeError(".immudb.schema.User.permissions: array expected");
                    message.permissions = [];
                    for (let i = 0; i < object.permissions.length; ++i) {
                        if (typeof object.permissions[i] !== "object")
                            throw TypeError(".immudb.schema.User.permissions: object expected");
                        message.permissions[i] = $root.immudb.schema.Permission.fromObject(object.permissions[i]);
                    }
                }
                if (object.createdby != null)
                    message.createdby = String(object.createdby);
                if (object.createdat != null)
                    message.createdat = String(object.createdat);
                if (object.active != null)
                    message.active = Boolean(object.active);
                return message;
            };

            /**
             * Creates a plain object from a User message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.User
             * @static
             * @param {immudb.schema.User} message User
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            User.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.permissions = [];
                if (options.defaults) {
                    if (options.bytes === String)
                        object.user = "";
                    else {
                        object.user = [];
                        if (options.bytes !== Array)
                            object.user = $util.newBuffer(object.user);
                    }
                    object.createdby = "";
                    object.createdat = "";
                    object.active = false;
                }
                if (message.user != null && message.hasOwnProperty("user"))
                    object.user = options.bytes === String ? $util.base64.encode(message.user, 0, message.user.length) : options.bytes === Array ? Array.prototype.slice.call(message.user) : message.user;
                if (message.permissions && message.permissions.length) {
                    object.permissions = [];
                    for (let j = 0; j < message.permissions.length; ++j)
                        object.permissions[j] = $root.immudb.schema.Permission.toObject(message.permissions[j], options);
                }
                if (message.createdby != null && message.hasOwnProperty("createdby"))
                    object.createdby = message.createdby;
                if (message.createdat != null && message.hasOwnProperty("createdat"))
                    object.createdat = message.createdat;
                if (message.active != null && message.hasOwnProperty("active"))
                    object.active = message.active;
                return object;
            };

            /**
             * Converts this User to JSON.
             * @function toJSON
             * @memberof immudb.schema.User
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            User.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for User
             * @function getTypeUrl
             * @memberof immudb.schema.User
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            User.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.User";
            };

            return User;
        })();

        schema.UserList = (function() {

            /**
             * Properties of a UserList.
             * @memberof immudb.schema
             * @interface IUserList
             * @property {Array.<immudb.schema.IUser>|null} [users] UserList users
             */

            /**
             * Constructs a new UserList.
             * @memberof immudb.schema
             * @classdesc Represents a UserList.
             * @implements IUserList
             * @constructor
             * @param {immudb.schema.IUserList=} [properties] Properties to set
             */
            function UserList(properties) {
                this.users = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UserList users.
             * @member {Array.<immudb.schema.IUser>} users
             * @memberof immudb.schema.UserList
             * @instance
             */
            UserList.prototype.users = $util.emptyArray;

            /**
             * Creates a new UserList instance using the specified properties.
             * @function create
             * @memberof immudb.schema.UserList
             * @static
             * @param {immudb.schema.IUserList=} [properties] Properties to set
             * @returns {immudb.schema.UserList} UserList instance
             */
            UserList.create = function create(properties) {
                return new UserList(properties);
            };

            /**
             * Encodes the specified UserList message. Does not implicitly {@link immudb.schema.UserList.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.UserList
             * @static
             * @param {immudb.schema.IUserList} message UserList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UserList.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.users != null && message.users.length)
                    for (let i = 0; i < message.users.length; ++i)
                        $root.immudb.schema.User.encode(message.users[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified UserList message, length delimited. Does not implicitly {@link immudb.schema.UserList.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.UserList
             * @static
             * @param {immudb.schema.IUserList} message UserList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UserList.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a UserList message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.UserList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.UserList} UserList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UserList.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.UserList();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.users && message.users.length))
                                message.users = [];
                            message.users.push($root.immudb.schema.User.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a UserList message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.UserList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.UserList} UserList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UserList.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a UserList message.
             * @function verify
             * @memberof immudb.schema.UserList
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UserList.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.users != null && message.hasOwnProperty("users")) {
                    if (!Array.isArray(message.users))
                        return "users: array expected";
                    for (let i = 0; i < message.users.length; ++i) {
                        let error = $root.immudb.schema.User.verify(message.users[i]);
                        if (error)
                            return "users." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a UserList message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.UserList
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.UserList} UserList
             */
            UserList.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.UserList)
                    return object;
                let message = new $root.immudb.schema.UserList();
                if (object.users) {
                    if (!Array.isArray(object.users))
                        throw TypeError(".immudb.schema.UserList.users: array expected");
                    message.users = [];
                    for (let i = 0; i < object.users.length; ++i) {
                        if (typeof object.users[i] !== "object")
                            throw TypeError(".immudb.schema.UserList.users: object expected");
                        message.users[i] = $root.immudb.schema.User.fromObject(object.users[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a UserList message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.UserList
             * @static
             * @param {immudb.schema.UserList} message UserList
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UserList.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.users = [];
                if (message.users && message.users.length) {
                    object.users = [];
                    for (let j = 0; j < message.users.length; ++j)
                        object.users[j] = $root.immudb.schema.User.toObject(message.users[j], options);
                }
                return object;
            };

            /**
             * Converts this UserList to JSON.
             * @function toJSON
             * @memberof immudb.schema.UserList
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UserList.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UserList
             * @function getTypeUrl
             * @memberof immudb.schema.UserList
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UserList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.UserList";
            };

            return UserList;
        })();

        schema.CreateUserRequest = (function() {

            /**
             * Properties of a CreateUserRequest.
             * @memberof immudb.schema
             * @interface ICreateUserRequest
             * @property {Uint8Array|null} [user] CreateUserRequest user
             * @property {Uint8Array|null} [password] CreateUserRequest password
             * @property {number|null} [permission] CreateUserRequest permission
             * @property {string|null} [database] CreateUserRequest database
             */

            /**
             * Constructs a new CreateUserRequest.
             * @memberof immudb.schema
             * @classdesc Represents a CreateUserRequest.
             * @implements ICreateUserRequest
             * @constructor
             * @param {immudb.schema.ICreateUserRequest=} [properties] Properties to set
             */
            function CreateUserRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateUserRequest user.
             * @member {Uint8Array} user
             * @memberof immudb.schema.CreateUserRequest
             * @instance
             */
            CreateUserRequest.prototype.user = $util.newBuffer([]);

            /**
             * CreateUserRequest password.
             * @member {Uint8Array} password
             * @memberof immudb.schema.CreateUserRequest
             * @instance
             */
            CreateUserRequest.prototype.password = $util.newBuffer([]);

            /**
             * CreateUserRequest permission.
             * @member {number} permission
             * @memberof immudb.schema.CreateUserRequest
             * @instance
             */
            CreateUserRequest.prototype.permission = 0;

            /**
             * CreateUserRequest database.
             * @member {string} database
             * @memberof immudb.schema.CreateUserRequest
             * @instance
             */
            CreateUserRequest.prototype.database = "";

            /**
             * Creates a new CreateUserRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.CreateUserRequest
             * @static
             * @param {immudb.schema.ICreateUserRequest=} [properties] Properties to set
             * @returns {immudb.schema.CreateUserRequest} CreateUserRequest instance
             */
            CreateUserRequest.create = function create(properties) {
                return new CreateUserRequest(properties);
            };

            /**
             * Encodes the specified CreateUserRequest message. Does not implicitly {@link immudb.schema.CreateUserRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.CreateUserRequest
             * @static
             * @param {immudb.schema.ICreateUserRequest} message CreateUserRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateUserRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.user != null && Object.hasOwnProperty.call(message, "user"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.user);
                if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.password);
                if (message.permission != null && Object.hasOwnProperty.call(message, "permission"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.permission);
                if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.database);
                return writer;
            };

            /**
             * Encodes the specified CreateUserRequest message, length delimited. Does not implicitly {@link immudb.schema.CreateUserRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.CreateUserRequest
             * @static
             * @param {immudb.schema.ICreateUserRequest} message CreateUserRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateUserRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateUserRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.CreateUserRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.CreateUserRequest} CreateUserRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateUserRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.CreateUserRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.user = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.password = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.permission = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.database = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateUserRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.CreateUserRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.CreateUserRequest} CreateUserRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateUserRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateUserRequest message.
             * @function verify
             * @memberof immudb.schema.CreateUserRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateUserRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.user != null && message.hasOwnProperty("user"))
                    if (!(message.user && typeof message.user.length === "number" || $util.isString(message.user)))
                        return "user: buffer expected";
                if (message.password != null && message.hasOwnProperty("password"))
                    if (!(message.password && typeof message.password.length === "number" || $util.isString(message.password)))
                        return "password: buffer expected";
                if (message.permission != null && message.hasOwnProperty("permission"))
                    if (!$util.isInteger(message.permission))
                        return "permission: integer expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isString(message.database))
                        return "database: string expected";
                return null;
            };

            /**
             * Creates a CreateUserRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.CreateUserRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.CreateUserRequest} CreateUserRequest
             */
            CreateUserRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.CreateUserRequest)
                    return object;
                let message = new $root.immudb.schema.CreateUserRequest();
                if (object.user != null)
                    if (typeof object.user === "string")
                        $util.base64.decode(object.user, message.user = $util.newBuffer($util.base64.length(object.user)), 0);
                    else if (object.user.length >= 0)
                        message.user = object.user;
                if (object.password != null)
                    if (typeof object.password === "string")
                        $util.base64.decode(object.password, message.password = $util.newBuffer($util.base64.length(object.password)), 0);
                    else if (object.password.length >= 0)
                        message.password = object.password;
                if (object.permission != null)
                    message.permission = object.permission >>> 0;
                if (object.database != null)
                    message.database = String(object.database);
                return message;
            };

            /**
             * Creates a plain object from a CreateUserRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.CreateUserRequest
             * @static
             * @param {immudb.schema.CreateUserRequest} message CreateUserRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateUserRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.user = "";
                    else {
                        object.user = [];
                        if (options.bytes !== Array)
                            object.user = $util.newBuffer(object.user);
                    }
                    if (options.bytes === String)
                        object.password = "";
                    else {
                        object.password = [];
                        if (options.bytes !== Array)
                            object.password = $util.newBuffer(object.password);
                    }
                    object.permission = 0;
                    object.database = "";
                }
                if (message.user != null && message.hasOwnProperty("user"))
                    object.user = options.bytes === String ? $util.base64.encode(message.user, 0, message.user.length) : options.bytes === Array ? Array.prototype.slice.call(message.user) : message.user;
                if (message.password != null && message.hasOwnProperty("password"))
                    object.password = options.bytes === String ? $util.base64.encode(message.password, 0, message.password.length) : options.bytes === Array ? Array.prototype.slice.call(message.password) : message.password;
                if (message.permission != null && message.hasOwnProperty("permission"))
                    object.permission = message.permission;
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                return object;
            };

            /**
             * Converts this CreateUserRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.CreateUserRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateUserRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CreateUserRequest
             * @function getTypeUrl
             * @memberof immudb.schema.CreateUserRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CreateUserRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.CreateUserRequest";
            };

            return CreateUserRequest;
        })();

        schema.UserRequest = (function() {

            /**
             * Properties of a UserRequest.
             * @memberof immudb.schema
             * @interface IUserRequest
             * @property {Uint8Array|null} [user] UserRequest user
             */

            /**
             * Constructs a new UserRequest.
             * @memberof immudb.schema
             * @classdesc Represents a UserRequest.
             * @implements IUserRequest
             * @constructor
             * @param {immudb.schema.IUserRequest=} [properties] Properties to set
             */
            function UserRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UserRequest user.
             * @member {Uint8Array} user
             * @memberof immudb.schema.UserRequest
             * @instance
             */
            UserRequest.prototype.user = $util.newBuffer([]);

            /**
             * Creates a new UserRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.UserRequest
             * @static
             * @param {immudb.schema.IUserRequest=} [properties] Properties to set
             * @returns {immudb.schema.UserRequest} UserRequest instance
             */
            UserRequest.create = function create(properties) {
                return new UserRequest(properties);
            };

            /**
             * Encodes the specified UserRequest message. Does not implicitly {@link immudb.schema.UserRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.UserRequest
             * @static
             * @param {immudb.schema.IUserRequest} message UserRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UserRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.user != null && Object.hasOwnProperty.call(message, "user"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.user);
                return writer;
            };

            /**
             * Encodes the specified UserRequest message, length delimited. Does not implicitly {@link immudb.schema.UserRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.UserRequest
             * @static
             * @param {immudb.schema.IUserRequest} message UserRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UserRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a UserRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.UserRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.UserRequest} UserRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UserRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.UserRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.user = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a UserRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.UserRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.UserRequest} UserRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UserRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a UserRequest message.
             * @function verify
             * @memberof immudb.schema.UserRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UserRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.user != null && message.hasOwnProperty("user"))
                    if (!(message.user && typeof message.user.length === "number" || $util.isString(message.user)))
                        return "user: buffer expected";
                return null;
            };

            /**
             * Creates a UserRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.UserRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.UserRequest} UserRequest
             */
            UserRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.UserRequest)
                    return object;
                let message = new $root.immudb.schema.UserRequest();
                if (object.user != null)
                    if (typeof object.user === "string")
                        $util.base64.decode(object.user, message.user = $util.newBuffer($util.base64.length(object.user)), 0);
                    else if (object.user.length >= 0)
                        message.user = object.user;
                return message;
            };

            /**
             * Creates a plain object from a UserRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.UserRequest
             * @static
             * @param {immudb.schema.UserRequest} message UserRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UserRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.user = "";
                    else {
                        object.user = [];
                        if (options.bytes !== Array)
                            object.user = $util.newBuffer(object.user);
                    }
                if (message.user != null && message.hasOwnProperty("user"))
                    object.user = options.bytes === String ? $util.base64.encode(message.user, 0, message.user.length) : options.bytes === Array ? Array.prototype.slice.call(message.user) : message.user;
                return object;
            };

            /**
             * Converts this UserRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.UserRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UserRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UserRequest
             * @function getTypeUrl
             * @memberof immudb.schema.UserRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UserRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.UserRequest";
            };

            return UserRequest;
        })();

        schema.ChangePasswordRequest = (function() {

            /**
             * Properties of a ChangePasswordRequest.
             * @memberof immudb.schema
             * @interface IChangePasswordRequest
             * @property {Uint8Array|null} [user] ChangePasswordRequest user
             * @property {Uint8Array|null} [oldPassword] ChangePasswordRequest oldPassword
             * @property {Uint8Array|null} [newPassword] ChangePasswordRequest newPassword
             */

            /**
             * Constructs a new ChangePasswordRequest.
             * @memberof immudb.schema
             * @classdesc Represents a ChangePasswordRequest.
             * @implements IChangePasswordRequest
             * @constructor
             * @param {immudb.schema.IChangePasswordRequest=} [properties] Properties to set
             */
            function ChangePasswordRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ChangePasswordRequest user.
             * @member {Uint8Array} user
             * @memberof immudb.schema.ChangePasswordRequest
             * @instance
             */
            ChangePasswordRequest.prototype.user = $util.newBuffer([]);

            /**
             * ChangePasswordRequest oldPassword.
             * @member {Uint8Array} oldPassword
             * @memberof immudb.schema.ChangePasswordRequest
             * @instance
             */
            ChangePasswordRequest.prototype.oldPassword = $util.newBuffer([]);

            /**
             * ChangePasswordRequest newPassword.
             * @member {Uint8Array} newPassword
             * @memberof immudb.schema.ChangePasswordRequest
             * @instance
             */
            ChangePasswordRequest.prototype.newPassword = $util.newBuffer([]);

            /**
             * Creates a new ChangePasswordRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.ChangePasswordRequest
             * @static
             * @param {immudb.schema.IChangePasswordRequest=} [properties] Properties to set
             * @returns {immudb.schema.ChangePasswordRequest} ChangePasswordRequest instance
             */
            ChangePasswordRequest.create = function create(properties) {
                return new ChangePasswordRequest(properties);
            };

            /**
             * Encodes the specified ChangePasswordRequest message. Does not implicitly {@link immudb.schema.ChangePasswordRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.ChangePasswordRequest
             * @static
             * @param {immudb.schema.IChangePasswordRequest} message ChangePasswordRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChangePasswordRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.user != null && Object.hasOwnProperty.call(message, "user"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.user);
                if (message.oldPassword != null && Object.hasOwnProperty.call(message, "oldPassword"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.oldPassword);
                if (message.newPassword != null && Object.hasOwnProperty.call(message, "newPassword"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.newPassword);
                return writer;
            };

            /**
             * Encodes the specified ChangePasswordRequest message, length delimited. Does not implicitly {@link immudb.schema.ChangePasswordRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.ChangePasswordRequest
             * @static
             * @param {immudb.schema.IChangePasswordRequest} message ChangePasswordRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChangePasswordRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ChangePasswordRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.ChangePasswordRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.ChangePasswordRequest} ChangePasswordRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChangePasswordRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.ChangePasswordRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.user = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.oldPassword = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.newPassword = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ChangePasswordRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.ChangePasswordRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.ChangePasswordRequest} ChangePasswordRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChangePasswordRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ChangePasswordRequest message.
             * @function verify
             * @memberof immudb.schema.ChangePasswordRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChangePasswordRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.user != null && message.hasOwnProperty("user"))
                    if (!(message.user && typeof message.user.length === "number" || $util.isString(message.user)))
                        return "user: buffer expected";
                if (message.oldPassword != null && message.hasOwnProperty("oldPassword"))
                    if (!(message.oldPassword && typeof message.oldPassword.length === "number" || $util.isString(message.oldPassword)))
                        return "oldPassword: buffer expected";
                if (message.newPassword != null && message.hasOwnProperty("newPassword"))
                    if (!(message.newPassword && typeof message.newPassword.length === "number" || $util.isString(message.newPassword)))
                        return "newPassword: buffer expected";
                return null;
            };

            /**
             * Creates a ChangePasswordRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.ChangePasswordRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.ChangePasswordRequest} ChangePasswordRequest
             */
            ChangePasswordRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.ChangePasswordRequest)
                    return object;
                let message = new $root.immudb.schema.ChangePasswordRequest();
                if (object.user != null)
                    if (typeof object.user === "string")
                        $util.base64.decode(object.user, message.user = $util.newBuffer($util.base64.length(object.user)), 0);
                    else if (object.user.length >= 0)
                        message.user = object.user;
                if (object.oldPassword != null)
                    if (typeof object.oldPassword === "string")
                        $util.base64.decode(object.oldPassword, message.oldPassword = $util.newBuffer($util.base64.length(object.oldPassword)), 0);
                    else if (object.oldPassword.length >= 0)
                        message.oldPassword = object.oldPassword;
                if (object.newPassword != null)
                    if (typeof object.newPassword === "string")
                        $util.base64.decode(object.newPassword, message.newPassword = $util.newBuffer($util.base64.length(object.newPassword)), 0);
                    else if (object.newPassword.length >= 0)
                        message.newPassword = object.newPassword;
                return message;
            };

            /**
             * Creates a plain object from a ChangePasswordRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.ChangePasswordRequest
             * @static
             * @param {immudb.schema.ChangePasswordRequest} message ChangePasswordRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChangePasswordRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.user = "";
                    else {
                        object.user = [];
                        if (options.bytes !== Array)
                            object.user = $util.newBuffer(object.user);
                    }
                    if (options.bytes === String)
                        object.oldPassword = "";
                    else {
                        object.oldPassword = [];
                        if (options.bytes !== Array)
                            object.oldPassword = $util.newBuffer(object.oldPassword);
                    }
                    if (options.bytes === String)
                        object.newPassword = "";
                    else {
                        object.newPassword = [];
                        if (options.bytes !== Array)
                            object.newPassword = $util.newBuffer(object.newPassword);
                    }
                }
                if (message.user != null && message.hasOwnProperty("user"))
                    object.user = options.bytes === String ? $util.base64.encode(message.user, 0, message.user.length) : options.bytes === Array ? Array.prototype.slice.call(message.user) : message.user;
                if (message.oldPassword != null && message.hasOwnProperty("oldPassword"))
                    object.oldPassword = options.bytes === String ? $util.base64.encode(message.oldPassword, 0, message.oldPassword.length) : options.bytes === Array ? Array.prototype.slice.call(message.oldPassword) : message.oldPassword;
                if (message.newPassword != null && message.hasOwnProperty("newPassword"))
                    object.newPassword = options.bytes === String ? $util.base64.encode(message.newPassword, 0, message.newPassword.length) : options.bytes === Array ? Array.prototype.slice.call(message.newPassword) : message.newPassword;
                return object;
            };

            /**
             * Converts this ChangePasswordRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.ChangePasswordRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChangePasswordRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ChangePasswordRequest
             * @function getTypeUrl
             * @memberof immudb.schema.ChangePasswordRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ChangePasswordRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.ChangePasswordRequest";
            };

            return ChangePasswordRequest;
        })();

        schema.LoginRequest = (function() {

            /**
             * Properties of a LoginRequest.
             * @memberof immudb.schema
             * @interface ILoginRequest
             * @property {Uint8Array|null} [user] LoginRequest user
             * @property {Uint8Array|null} [password] LoginRequest password
             */

            /**
             * Constructs a new LoginRequest.
             * @memberof immudb.schema
             * @classdesc Represents a LoginRequest.
             * @implements ILoginRequest
             * @constructor
             * @param {immudb.schema.ILoginRequest=} [properties] Properties to set
             */
            function LoginRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LoginRequest user.
             * @member {Uint8Array} user
             * @memberof immudb.schema.LoginRequest
             * @instance
             */
            LoginRequest.prototype.user = $util.newBuffer([]);

            /**
             * LoginRequest password.
             * @member {Uint8Array} password
             * @memberof immudb.schema.LoginRequest
             * @instance
             */
            LoginRequest.prototype.password = $util.newBuffer([]);

            /**
             * Creates a new LoginRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.LoginRequest
             * @static
             * @param {immudb.schema.ILoginRequest=} [properties] Properties to set
             * @returns {immudb.schema.LoginRequest} LoginRequest instance
             */
            LoginRequest.create = function create(properties) {
                return new LoginRequest(properties);
            };

            /**
             * Encodes the specified LoginRequest message. Does not implicitly {@link immudb.schema.LoginRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.LoginRequest
             * @static
             * @param {immudb.schema.ILoginRequest} message LoginRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoginRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.user != null && Object.hasOwnProperty.call(message, "user"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.user);
                if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.password);
                return writer;
            };

            /**
             * Encodes the specified LoginRequest message, length delimited. Does not implicitly {@link immudb.schema.LoginRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.LoginRequest
             * @static
             * @param {immudb.schema.ILoginRequest} message LoginRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoginRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LoginRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.LoginRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.LoginRequest} LoginRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoginRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.LoginRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.user = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.password = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LoginRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.LoginRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.LoginRequest} LoginRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoginRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LoginRequest message.
             * @function verify
             * @memberof immudb.schema.LoginRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LoginRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.user != null && message.hasOwnProperty("user"))
                    if (!(message.user && typeof message.user.length === "number" || $util.isString(message.user)))
                        return "user: buffer expected";
                if (message.password != null && message.hasOwnProperty("password"))
                    if (!(message.password && typeof message.password.length === "number" || $util.isString(message.password)))
                        return "password: buffer expected";
                return null;
            };

            /**
             * Creates a LoginRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.LoginRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.LoginRequest} LoginRequest
             */
            LoginRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.LoginRequest)
                    return object;
                let message = new $root.immudb.schema.LoginRequest();
                if (object.user != null)
                    if (typeof object.user === "string")
                        $util.base64.decode(object.user, message.user = $util.newBuffer($util.base64.length(object.user)), 0);
                    else if (object.user.length >= 0)
                        message.user = object.user;
                if (object.password != null)
                    if (typeof object.password === "string")
                        $util.base64.decode(object.password, message.password = $util.newBuffer($util.base64.length(object.password)), 0);
                    else if (object.password.length >= 0)
                        message.password = object.password;
                return message;
            };

            /**
             * Creates a plain object from a LoginRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.LoginRequest
             * @static
             * @param {immudb.schema.LoginRequest} message LoginRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LoginRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.user = "";
                    else {
                        object.user = [];
                        if (options.bytes !== Array)
                            object.user = $util.newBuffer(object.user);
                    }
                    if (options.bytes === String)
                        object.password = "";
                    else {
                        object.password = [];
                        if (options.bytes !== Array)
                            object.password = $util.newBuffer(object.password);
                    }
                }
                if (message.user != null && message.hasOwnProperty("user"))
                    object.user = options.bytes === String ? $util.base64.encode(message.user, 0, message.user.length) : options.bytes === Array ? Array.prototype.slice.call(message.user) : message.user;
                if (message.password != null && message.hasOwnProperty("password"))
                    object.password = options.bytes === String ? $util.base64.encode(message.password, 0, message.password.length) : options.bytes === Array ? Array.prototype.slice.call(message.password) : message.password;
                return object;
            };

            /**
             * Converts this LoginRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.LoginRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LoginRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LoginRequest
             * @function getTypeUrl
             * @memberof immudb.schema.LoginRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LoginRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.LoginRequest";
            };

            return LoginRequest;
        })();

        schema.LoginResponse = (function() {

            /**
             * Properties of a LoginResponse.
             * @memberof immudb.schema
             * @interface ILoginResponse
             * @property {string|null} [token] LoginResponse token
             * @property {Uint8Array|null} [warning] LoginResponse warning
             */

            /**
             * Constructs a new LoginResponse.
             * @memberof immudb.schema
             * @classdesc Represents a LoginResponse.
             * @implements ILoginResponse
             * @constructor
             * @param {immudb.schema.ILoginResponse=} [properties] Properties to set
             */
            function LoginResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LoginResponse token.
             * @member {string} token
             * @memberof immudb.schema.LoginResponse
             * @instance
             */
            LoginResponse.prototype.token = "";

            /**
             * LoginResponse warning.
             * @member {Uint8Array} warning
             * @memberof immudb.schema.LoginResponse
             * @instance
             */
            LoginResponse.prototype.warning = $util.newBuffer([]);

            /**
             * Creates a new LoginResponse instance using the specified properties.
             * @function create
             * @memberof immudb.schema.LoginResponse
             * @static
             * @param {immudb.schema.ILoginResponse=} [properties] Properties to set
             * @returns {immudb.schema.LoginResponse} LoginResponse instance
             */
            LoginResponse.create = function create(properties) {
                return new LoginResponse(properties);
            };

            /**
             * Encodes the specified LoginResponse message. Does not implicitly {@link immudb.schema.LoginResponse.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.LoginResponse
             * @static
             * @param {immudb.schema.ILoginResponse} message LoginResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoginResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.token);
                if (message.warning != null && Object.hasOwnProperty.call(message, "warning"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.warning);
                return writer;
            };

            /**
             * Encodes the specified LoginResponse message, length delimited. Does not implicitly {@link immudb.schema.LoginResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.LoginResponse
             * @static
             * @param {immudb.schema.ILoginResponse} message LoginResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoginResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LoginResponse message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.LoginResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.LoginResponse} LoginResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoginResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.LoginResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.token = reader.string();
                            break;
                        }
                    case 2: {
                            message.warning = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LoginResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.LoginResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.LoginResponse} LoginResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoginResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LoginResponse message.
             * @function verify
             * @memberof immudb.schema.LoginResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LoginResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                if (message.warning != null && message.hasOwnProperty("warning"))
                    if (!(message.warning && typeof message.warning.length === "number" || $util.isString(message.warning)))
                        return "warning: buffer expected";
                return null;
            };

            /**
             * Creates a LoginResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.LoginResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.LoginResponse} LoginResponse
             */
            LoginResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.LoginResponse)
                    return object;
                let message = new $root.immudb.schema.LoginResponse();
                if (object.token != null)
                    message.token = String(object.token);
                if (object.warning != null)
                    if (typeof object.warning === "string")
                        $util.base64.decode(object.warning, message.warning = $util.newBuffer($util.base64.length(object.warning)), 0);
                    else if (object.warning.length >= 0)
                        message.warning = object.warning;
                return message;
            };

            /**
             * Creates a plain object from a LoginResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.LoginResponse
             * @static
             * @param {immudb.schema.LoginResponse} message LoginResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LoginResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.token = "";
                    if (options.bytes === String)
                        object.warning = "";
                    else {
                        object.warning = [];
                        if (options.bytes !== Array)
                            object.warning = $util.newBuffer(object.warning);
                    }
                }
                if (message.token != null && message.hasOwnProperty("token"))
                    object.token = message.token;
                if (message.warning != null && message.hasOwnProperty("warning"))
                    object.warning = options.bytes === String ? $util.base64.encode(message.warning, 0, message.warning.length) : options.bytes === Array ? Array.prototype.slice.call(message.warning) : message.warning;
                return object;
            };

            /**
             * Converts this LoginResponse to JSON.
             * @function toJSON
             * @memberof immudb.schema.LoginResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LoginResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LoginResponse
             * @function getTypeUrl
             * @memberof immudb.schema.LoginResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LoginResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.LoginResponse";
            };

            return LoginResponse;
        })();

        schema.AuthConfig = (function() {

            /**
             * Properties of an AuthConfig.
             * @memberof immudb.schema
             * @interface IAuthConfig
             * @property {number|null} [kind] AuthConfig kind
             */

            /**
             * Constructs a new AuthConfig.
             * @memberof immudb.schema
             * @classdesc Represents an AuthConfig.
             * @implements IAuthConfig
             * @constructor
             * @param {immudb.schema.IAuthConfig=} [properties] Properties to set
             */
            function AuthConfig(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AuthConfig kind.
             * @member {number} kind
             * @memberof immudb.schema.AuthConfig
             * @instance
             */
            AuthConfig.prototype.kind = 0;

            /**
             * Creates a new AuthConfig instance using the specified properties.
             * @function create
             * @memberof immudb.schema.AuthConfig
             * @static
             * @param {immudb.schema.IAuthConfig=} [properties] Properties to set
             * @returns {immudb.schema.AuthConfig} AuthConfig instance
             */
            AuthConfig.create = function create(properties) {
                return new AuthConfig(properties);
            };

            /**
             * Encodes the specified AuthConfig message. Does not implicitly {@link immudb.schema.AuthConfig.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.AuthConfig
             * @static
             * @param {immudb.schema.IAuthConfig} message AuthConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AuthConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.kind != null && Object.hasOwnProperty.call(message, "kind"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.kind);
                return writer;
            };

            /**
             * Encodes the specified AuthConfig message, length delimited. Does not implicitly {@link immudb.schema.AuthConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.AuthConfig
             * @static
             * @param {immudb.schema.IAuthConfig} message AuthConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AuthConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AuthConfig message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.AuthConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.AuthConfig} AuthConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AuthConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.AuthConfig();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.kind = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AuthConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.AuthConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.AuthConfig} AuthConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AuthConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AuthConfig message.
             * @function verify
             * @memberof immudb.schema.AuthConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AuthConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.kind != null && message.hasOwnProperty("kind"))
                    if (!$util.isInteger(message.kind))
                        return "kind: integer expected";
                return null;
            };

            /**
             * Creates an AuthConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.AuthConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.AuthConfig} AuthConfig
             */
            AuthConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.AuthConfig)
                    return object;
                let message = new $root.immudb.schema.AuthConfig();
                if (object.kind != null)
                    message.kind = object.kind >>> 0;
                return message;
            };

            /**
             * Creates a plain object from an AuthConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.AuthConfig
             * @static
             * @param {immudb.schema.AuthConfig} message AuthConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AuthConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.kind = 0;
                if (message.kind != null && message.hasOwnProperty("kind"))
                    object.kind = message.kind;
                return object;
            };

            /**
             * Converts this AuthConfig to JSON.
             * @function toJSON
             * @memberof immudb.schema.AuthConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AuthConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AuthConfig
             * @function getTypeUrl
             * @memberof immudb.schema.AuthConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AuthConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.AuthConfig";
            };

            return AuthConfig;
        })();

        schema.MTLSConfig = (function() {

            /**
             * Properties of a MTLSConfig.
             * @memberof immudb.schema
             * @interface IMTLSConfig
             * @property {boolean|null} [enabled] MTLSConfig enabled
             */

            /**
             * Constructs a new MTLSConfig.
             * @memberof immudb.schema
             * @classdesc Represents a MTLSConfig.
             * @implements IMTLSConfig
             * @constructor
             * @param {immudb.schema.IMTLSConfig=} [properties] Properties to set
             */
            function MTLSConfig(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MTLSConfig enabled.
             * @member {boolean} enabled
             * @memberof immudb.schema.MTLSConfig
             * @instance
             */
            MTLSConfig.prototype.enabled = false;

            /**
             * Creates a new MTLSConfig instance using the specified properties.
             * @function create
             * @memberof immudb.schema.MTLSConfig
             * @static
             * @param {immudb.schema.IMTLSConfig=} [properties] Properties to set
             * @returns {immudb.schema.MTLSConfig} MTLSConfig instance
             */
            MTLSConfig.create = function create(properties) {
                return new MTLSConfig(properties);
            };

            /**
             * Encodes the specified MTLSConfig message. Does not implicitly {@link immudb.schema.MTLSConfig.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.MTLSConfig
             * @static
             * @param {immudb.schema.IMTLSConfig} message MTLSConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MTLSConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enabled);
                return writer;
            };

            /**
             * Encodes the specified MTLSConfig message, length delimited. Does not implicitly {@link immudb.schema.MTLSConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.MTLSConfig
             * @static
             * @param {immudb.schema.IMTLSConfig} message MTLSConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MTLSConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MTLSConfig message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.MTLSConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.MTLSConfig} MTLSConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MTLSConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.MTLSConfig();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.enabled = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MTLSConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.MTLSConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.MTLSConfig} MTLSConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MTLSConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MTLSConfig message.
             * @function verify
             * @memberof immudb.schema.MTLSConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MTLSConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.enabled != null && message.hasOwnProperty("enabled"))
                    if (typeof message.enabled !== "boolean")
                        return "enabled: boolean expected";
                return null;
            };

            /**
             * Creates a MTLSConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.MTLSConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.MTLSConfig} MTLSConfig
             */
            MTLSConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.MTLSConfig)
                    return object;
                let message = new $root.immudb.schema.MTLSConfig();
                if (object.enabled != null)
                    message.enabled = Boolean(object.enabled);
                return message;
            };

            /**
             * Creates a plain object from a MTLSConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.MTLSConfig
             * @static
             * @param {immudb.schema.MTLSConfig} message MTLSConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MTLSConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.enabled = false;
                if (message.enabled != null && message.hasOwnProperty("enabled"))
                    object.enabled = message.enabled;
                return object;
            };

            /**
             * Converts this MTLSConfig to JSON.
             * @function toJSON
             * @memberof immudb.schema.MTLSConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MTLSConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MTLSConfig
             * @function getTypeUrl
             * @memberof immudb.schema.MTLSConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MTLSConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.MTLSConfig";
            };

            return MTLSConfig;
        })();

        schema.OpenSessionRequest = (function() {

            /**
             * Properties of an OpenSessionRequest.
             * @memberof immudb.schema
             * @interface IOpenSessionRequest
             * @property {Uint8Array|null} [username] OpenSessionRequest username
             * @property {Uint8Array|null} [password] OpenSessionRequest password
             * @property {string|null} [databaseName] OpenSessionRequest databaseName
             */

            /**
             * Constructs a new OpenSessionRequest.
             * @memberof immudb.schema
             * @classdesc Represents an OpenSessionRequest.
             * @implements IOpenSessionRequest
             * @constructor
             * @param {immudb.schema.IOpenSessionRequest=} [properties] Properties to set
             */
            function OpenSessionRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OpenSessionRequest username.
             * @member {Uint8Array} username
             * @memberof immudb.schema.OpenSessionRequest
             * @instance
             */
            OpenSessionRequest.prototype.username = $util.newBuffer([]);

            /**
             * OpenSessionRequest password.
             * @member {Uint8Array} password
             * @memberof immudb.schema.OpenSessionRequest
             * @instance
             */
            OpenSessionRequest.prototype.password = $util.newBuffer([]);

            /**
             * OpenSessionRequest databaseName.
             * @member {string} databaseName
             * @memberof immudb.schema.OpenSessionRequest
             * @instance
             */
            OpenSessionRequest.prototype.databaseName = "";

            /**
             * Creates a new OpenSessionRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.OpenSessionRequest
             * @static
             * @param {immudb.schema.IOpenSessionRequest=} [properties] Properties to set
             * @returns {immudb.schema.OpenSessionRequest} OpenSessionRequest instance
             */
            OpenSessionRequest.create = function create(properties) {
                return new OpenSessionRequest(properties);
            };

            /**
             * Encodes the specified OpenSessionRequest message. Does not implicitly {@link immudb.schema.OpenSessionRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.OpenSessionRequest
             * @static
             * @param {immudb.schema.IOpenSessionRequest} message OpenSessionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OpenSessionRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.username);
                if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.password);
                if (message.databaseName != null && Object.hasOwnProperty.call(message, "databaseName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.databaseName);
                return writer;
            };

            /**
             * Encodes the specified OpenSessionRequest message, length delimited. Does not implicitly {@link immudb.schema.OpenSessionRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.OpenSessionRequest
             * @static
             * @param {immudb.schema.IOpenSessionRequest} message OpenSessionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OpenSessionRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OpenSessionRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.OpenSessionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.OpenSessionRequest} OpenSessionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OpenSessionRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.OpenSessionRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.username = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.password = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.databaseName = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OpenSessionRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.OpenSessionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.OpenSessionRequest} OpenSessionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OpenSessionRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OpenSessionRequest message.
             * @function verify
             * @memberof immudb.schema.OpenSessionRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OpenSessionRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.username != null && message.hasOwnProperty("username"))
                    if (!(message.username && typeof message.username.length === "number" || $util.isString(message.username)))
                        return "username: buffer expected";
                if (message.password != null && message.hasOwnProperty("password"))
                    if (!(message.password && typeof message.password.length === "number" || $util.isString(message.password)))
                        return "password: buffer expected";
                if (message.databaseName != null && message.hasOwnProperty("databaseName"))
                    if (!$util.isString(message.databaseName))
                        return "databaseName: string expected";
                return null;
            };

            /**
             * Creates an OpenSessionRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.OpenSessionRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.OpenSessionRequest} OpenSessionRequest
             */
            OpenSessionRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.OpenSessionRequest)
                    return object;
                let message = new $root.immudb.schema.OpenSessionRequest();
                if (object.username != null)
                    if (typeof object.username === "string")
                        $util.base64.decode(object.username, message.username = $util.newBuffer($util.base64.length(object.username)), 0);
                    else if (object.username.length >= 0)
                        message.username = object.username;
                if (object.password != null)
                    if (typeof object.password === "string")
                        $util.base64.decode(object.password, message.password = $util.newBuffer($util.base64.length(object.password)), 0);
                    else if (object.password.length >= 0)
                        message.password = object.password;
                if (object.databaseName != null)
                    message.databaseName = String(object.databaseName);
                return message;
            };

            /**
             * Creates a plain object from an OpenSessionRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.OpenSessionRequest
             * @static
             * @param {immudb.schema.OpenSessionRequest} message OpenSessionRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OpenSessionRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.username = "";
                    else {
                        object.username = [];
                        if (options.bytes !== Array)
                            object.username = $util.newBuffer(object.username);
                    }
                    if (options.bytes === String)
                        object.password = "";
                    else {
                        object.password = [];
                        if (options.bytes !== Array)
                            object.password = $util.newBuffer(object.password);
                    }
                    object.databaseName = "";
                }
                if (message.username != null && message.hasOwnProperty("username"))
                    object.username = options.bytes === String ? $util.base64.encode(message.username, 0, message.username.length) : options.bytes === Array ? Array.prototype.slice.call(message.username) : message.username;
                if (message.password != null && message.hasOwnProperty("password"))
                    object.password = options.bytes === String ? $util.base64.encode(message.password, 0, message.password.length) : options.bytes === Array ? Array.prototype.slice.call(message.password) : message.password;
                if (message.databaseName != null && message.hasOwnProperty("databaseName"))
                    object.databaseName = message.databaseName;
                return object;
            };

            /**
             * Converts this OpenSessionRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.OpenSessionRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OpenSessionRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for OpenSessionRequest
             * @function getTypeUrl
             * @memberof immudb.schema.OpenSessionRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            OpenSessionRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.OpenSessionRequest";
            };

            return OpenSessionRequest;
        })();

        schema.OpenSessionResponse = (function() {

            /**
             * Properties of an OpenSessionResponse.
             * @memberof immudb.schema
             * @interface IOpenSessionResponse
             * @property {string|null} [sessionID] OpenSessionResponse sessionID
             * @property {string|null} [serverUUID] OpenSessionResponse serverUUID
             */

            /**
             * Constructs a new OpenSessionResponse.
             * @memberof immudb.schema
             * @classdesc Represents an OpenSessionResponse.
             * @implements IOpenSessionResponse
             * @constructor
             * @param {immudb.schema.IOpenSessionResponse=} [properties] Properties to set
             */
            function OpenSessionResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OpenSessionResponse sessionID.
             * @member {string} sessionID
             * @memberof immudb.schema.OpenSessionResponse
             * @instance
             */
            OpenSessionResponse.prototype.sessionID = "";

            /**
             * OpenSessionResponse serverUUID.
             * @member {string} serverUUID
             * @memberof immudb.schema.OpenSessionResponse
             * @instance
             */
            OpenSessionResponse.prototype.serverUUID = "";

            /**
             * Creates a new OpenSessionResponse instance using the specified properties.
             * @function create
             * @memberof immudb.schema.OpenSessionResponse
             * @static
             * @param {immudb.schema.IOpenSessionResponse=} [properties] Properties to set
             * @returns {immudb.schema.OpenSessionResponse} OpenSessionResponse instance
             */
            OpenSessionResponse.create = function create(properties) {
                return new OpenSessionResponse(properties);
            };

            /**
             * Encodes the specified OpenSessionResponse message. Does not implicitly {@link immudb.schema.OpenSessionResponse.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.OpenSessionResponse
             * @static
             * @param {immudb.schema.IOpenSessionResponse} message OpenSessionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OpenSessionResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionID != null && Object.hasOwnProperty.call(message, "sessionID"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionID);
                if (message.serverUUID != null && Object.hasOwnProperty.call(message, "serverUUID"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.serverUUID);
                return writer;
            };

            /**
             * Encodes the specified OpenSessionResponse message, length delimited. Does not implicitly {@link immudb.schema.OpenSessionResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.OpenSessionResponse
             * @static
             * @param {immudb.schema.IOpenSessionResponse} message OpenSessionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OpenSessionResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OpenSessionResponse message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.OpenSessionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.OpenSessionResponse} OpenSessionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OpenSessionResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.OpenSessionResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.sessionID = reader.string();
                            break;
                        }
                    case 2: {
                            message.serverUUID = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OpenSessionResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.OpenSessionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.OpenSessionResponse} OpenSessionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OpenSessionResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OpenSessionResponse message.
             * @function verify
             * @memberof immudb.schema.OpenSessionResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OpenSessionResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionID != null && message.hasOwnProperty("sessionID"))
                    if (!$util.isString(message.sessionID))
                        return "sessionID: string expected";
                if (message.serverUUID != null && message.hasOwnProperty("serverUUID"))
                    if (!$util.isString(message.serverUUID))
                        return "serverUUID: string expected";
                return null;
            };

            /**
             * Creates an OpenSessionResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.OpenSessionResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.OpenSessionResponse} OpenSessionResponse
             */
            OpenSessionResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.OpenSessionResponse)
                    return object;
                let message = new $root.immudb.schema.OpenSessionResponse();
                if (object.sessionID != null)
                    message.sessionID = String(object.sessionID);
                if (object.serverUUID != null)
                    message.serverUUID = String(object.serverUUID);
                return message;
            };

            /**
             * Creates a plain object from an OpenSessionResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.OpenSessionResponse
             * @static
             * @param {immudb.schema.OpenSessionResponse} message OpenSessionResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OpenSessionResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.sessionID = "";
                    object.serverUUID = "";
                }
                if (message.sessionID != null && message.hasOwnProperty("sessionID"))
                    object.sessionID = message.sessionID;
                if (message.serverUUID != null && message.hasOwnProperty("serverUUID"))
                    object.serverUUID = message.serverUUID;
                return object;
            };

            /**
             * Converts this OpenSessionResponse to JSON.
             * @function toJSON
             * @memberof immudb.schema.OpenSessionResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OpenSessionResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for OpenSessionResponse
             * @function getTypeUrl
             * @memberof immudb.schema.OpenSessionResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            OpenSessionResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.OpenSessionResponse";
            };

            return OpenSessionResponse;
        })();

        schema.Precondition = (function() {

            /**
             * Properties of a Precondition.
             * @memberof immudb.schema
             * @interface IPrecondition
             * @property {immudb.schema.Precondition.IKeyMustExistPrecondition|null} [keyMustExist] Precondition keyMustExist
             * @property {immudb.schema.Precondition.IKeyMustNotExistPrecondition|null} [keyMustNotExist] Precondition keyMustNotExist
             * @property {immudb.schema.Precondition.IKeyNotModifiedAfterTXPrecondition|null} [keyNotModifiedAfterTX] Precondition keyNotModifiedAfterTX
             */

            /**
             * Constructs a new Precondition.
             * @memberof immudb.schema
             * @classdesc Represents a Precondition.
             * @implements IPrecondition
             * @constructor
             * @param {immudb.schema.IPrecondition=} [properties] Properties to set
             */
            function Precondition(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Precondition keyMustExist.
             * @member {immudb.schema.Precondition.IKeyMustExistPrecondition|null|undefined} keyMustExist
             * @memberof immudb.schema.Precondition
             * @instance
             */
            Precondition.prototype.keyMustExist = null;

            /**
             * Precondition keyMustNotExist.
             * @member {immudb.schema.Precondition.IKeyMustNotExistPrecondition|null|undefined} keyMustNotExist
             * @memberof immudb.schema.Precondition
             * @instance
             */
            Precondition.prototype.keyMustNotExist = null;

            /**
             * Precondition keyNotModifiedAfterTX.
             * @member {immudb.schema.Precondition.IKeyNotModifiedAfterTXPrecondition|null|undefined} keyNotModifiedAfterTX
             * @memberof immudb.schema.Precondition
             * @instance
             */
            Precondition.prototype.keyNotModifiedAfterTX = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Precondition precondition.
             * @member {"keyMustExist"|"keyMustNotExist"|"keyNotModifiedAfterTX"|undefined} precondition
             * @memberof immudb.schema.Precondition
             * @instance
             */
            Object.defineProperty(Precondition.prototype, "precondition", {
                get: $util.oneOfGetter($oneOfFields = ["keyMustExist", "keyMustNotExist", "keyNotModifiedAfterTX"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Precondition instance using the specified properties.
             * @function create
             * @memberof immudb.schema.Precondition
             * @static
             * @param {immudb.schema.IPrecondition=} [properties] Properties to set
             * @returns {immudb.schema.Precondition} Precondition instance
             */
            Precondition.create = function create(properties) {
                return new Precondition(properties);
            };

            /**
             * Encodes the specified Precondition message. Does not implicitly {@link immudb.schema.Precondition.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.Precondition
             * @static
             * @param {immudb.schema.IPrecondition} message Precondition message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Precondition.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.keyMustExist != null && Object.hasOwnProperty.call(message, "keyMustExist"))
                    $root.immudb.schema.Precondition.KeyMustExistPrecondition.encode(message.keyMustExist, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.keyMustNotExist != null && Object.hasOwnProperty.call(message, "keyMustNotExist"))
                    $root.immudb.schema.Precondition.KeyMustNotExistPrecondition.encode(message.keyMustNotExist, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.keyNotModifiedAfterTX != null && Object.hasOwnProperty.call(message, "keyNotModifiedAfterTX"))
                    $root.immudb.schema.Precondition.KeyNotModifiedAfterTXPrecondition.encode(message.keyNotModifiedAfterTX, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Precondition message, length delimited. Does not implicitly {@link immudb.schema.Precondition.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.Precondition
             * @static
             * @param {immudb.schema.IPrecondition} message Precondition message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Precondition.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Precondition message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.Precondition
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.Precondition} Precondition
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Precondition.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.Precondition();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.keyMustExist = $root.immudb.schema.Precondition.KeyMustExistPrecondition.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.keyMustNotExist = $root.immudb.schema.Precondition.KeyMustNotExistPrecondition.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.keyNotModifiedAfterTX = $root.immudb.schema.Precondition.KeyNotModifiedAfterTXPrecondition.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Precondition message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.Precondition
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.Precondition} Precondition
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Precondition.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Precondition message.
             * @function verify
             * @memberof immudb.schema.Precondition
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Precondition.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.keyMustExist != null && message.hasOwnProperty("keyMustExist")) {
                    properties.precondition = 1;
                    {
                        let error = $root.immudb.schema.Precondition.KeyMustExistPrecondition.verify(message.keyMustExist);
                        if (error)
                            return "keyMustExist." + error;
                    }
                }
                if (message.keyMustNotExist != null && message.hasOwnProperty("keyMustNotExist")) {
                    if (properties.precondition === 1)
                        return "precondition: multiple values";
                    properties.precondition = 1;
                    {
                        let error = $root.immudb.schema.Precondition.KeyMustNotExistPrecondition.verify(message.keyMustNotExist);
                        if (error)
                            return "keyMustNotExist." + error;
                    }
                }
                if (message.keyNotModifiedAfterTX != null && message.hasOwnProperty("keyNotModifiedAfterTX")) {
                    if (properties.precondition === 1)
                        return "precondition: multiple values";
                    properties.precondition = 1;
                    {
                        let error = $root.immudb.schema.Precondition.KeyNotModifiedAfterTXPrecondition.verify(message.keyNotModifiedAfterTX);
                        if (error)
                            return "keyNotModifiedAfterTX." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Precondition message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.Precondition
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.Precondition} Precondition
             */
            Precondition.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.Precondition)
                    return object;
                let message = new $root.immudb.schema.Precondition();
                if (object.keyMustExist != null) {
                    if (typeof object.keyMustExist !== "object")
                        throw TypeError(".immudb.schema.Precondition.keyMustExist: object expected");
                    message.keyMustExist = $root.immudb.schema.Precondition.KeyMustExistPrecondition.fromObject(object.keyMustExist);
                }
                if (object.keyMustNotExist != null) {
                    if (typeof object.keyMustNotExist !== "object")
                        throw TypeError(".immudb.schema.Precondition.keyMustNotExist: object expected");
                    message.keyMustNotExist = $root.immudb.schema.Precondition.KeyMustNotExistPrecondition.fromObject(object.keyMustNotExist);
                }
                if (object.keyNotModifiedAfterTX != null) {
                    if (typeof object.keyNotModifiedAfterTX !== "object")
                        throw TypeError(".immudb.schema.Precondition.keyNotModifiedAfterTX: object expected");
                    message.keyNotModifiedAfterTX = $root.immudb.schema.Precondition.KeyNotModifiedAfterTXPrecondition.fromObject(object.keyNotModifiedAfterTX);
                }
                return message;
            };

            /**
             * Creates a plain object from a Precondition message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.Precondition
             * @static
             * @param {immudb.schema.Precondition} message Precondition
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Precondition.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.keyMustExist != null && message.hasOwnProperty("keyMustExist")) {
                    object.keyMustExist = $root.immudb.schema.Precondition.KeyMustExistPrecondition.toObject(message.keyMustExist, options);
                    if (options.oneofs)
                        object.precondition = "keyMustExist";
                }
                if (message.keyMustNotExist != null && message.hasOwnProperty("keyMustNotExist")) {
                    object.keyMustNotExist = $root.immudb.schema.Precondition.KeyMustNotExistPrecondition.toObject(message.keyMustNotExist, options);
                    if (options.oneofs)
                        object.precondition = "keyMustNotExist";
                }
                if (message.keyNotModifiedAfterTX != null && message.hasOwnProperty("keyNotModifiedAfterTX")) {
                    object.keyNotModifiedAfterTX = $root.immudb.schema.Precondition.KeyNotModifiedAfterTXPrecondition.toObject(message.keyNotModifiedAfterTX, options);
                    if (options.oneofs)
                        object.precondition = "keyNotModifiedAfterTX";
                }
                return object;
            };

            /**
             * Converts this Precondition to JSON.
             * @function toJSON
             * @memberof immudb.schema.Precondition
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Precondition.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Precondition
             * @function getTypeUrl
             * @memberof immudb.schema.Precondition
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Precondition.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.Precondition";
            };

            Precondition.KeyMustExistPrecondition = (function() {

                /**
                 * Properties of a KeyMustExistPrecondition.
                 * @memberof immudb.schema.Precondition
                 * @interface IKeyMustExistPrecondition
                 * @property {Uint8Array|null} [key] KeyMustExistPrecondition key
                 */

                /**
                 * Constructs a new KeyMustExistPrecondition.
                 * @memberof immudb.schema.Precondition
                 * @classdesc Represents a KeyMustExistPrecondition.
                 * @implements IKeyMustExistPrecondition
                 * @constructor
                 * @param {immudb.schema.Precondition.IKeyMustExistPrecondition=} [properties] Properties to set
                 */
                function KeyMustExistPrecondition(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * KeyMustExistPrecondition key.
                 * @member {Uint8Array} key
                 * @memberof immudb.schema.Precondition.KeyMustExistPrecondition
                 * @instance
                 */
                KeyMustExistPrecondition.prototype.key = $util.newBuffer([]);

                /**
                 * Creates a new KeyMustExistPrecondition instance using the specified properties.
                 * @function create
                 * @memberof immudb.schema.Precondition.KeyMustExistPrecondition
                 * @static
                 * @param {immudb.schema.Precondition.IKeyMustExistPrecondition=} [properties] Properties to set
                 * @returns {immudb.schema.Precondition.KeyMustExistPrecondition} KeyMustExistPrecondition instance
                 */
                KeyMustExistPrecondition.create = function create(properties) {
                    return new KeyMustExistPrecondition(properties);
                };

                /**
                 * Encodes the specified KeyMustExistPrecondition message. Does not implicitly {@link immudb.schema.Precondition.KeyMustExistPrecondition.verify|verify} messages.
                 * @function encode
                 * @memberof immudb.schema.Precondition.KeyMustExistPrecondition
                 * @static
                 * @param {immudb.schema.Precondition.IKeyMustExistPrecondition} message KeyMustExistPrecondition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                KeyMustExistPrecondition.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
                    return writer;
                };

                /**
                 * Encodes the specified KeyMustExistPrecondition message, length delimited. Does not implicitly {@link immudb.schema.Precondition.KeyMustExistPrecondition.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof immudb.schema.Precondition.KeyMustExistPrecondition
                 * @static
                 * @param {immudb.schema.Precondition.IKeyMustExistPrecondition} message KeyMustExistPrecondition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                KeyMustExistPrecondition.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a KeyMustExistPrecondition message from the specified reader or buffer.
                 * @function decode
                 * @memberof immudb.schema.Precondition.KeyMustExistPrecondition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {immudb.schema.Precondition.KeyMustExistPrecondition} KeyMustExistPrecondition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                KeyMustExistPrecondition.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.Precondition.KeyMustExistPrecondition();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.key = reader.bytes();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a KeyMustExistPrecondition message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof immudb.schema.Precondition.KeyMustExistPrecondition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {immudb.schema.Precondition.KeyMustExistPrecondition} KeyMustExistPrecondition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                KeyMustExistPrecondition.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a KeyMustExistPrecondition message.
                 * @function verify
                 * @memberof immudb.schema.Precondition.KeyMustExistPrecondition
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                KeyMustExistPrecondition.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.key != null && message.hasOwnProperty("key"))
                        if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                            return "key: buffer expected";
                    return null;
                };

                /**
                 * Creates a KeyMustExistPrecondition message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof immudb.schema.Precondition.KeyMustExistPrecondition
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {immudb.schema.Precondition.KeyMustExistPrecondition} KeyMustExistPrecondition
                 */
                KeyMustExistPrecondition.fromObject = function fromObject(object) {
                    if (object instanceof $root.immudb.schema.Precondition.KeyMustExistPrecondition)
                        return object;
                    let message = new $root.immudb.schema.Precondition.KeyMustExistPrecondition();
                    if (object.key != null)
                        if (typeof object.key === "string")
                            $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                        else if (object.key.length >= 0)
                            message.key = object.key;
                    return message;
                };

                /**
                 * Creates a plain object from a KeyMustExistPrecondition message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof immudb.schema.Precondition.KeyMustExistPrecondition
                 * @static
                 * @param {immudb.schema.Precondition.KeyMustExistPrecondition} message KeyMustExistPrecondition
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                KeyMustExistPrecondition.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        if (options.bytes === String)
                            object.key = "";
                        else {
                            object.key = [];
                            if (options.bytes !== Array)
                                object.key = $util.newBuffer(object.key);
                        }
                    if (message.key != null && message.hasOwnProperty("key"))
                        object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                    return object;
                };

                /**
                 * Converts this KeyMustExistPrecondition to JSON.
                 * @function toJSON
                 * @memberof immudb.schema.Precondition.KeyMustExistPrecondition
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                KeyMustExistPrecondition.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for KeyMustExistPrecondition
                 * @function getTypeUrl
                 * @memberof immudb.schema.Precondition.KeyMustExistPrecondition
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                KeyMustExistPrecondition.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/immudb.schema.Precondition.KeyMustExistPrecondition";
                };

                return KeyMustExistPrecondition;
            })();

            Precondition.KeyMustNotExistPrecondition = (function() {

                /**
                 * Properties of a KeyMustNotExistPrecondition.
                 * @memberof immudb.schema.Precondition
                 * @interface IKeyMustNotExistPrecondition
                 * @property {Uint8Array|null} [key] KeyMustNotExistPrecondition key
                 */

                /**
                 * Constructs a new KeyMustNotExistPrecondition.
                 * @memberof immudb.schema.Precondition
                 * @classdesc Represents a KeyMustNotExistPrecondition.
                 * @implements IKeyMustNotExistPrecondition
                 * @constructor
                 * @param {immudb.schema.Precondition.IKeyMustNotExistPrecondition=} [properties] Properties to set
                 */
                function KeyMustNotExistPrecondition(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * KeyMustNotExistPrecondition key.
                 * @member {Uint8Array} key
                 * @memberof immudb.schema.Precondition.KeyMustNotExistPrecondition
                 * @instance
                 */
                KeyMustNotExistPrecondition.prototype.key = $util.newBuffer([]);

                /**
                 * Creates a new KeyMustNotExistPrecondition instance using the specified properties.
                 * @function create
                 * @memberof immudb.schema.Precondition.KeyMustNotExistPrecondition
                 * @static
                 * @param {immudb.schema.Precondition.IKeyMustNotExistPrecondition=} [properties] Properties to set
                 * @returns {immudb.schema.Precondition.KeyMustNotExistPrecondition} KeyMustNotExistPrecondition instance
                 */
                KeyMustNotExistPrecondition.create = function create(properties) {
                    return new KeyMustNotExistPrecondition(properties);
                };

                /**
                 * Encodes the specified KeyMustNotExistPrecondition message. Does not implicitly {@link immudb.schema.Precondition.KeyMustNotExistPrecondition.verify|verify} messages.
                 * @function encode
                 * @memberof immudb.schema.Precondition.KeyMustNotExistPrecondition
                 * @static
                 * @param {immudb.schema.Precondition.IKeyMustNotExistPrecondition} message KeyMustNotExistPrecondition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                KeyMustNotExistPrecondition.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
                    return writer;
                };

                /**
                 * Encodes the specified KeyMustNotExistPrecondition message, length delimited. Does not implicitly {@link immudb.schema.Precondition.KeyMustNotExistPrecondition.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof immudb.schema.Precondition.KeyMustNotExistPrecondition
                 * @static
                 * @param {immudb.schema.Precondition.IKeyMustNotExistPrecondition} message KeyMustNotExistPrecondition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                KeyMustNotExistPrecondition.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a KeyMustNotExistPrecondition message from the specified reader or buffer.
                 * @function decode
                 * @memberof immudb.schema.Precondition.KeyMustNotExistPrecondition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {immudb.schema.Precondition.KeyMustNotExistPrecondition} KeyMustNotExistPrecondition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                KeyMustNotExistPrecondition.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.Precondition.KeyMustNotExistPrecondition();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.key = reader.bytes();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a KeyMustNotExistPrecondition message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof immudb.schema.Precondition.KeyMustNotExistPrecondition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {immudb.schema.Precondition.KeyMustNotExistPrecondition} KeyMustNotExistPrecondition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                KeyMustNotExistPrecondition.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a KeyMustNotExistPrecondition message.
                 * @function verify
                 * @memberof immudb.schema.Precondition.KeyMustNotExistPrecondition
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                KeyMustNotExistPrecondition.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.key != null && message.hasOwnProperty("key"))
                        if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                            return "key: buffer expected";
                    return null;
                };

                /**
                 * Creates a KeyMustNotExistPrecondition message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof immudb.schema.Precondition.KeyMustNotExistPrecondition
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {immudb.schema.Precondition.KeyMustNotExistPrecondition} KeyMustNotExistPrecondition
                 */
                KeyMustNotExistPrecondition.fromObject = function fromObject(object) {
                    if (object instanceof $root.immudb.schema.Precondition.KeyMustNotExistPrecondition)
                        return object;
                    let message = new $root.immudb.schema.Precondition.KeyMustNotExistPrecondition();
                    if (object.key != null)
                        if (typeof object.key === "string")
                            $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                        else if (object.key.length >= 0)
                            message.key = object.key;
                    return message;
                };

                /**
                 * Creates a plain object from a KeyMustNotExistPrecondition message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof immudb.schema.Precondition.KeyMustNotExistPrecondition
                 * @static
                 * @param {immudb.schema.Precondition.KeyMustNotExistPrecondition} message KeyMustNotExistPrecondition
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                KeyMustNotExistPrecondition.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        if (options.bytes === String)
                            object.key = "";
                        else {
                            object.key = [];
                            if (options.bytes !== Array)
                                object.key = $util.newBuffer(object.key);
                        }
                    if (message.key != null && message.hasOwnProperty("key"))
                        object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                    return object;
                };

                /**
                 * Converts this KeyMustNotExistPrecondition to JSON.
                 * @function toJSON
                 * @memberof immudb.schema.Precondition.KeyMustNotExistPrecondition
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                KeyMustNotExistPrecondition.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for KeyMustNotExistPrecondition
                 * @function getTypeUrl
                 * @memberof immudb.schema.Precondition.KeyMustNotExistPrecondition
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                KeyMustNotExistPrecondition.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/immudb.schema.Precondition.KeyMustNotExistPrecondition";
                };

                return KeyMustNotExistPrecondition;
            })();

            Precondition.KeyNotModifiedAfterTXPrecondition = (function() {

                /**
                 * Properties of a KeyNotModifiedAfterTXPrecondition.
                 * @memberof immudb.schema.Precondition
                 * @interface IKeyNotModifiedAfterTXPrecondition
                 * @property {Uint8Array|null} [key] KeyNotModifiedAfterTXPrecondition key
                 * @property {Long|null} [txID] KeyNotModifiedAfterTXPrecondition txID
                 */

                /**
                 * Constructs a new KeyNotModifiedAfterTXPrecondition.
                 * @memberof immudb.schema.Precondition
                 * @classdesc Represents a KeyNotModifiedAfterTXPrecondition.
                 * @implements IKeyNotModifiedAfterTXPrecondition
                 * @constructor
                 * @param {immudb.schema.Precondition.IKeyNotModifiedAfterTXPrecondition=} [properties] Properties to set
                 */
                function KeyNotModifiedAfterTXPrecondition(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * KeyNotModifiedAfterTXPrecondition key.
                 * @member {Uint8Array} key
                 * @memberof immudb.schema.Precondition.KeyNotModifiedAfterTXPrecondition
                 * @instance
                 */
                KeyNotModifiedAfterTXPrecondition.prototype.key = $util.newBuffer([]);

                /**
                 * KeyNotModifiedAfterTXPrecondition txID.
                 * @member {Long} txID
                 * @memberof immudb.schema.Precondition.KeyNotModifiedAfterTXPrecondition
                 * @instance
                 */
                KeyNotModifiedAfterTXPrecondition.prototype.txID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Creates a new KeyNotModifiedAfterTXPrecondition instance using the specified properties.
                 * @function create
                 * @memberof immudb.schema.Precondition.KeyNotModifiedAfterTXPrecondition
                 * @static
                 * @param {immudb.schema.Precondition.IKeyNotModifiedAfterTXPrecondition=} [properties] Properties to set
                 * @returns {immudb.schema.Precondition.KeyNotModifiedAfterTXPrecondition} KeyNotModifiedAfterTXPrecondition instance
                 */
                KeyNotModifiedAfterTXPrecondition.create = function create(properties) {
                    return new KeyNotModifiedAfterTXPrecondition(properties);
                };

                /**
                 * Encodes the specified KeyNotModifiedAfterTXPrecondition message. Does not implicitly {@link immudb.schema.Precondition.KeyNotModifiedAfterTXPrecondition.verify|verify} messages.
                 * @function encode
                 * @memberof immudb.schema.Precondition.KeyNotModifiedAfterTXPrecondition
                 * @static
                 * @param {immudb.schema.Precondition.IKeyNotModifiedAfterTXPrecondition} message KeyNotModifiedAfterTXPrecondition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                KeyNotModifiedAfterTXPrecondition.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
                    if (message.txID != null && Object.hasOwnProperty.call(message, "txID"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.txID);
                    return writer;
                };

                /**
                 * Encodes the specified KeyNotModifiedAfterTXPrecondition message, length delimited. Does not implicitly {@link immudb.schema.Precondition.KeyNotModifiedAfterTXPrecondition.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof immudb.schema.Precondition.KeyNotModifiedAfterTXPrecondition
                 * @static
                 * @param {immudb.schema.Precondition.IKeyNotModifiedAfterTXPrecondition} message KeyNotModifiedAfterTXPrecondition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                KeyNotModifiedAfterTXPrecondition.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a KeyNotModifiedAfterTXPrecondition message from the specified reader or buffer.
                 * @function decode
                 * @memberof immudb.schema.Precondition.KeyNotModifiedAfterTXPrecondition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {immudb.schema.Precondition.KeyNotModifiedAfterTXPrecondition} KeyNotModifiedAfterTXPrecondition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                KeyNotModifiedAfterTXPrecondition.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.Precondition.KeyNotModifiedAfterTXPrecondition();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.key = reader.bytes();
                                break;
                            }
                        case 2: {
                                message.txID = reader.uint64();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a KeyNotModifiedAfterTXPrecondition message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof immudb.schema.Precondition.KeyNotModifiedAfterTXPrecondition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {immudb.schema.Precondition.KeyNotModifiedAfterTXPrecondition} KeyNotModifiedAfterTXPrecondition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                KeyNotModifiedAfterTXPrecondition.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a KeyNotModifiedAfterTXPrecondition message.
                 * @function verify
                 * @memberof immudb.schema.Precondition.KeyNotModifiedAfterTXPrecondition
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                KeyNotModifiedAfterTXPrecondition.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.key != null && message.hasOwnProperty("key"))
                        if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                            return "key: buffer expected";
                    if (message.txID != null && message.hasOwnProperty("txID"))
                        if (!$util.isInteger(message.txID) && !(message.txID && $util.isInteger(message.txID.low) && $util.isInteger(message.txID.high)))
                            return "txID: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a KeyNotModifiedAfterTXPrecondition message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof immudb.schema.Precondition.KeyNotModifiedAfterTXPrecondition
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {immudb.schema.Precondition.KeyNotModifiedAfterTXPrecondition} KeyNotModifiedAfterTXPrecondition
                 */
                KeyNotModifiedAfterTXPrecondition.fromObject = function fromObject(object) {
                    if (object instanceof $root.immudb.schema.Precondition.KeyNotModifiedAfterTXPrecondition)
                        return object;
                    let message = new $root.immudb.schema.Precondition.KeyNotModifiedAfterTXPrecondition();
                    if (object.key != null)
                        if (typeof object.key === "string")
                            $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                        else if (object.key.length >= 0)
                            message.key = object.key;
                    if (object.txID != null)
                        if ($util.Long)
                            (message.txID = $util.Long.fromValue(object.txID)).unsigned = true;
                        else if (typeof object.txID === "string")
                            message.txID = parseInt(object.txID, 10);
                        else if (typeof object.txID === "number")
                            message.txID = object.txID;
                        else if (typeof object.txID === "object")
                            message.txID = new $util.LongBits(object.txID.low >>> 0, object.txID.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a KeyNotModifiedAfterTXPrecondition message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof immudb.schema.Precondition.KeyNotModifiedAfterTXPrecondition
                 * @static
                 * @param {immudb.schema.Precondition.KeyNotModifiedAfterTXPrecondition} message KeyNotModifiedAfterTXPrecondition
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                KeyNotModifiedAfterTXPrecondition.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.key = "";
                        else {
                            object.key = [];
                            if (options.bytes !== Array)
                                object.key = $util.newBuffer(object.key);
                        }
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.txID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.txID = options.longs === String ? "0" : 0;
                    }
                    if (message.key != null && message.hasOwnProperty("key"))
                        object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                    if (message.txID != null && message.hasOwnProperty("txID"))
                        if (typeof message.txID === "number")
                            object.txID = options.longs === String ? String(message.txID) : message.txID;
                        else
                            object.txID = options.longs === String ? $util.Long.prototype.toString.call(message.txID) : options.longs === Number ? new $util.LongBits(message.txID.low >>> 0, message.txID.high >>> 0).toNumber(true) : message.txID;
                    return object;
                };

                /**
                 * Converts this KeyNotModifiedAfterTXPrecondition to JSON.
                 * @function toJSON
                 * @memberof immudb.schema.Precondition.KeyNotModifiedAfterTXPrecondition
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                KeyNotModifiedAfterTXPrecondition.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for KeyNotModifiedAfterTXPrecondition
                 * @function getTypeUrl
                 * @memberof immudb.schema.Precondition.KeyNotModifiedAfterTXPrecondition
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                KeyNotModifiedAfterTXPrecondition.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/immudb.schema.Precondition.KeyNotModifiedAfterTXPrecondition";
                };

                return KeyNotModifiedAfterTXPrecondition;
            })();

            return Precondition;
        })();

        schema.KeyValue = (function() {

            /**
             * Properties of a KeyValue.
             * @memberof immudb.schema
             * @interface IKeyValue
             * @property {Uint8Array|null} [key] KeyValue key
             * @property {Uint8Array|null} [value] KeyValue value
             * @property {immudb.schema.IKVMetadata|null} [metadata] KeyValue metadata
             */

            /**
             * Constructs a new KeyValue.
             * @memberof immudb.schema
             * @classdesc Represents a KeyValue.
             * @implements IKeyValue
             * @constructor
             * @param {immudb.schema.IKeyValue=} [properties] Properties to set
             */
            function KeyValue(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KeyValue key.
             * @member {Uint8Array} key
             * @memberof immudb.schema.KeyValue
             * @instance
             */
            KeyValue.prototype.key = $util.newBuffer([]);

            /**
             * KeyValue value.
             * @member {Uint8Array} value
             * @memberof immudb.schema.KeyValue
             * @instance
             */
            KeyValue.prototype.value = $util.newBuffer([]);

            /**
             * KeyValue metadata.
             * @member {immudb.schema.IKVMetadata|null|undefined} metadata
             * @memberof immudb.schema.KeyValue
             * @instance
             */
            KeyValue.prototype.metadata = null;

            /**
             * Creates a new KeyValue instance using the specified properties.
             * @function create
             * @memberof immudb.schema.KeyValue
             * @static
             * @param {immudb.schema.IKeyValue=} [properties] Properties to set
             * @returns {immudb.schema.KeyValue} KeyValue instance
             */
            KeyValue.create = function create(properties) {
                return new KeyValue(properties);
            };

            /**
             * Encodes the specified KeyValue message. Does not implicitly {@link immudb.schema.KeyValue.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.KeyValue
             * @static
             * @param {immudb.schema.IKeyValue} message KeyValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    $root.immudb.schema.KVMetadata.encode(message.metadata, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified KeyValue message, length delimited. Does not implicitly {@link immudb.schema.KeyValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.KeyValue
             * @static
             * @param {immudb.schema.IKeyValue} message KeyValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KeyValue message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.KeyValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.KeyValue} KeyValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.KeyValue();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.key = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.value = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.metadata = $root.immudb.schema.KVMetadata.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KeyValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.KeyValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.KeyValue} KeyValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KeyValue message.
             * @function verify
             * @memberof immudb.schema.KeyValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KeyValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                        return "key: buffer expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    let error = $root.immudb.schema.KVMetadata.verify(message.metadata);
                    if (error)
                        return "metadata." + error;
                }
                return null;
            };

            /**
             * Creates a KeyValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.KeyValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.KeyValue} KeyValue
             */
            KeyValue.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.KeyValue)
                    return object;
                let message = new $root.immudb.schema.KeyValue();
                if (object.key != null)
                    if (typeof object.key === "string")
                        $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                    else if (object.key.length >= 0)
                        message.key = object.key;
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length >= 0)
                        message.value = object.value;
                if (object.metadata != null) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".immudb.schema.KeyValue.metadata: object expected");
                    message.metadata = $root.immudb.schema.KVMetadata.fromObject(object.metadata);
                }
                return message;
            };

            /**
             * Creates a plain object from a KeyValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.KeyValue
             * @static
             * @param {immudb.schema.KeyValue} message KeyValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KeyValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.key = "";
                    else {
                        object.key = [];
                        if (options.bytes !== Array)
                            object.key = $util.newBuffer(object.key);
                    }
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    object.metadata = null;
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = $root.immudb.schema.KVMetadata.toObject(message.metadata, options);
                return object;
            };

            /**
             * Converts this KeyValue to JSON.
             * @function toJSON
             * @memberof immudb.schema.KeyValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KeyValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for KeyValue
             * @function getTypeUrl
             * @memberof immudb.schema.KeyValue
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            KeyValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.KeyValue";
            };

            return KeyValue;
        })();

        schema.Entry = (function() {

            /**
             * Properties of an Entry.
             * @memberof immudb.schema
             * @interface IEntry
             * @property {Long|null} [tx] Entry tx
             * @property {Uint8Array|null} [key] Entry key
             * @property {Uint8Array|null} [value] Entry value
             * @property {immudb.schema.IReference|null} [referencedBy] Entry referencedBy
             * @property {immudb.schema.IKVMetadata|null} [metadata] Entry metadata
             * @property {boolean|null} [expired] Entry expired
             * @property {Long|null} [revision] Entry revision
             */

            /**
             * Constructs a new Entry.
             * @memberof immudb.schema
             * @classdesc Represents an Entry.
             * @implements IEntry
             * @constructor
             * @param {immudb.schema.IEntry=} [properties] Properties to set
             */
            function Entry(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Entry tx.
             * @member {Long} tx
             * @memberof immudb.schema.Entry
             * @instance
             */
            Entry.prototype.tx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Entry key.
             * @member {Uint8Array} key
             * @memberof immudb.schema.Entry
             * @instance
             */
            Entry.prototype.key = $util.newBuffer([]);

            /**
             * Entry value.
             * @member {Uint8Array} value
             * @memberof immudb.schema.Entry
             * @instance
             */
            Entry.prototype.value = $util.newBuffer([]);

            /**
             * Entry referencedBy.
             * @member {immudb.schema.IReference|null|undefined} referencedBy
             * @memberof immudb.schema.Entry
             * @instance
             */
            Entry.prototype.referencedBy = null;

            /**
             * Entry metadata.
             * @member {immudb.schema.IKVMetadata|null|undefined} metadata
             * @memberof immudb.schema.Entry
             * @instance
             */
            Entry.prototype.metadata = null;

            /**
             * Entry expired.
             * @member {boolean} expired
             * @memberof immudb.schema.Entry
             * @instance
             */
            Entry.prototype.expired = false;

            /**
             * Entry revision.
             * @member {Long} revision
             * @memberof immudb.schema.Entry
             * @instance
             */
            Entry.prototype.revision = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new Entry instance using the specified properties.
             * @function create
             * @memberof immudb.schema.Entry
             * @static
             * @param {immudb.schema.IEntry=} [properties] Properties to set
             * @returns {immudb.schema.Entry} Entry instance
             */
            Entry.create = function create(properties) {
                return new Entry(properties);
            };

            /**
             * Encodes the specified Entry message. Does not implicitly {@link immudb.schema.Entry.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.Entry
             * @static
             * @param {immudb.schema.IEntry} message Entry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Entry.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tx != null && Object.hasOwnProperty.call(message, "tx"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.tx);
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.key);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.value);
                if (message.referencedBy != null && Object.hasOwnProperty.call(message, "referencedBy"))
                    $root.immudb.schema.Reference.encode(message.referencedBy, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    $root.immudb.schema.KVMetadata.encode(message.metadata, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.expired != null && Object.hasOwnProperty.call(message, "expired"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.expired);
                if (message.revision != null && Object.hasOwnProperty.call(message, "revision"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.revision);
                return writer;
            };

            /**
             * Encodes the specified Entry message, length delimited. Does not implicitly {@link immudb.schema.Entry.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.Entry
             * @static
             * @param {immudb.schema.IEntry} message Entry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Entry.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Entry message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.Entry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.Entry} Entry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Entry.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.Entry();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.tx = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.key = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.value = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.referencedBy = $root.immudb.schema.Reference.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.metadata = $root.immudb.schema.KVMetadata.decode(reader, reader.uint32());
                            break;
                        }
                    case 6: {
                            message.expired = reader.bool();
                            break;
                        }
                    case 7: {
                            message.revision = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Entry message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.Entry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.Entry} Entry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Entry.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Entry message.
             * @function verify
             * @memberof immudb.schema.Entry
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Entry.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tx != null && message.hasOwnProperty("tx"))
                    if (!$util.isInteger(message.tx) && !(message.tx && $util.isInteger(message.tx.low) && $util.isInteger(message.tx.high)))
                        return "tx: integer|Long expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                        return "key: buffer expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.referencedBy != null && message.hasOwnProperty("referencedBy")) {
                    let error = $root.immudb.schema.Reference.verify(message.referencedBy);
                    if (error)
                        return "referencedBy." + error;
                }
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    let error = $root.immudb.schema.KVMetadata.verify(message.metadata);
                    if (error)
                        return "metadata." + error;
                }
                if (message.expired != null && message.hasOwnProperty("expired"))
                    if (typeof message.expired !== "boolean")
                        return "expired: boolean expected";
                if (message.revision != null && message.hasOwnProperty("revision"))
                    if (!$util.isInteger(message.revision) && !(message.revision && $util.isInteger(message.revision.low) && $util.isInteger(message.revision.high)))
                        return "revision: integer|Long expected";
                return null;
            };

            /**
             * Creates an Entry message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.Entry
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.Entry} Entry
             */
            Entry.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.Entry)
                    return object;
                let message = new $root.immudb.schema.Entry();
                if (object.tx != null)
                    if ($util.Long)
                        (message.tx = $util.Long.fromValue(object.tx)).unsigned = true;
                    else if (typeof object.tx === "string")
                        message.tx = parseInt(object.tx, 10);
                    else if (typeof object.tx === "number")
                        message.tx = object.tx;
                    else if (typeof object.tx === "object")
                        message.tx = new $util.LongBits(object.tx.low >>> 0, object.tx.high >>> 0).toNumber(true);
                if (object.key != null)
                    if (typeof object.key === "string")
                        $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                    else if (object.key.length >= 0)
                        message.key = object.key;
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length >= 0)
                        message.value = object.value;
                if (object.referencedBy != null) {
                    if (typeof object.referencedBy !== "object")
                        throw TypeError(".immudb.schema.Entry.referencedBy: object expected");
                    message.referencedBy = $root.immudb.schema.Reference.fromObject(object.referencedBy);
                }
                if (object.metadata != null) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".immudb.schema.Entry.metadata: object expected");
                    message.metadata = $root.immudb.schema.KVMetadata.fromObject(object.metadata);
                }
                if (object.expired != null)
                    message.expired = Boolean(object.expired);
                if (object.revision != null)
                    if ($util.Long)
                        (message.revision = $util.Long.fromValue(object.revision)).unsigned = true;
                    else if (typeof object.revision === "string")
                        message.revision = parseInt(object.revision, 10);
                    else if (typeof object.revision === "number")
                        message.revision = object.revision;
                    else if (typeof object.revision === "object")
                        message.revision = new $util.LongBits(object.revision.low >>> 0, object.revision.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from an Entry message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.Entry
             * @static
             * @param {immudb.schema.Entry} message Entry
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Entry.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.tx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.tx = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.key = "";
                    else {
                        object.key = [];
                        if (options.bytes !== Array)
                            object.key = $util.newBuffer(object.key);
                    }
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    object.referencedBy = null;
                    object.metadata = null;
                    object.expired = false;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.revision = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.revision = options.longs === String ? "0" : 0;
                }
                if (message.tx != null && message.hasOwnProperty("tx"))
                    if (typeof message.tx === "number")
                        object.tx = options.longs === String ? String(message.tx) : message.tx;
                    else
                        object.tx = options.longs === String ? $util.Long.prototype.toString.call(message.tx) : options.longs === Number ? new $util.LongBits(message.tx.low >>> 0, message.tx.high >>> 0).toNumber(true) : message.tx;
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.referencedBy != null && message.hasOwnProperty("referencedBy"))
                    object.referencedBy = $root.immudb.schema.Reference.toObject(message.referencedBy, options);
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = $root.immudb.schema.KVMetadata.toObject(message.metadata, options);
                if (message.expired != null && message.hasOwnProperty("expired"))
                    object.expired = message.expired;
                if (message.revision != null && message.hasOwnProperty("revision"))
                    if (typeof message.revision === "number")
                        object.revision = options.longs === String ? String(message.revision) : message.revision;
                    else
                        object.revision = options.longs === String ? $util.Long.prototype.toString.call(message.revision) : options.longs === Number ? new $util.LongBits(message.revision.low >>> 0, message.revision.high >>> 0).toNumber(true) : message.revision;
                return object;
            };

            /**
             * Converts this Entry to JSON.
             * @function toJSON
             * @memberof immudb.schema.Entry
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Entry.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Entry
             * @function getTypeUrl
             * @memberof immudb.schema.Entry
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Entry.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.Entry";
            };

            return Entry;
        })();

        schema.Reference = (function() {

            /**
             * Properties of a Reference.
             * @memberof immudb.schema
             * @interface IReference
             * @property {Long|null} [tx] Reference tx
             * @property {Uint8Array|null} [key] Reference key
             * @property {Long|null} [atTx] Reference atTx
             * @property {immudb.schema.IKVMetadata|null} [metadata] Reference metadata
             * @property {Long|null} [revision] Reference revision
             */

            /**
             * Constructs a new Reference.
             * @memberof immudb.schema
             * @classdesc Represents a Reference.
             * @implements IReference
             * @constructor
             * @param {immudb.schema.IReference=} [properties] Properties to set
             */
            function Reference(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Reference tx.
             * @member {Long} tx
             * @memberof immudb.schema.Reference
             * @instance
             */
            Reference.prototype.tx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Reference key.
             * @member {Uint8Array} key
             * @memberof immudb.schema.Reference
             * @instance
             */
            Reference.prototype.key = $util.newBuffer([]);

            /**
             * Reference atTx.
             * @member {Long} atTx
             * @memberof immudb.schema.Reference
             * @instance
             */
            Reference.prototype.atTx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Reference metadata.
             * @member {immudb.schema.IKVMetadata|null|undefined} metadata
             * @memberof immudb.schema.Reference
             * @instance
             */
            Reference.prototype.metadata = null;

            /**
             * Reference revision.
             * @member {Long} revision
             * @memberof immudb.schema.Reference
             * @instance
             */
            Reference.prototype.revision = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new Reference instance using the specified properties.
             * @function create
             * @memberof immudb.schema.Reference
             * @static
             * @param {immudb.schema.IReference=} [properties] Properties to set
             * @returns {immudb.schema.Reference} Reference instance
             */
            Reference.create = function create(properties) {
                return new Reference(properties);
            };

            /**
             * Encodes the specified Reference message. Does not implicitly {@link immudb.schema.Reference.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.Reference
             * @static
             * @param {immudb.schema.IReference} message Reference message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Reference.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tx != null && Object.hasOwnProperty.call(message, "tx"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.tx);
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.key);
                if (message.atTx != null && Object.hasOwnProperty.call(message, "atTx"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.atTx);
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    $root.immudb.schema.KVMetadata.encode(message.metadata, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.revision != null && Object.hasOwnProperty.call(message, "revision"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.revision);
                return writer;
            };

            /**
             * Encodes the specified Reference message, length delimited. Does not implicitly {@link immudb.schema.Reference.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.Reference
             * @static
             * @param {immudb.schema.IReference} message Reference message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Reference.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Reference message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.Reference
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.Reference} Reference
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Reference.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.Reference();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.tx = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.key = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.atTx = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.metadata = $root.immudb.schema.KVMetadata.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.revision = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Reference message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.Reference
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.Reference} Reference
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Reference.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Reference message.
             * @function verify
             * @memberof immudb.schema.Reference
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Reference.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tx != null && message.hasOwnProperty("tx"))
                    if (!$util.isInteger(message.tx) && !(message.tx && $util.isInteger(message.tx.low) && $util.isInteger(message.tx.high)))
                        return "tx: integer|Long expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                        return "key: buffer expected";
                if (message.atTx != null && message.hasOwnProperty("atTx"))
                    if (!$util.isInteger(message.atTx) && !(message.atTx && $util.isInteger(message.atTx.low) && $util.isInteger(message.atTx.high)))
                        return "atTx: integer|Long expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    let error = $root.immudb.schema.KVMetadata.verify(message.metadata);
                    if (error)
                        return "metadata." + error;
                }
                if (message.revision != null && message.hasOwnProperty("revision"))
                    if (!$util.isInteger(message.revision) && !(message.revision && $util.isInteger(message.revision.low) && $util.isInteger(message.revision.high)))
                        return "revision: integer|Long expected";
                return null;
            };

            /**
             * Creates a Reference message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.Reference
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.Reference} Reference
             */
            Reference.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.Reference)
                    return object;
                let message = new $root.immudb.schema.Reference();
                if (object.tx != null)
                    if ($util.Long)
                        (message.tx = $util.Long.fromValue(object.tx)).unsigned = true;
                    else if (typeof object.tx === "string")
                        message.tx = parseInt(object.tx, 10);
                    else if (typeof object.tx === "number")
                        message.tx = object.tx;
                    else if (typeof object.tx === "object")
                        message.tx = new $util.LongBits(object.tx.low >>> 0, object.tx.high >>> 0).toNumber(true);
                if (object.key != null)
                    if (typeof object.key === "string")
                        $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                    else if (object.key.length >= 0)
                        message.key = object.key;
                if (object.atTx != null)
                    if ($util.Long)
                        (message.atTx = $util.Long.fromValue(object.atTx)).unsigned = true;
                    else if (typeof object.atTx === "string")
                        message.atTx = parseInt(object.atTx, 10);
                    else if (typeof object.atTx === "number")
                        message.atTx = object.atTx;
                    else if (typeof object.atTx === "object")
                        message.atTx = new $util.LongBits(object.atTx.low >>> 0, object.atTx.high >>> 0).toNumber(true);
                if (object.metadata != null) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".immudb.schema.Reference.metadata: object expected");
                    message.metadata = $root.immudb.schema.KVMetadata.fromObject(object.metadata);
                }
                if (object.revision != null)
                    if ($util.Long)
                        (message.revision = $util.Long.fromValue(object.revision)).unsigned = true;
                    else if (typeof object.revision === "string")
                        message.revision = parseInt(object.revision, 10);
                    else if (typeof object.revision === "number")
                        message.revision = object.revision;
                    else if (typeof object.revision === "object")
                        message.revision = new $util.LongBits(object.revision.low >>> 0, object.revision.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a Reference message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.Reference
             * @static
             * @param {immudb.schema.Reference} message Reference
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Reference.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.tx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.tx = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.key = "";
                    else {
                        object.key = [];
                        if (options.bytes !== Array)
                            object.key = $util.newBuffer(object.key);
                    }
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.atTx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.atTx = options.longs === String ? "0" : 0;
                    object.metadata = null;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.revision = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.revision = options.longs === String ? "0" : 0;
                }
                if (message.tx != null && message.hasOwnProperty("tx"))
                    if (typeof message.tx === "number")
                        object.tx = options.longs === String ? String(message.tx) : message.tx;
                    else
                        object.tx = options.longs === String ? $util.Long.prototype.toString.call(message.tx) : options.longs === Number ? new $util.LongBits(message.tx.low >>> 0, message.tx.high >>> 0).toNumber(true) : message.tx;
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                if (message.atTx != null && message.hasOwnProperty("atTx"))
                    if (typeof message.atTx === "number")
                        object.atTx = options.longs === String ? String(message.atTx) : message.atTx;
                    else
                        object.atTx = options.longs === String ? $util.Long.prototype.toString.call(message.atTx) : options.longs === Number ? new $util.LongBits(message.atTx.low >>> 0, message.atTx.high >>> 0).toNumber(true) : message.atTx;
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = $root.immudb.schema.KVMetadata.toObject(message.metadata, options);
                if (message.revision != null && message.hasOwnProperty("revision"))
                    if (typeof message.revision === "number")
                        object.revision = options.longs === String ? String(message.revision) : message.revision;
                    else
                        object.revision = options.longs === String ? $util.Long.prototype.toString.call(message.revision) : options.longs === Number ? new $util.LongBits(message.revision.low >>> 0, message.revision.high >>> 0).toNumber(true) : message.revision;
                return object;
            };

            /**
             * Converts this Reference to JSON.
             * @function toJSON
             * @memberof immudb.schema.Reference
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Reference.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Reference
             * @function getTypeUrl
             * @memberof immudb.schema.Reference
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Reference.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.Reference";
            };

            return Reference;
        })();

        schema.Op = (function() {

            /**
             * Properties of an Op.
             * @memberof immudb.schema
             * @interface IOp
             * @property {immudb.schema.IKeyValue|null} [kv] Op kv
             * @property {immudb.schema.IZAddRequest|null} [zAdd] Op zAdd
             * @property {immudb.schema.IReferenceRequest|null} [ref] Op ref
             */

            /**
             * Constructs a new Op.
             * @memberof immudb.schema
             * @classdesc Represents an Op.
             * @implements IOp
             * @constructor
             * @param {immudb.schema.IOp=} [properties] Properties to set
             */
            function Op(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Op kv.
             * @member {immudb.schema.IKeyValue|null|undefined} kv
             * @memberof immudb.schema.Op
             * @instance
             */
            Op.prototype.kv = null;

            /**
             * Op zAdd.
             * @member {immudb.schema.IZAddRequest|null|undefined} zAdd
             * @memberof immudb.schema.Op
             * @instance
             */
            Op.prototype.zAdd = null;

            /**
             * Op ref.
             * @member {immudb.schema.IReferenceRequest|null|undefined} ref
             * @memberof immudb.schema.Op
             * @instance
             */
            Op.prototype.ref = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Op operation.
             * @member {"kv"|"zAdd"|"ref"|undefined} operation
             * @memberof immudb.schema.Op
             * @instance
             */
            Object.defineProperty(Op.prototype, "operation", {
                get: $util.oneOfGetter($oneOfFields = ["kv", "zAdd", "ref"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Op instance using the specified properties.
             * @function create
             * @memberof immudb.schema.Op
             * @static
             * @param {immudb.schema.IOp=} [properties] Properties to set
             * @returns {immudb.schema.Op} Op instance
             */
            Op.create = function create(properties) {
                return new Op(properties);
            };

            /**
             * Encodes the specified Op message. Does not implicitly {@link immudb.schema.Op.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.Op
             * @static
             * @param {immudb.schema.IOp} message Op message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Op.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.kv != null && Object.hasOwnProperty.call(message, "kv"))
                    $root.immudb.schema.KeyValue.encode(message.kv, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.zAdd != null && Object.hasOwnProperty.call(message, "zAdd"))
                    $root.immudb.schema.ZAddRequest.encode(message.zAdd, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.ref != null && Object.hasOwnProperty.call(message, "ref"))
                    $root.immudb.schema.ReferenceRequest.encode(message.ref, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Op message, length delimited. Does not implicitly {@link immudb.schema.Op.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.Op
             * @static
             * @param {immudb.schema.IOp} message Op message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Op.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Op message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.Op
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.Op} Op
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Op.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.Op();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.kv = $root.immudb.schema.KeyValue.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.zAdd = $root.immudb.schema.ZAddRequest.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.ref = $root.immudb.schema.ReferenceRequest.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Op message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.Op
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.Op} Op
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Op.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Op message.
             * @function verify
             * @memberof immudb.schema.Op
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Op.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.kv != null && message.hasOwnProperty("kv")) {
                    properties.operation = 1;
                    {
                        let error = $root.immudb.schema.KeyValue.verify(message.kv);
                        if (error)
                            return "kv." + error;
                    }
                }
                if (message.zAdd != null && message.hasOwnProperty("zAdd")) {
                    if (properties.operation === 1)
                        return "operation: multiple values";
                    properties.operation = 1;
                    {
                        let error = $root.immudb.schema.ZAddRequest.verify(message.zAdd);
                        if (error)
                            return "zAdd." + error;
                    }
                }
                if (message.ref != null && message.hasOwnProperty("ref")) {
                    if (properties.operation === 1)
                        return "operation: multiple values";
                    properties.operation = 1;
                    {
                        let error = $root.immudb.schema.ReferenceRequest.verify(message.ref);
                        if (error)
                            return "ref." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an Op message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.Op
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.Op} Op
             */
            Op.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.Op)
                    return object;
                let message = new $root.immudb.schema.Op();
                if (object.kv != null) {
                    if (typeof object.kv !== "object")
                        throw TypeError(".immudb.schema.Op.kv: object expected");
                    message.kv = $root.immudb.schema.KeyValue.fromObject(object.kv);
                }
                if (object.zAdd != null) {
                    if (typeof object.zAdd !== "object")
                        throw TypeError(".immudb.schema.Op.zAdd: object expected");
                    message.zAdd = $root.immudb.schema.ZAddRequest.fromObject(object.zAdd);
                }
                if (object.ref != null) {
                    if (typeof object.ref !== "object")
                        throw TypeError(".immudb.schema.Op.ref: object expected");
                    message.ref = $root.immudb.schema.ReferenceRequest.fromObject(object.ref);
                }
                return message;
            };

            /**
             * Creates a plain object from an Op message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.Op
             * @static
             * @param {immudb.schema.Op} message Op
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Op.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.kv != null && message.hasOwnProperty("kv")) {
                    object.kv = $root.immudb.schema.KeyValue.toObject(message.kv, options);
                    if (options.oneofs)
                        object.operation = "kv";
                }
                if (message.zAdd != null && message.hasOwnProperty("zAdd")) {
                    object.zAdd = $root.immudb.schema.ZAddRequest.toObject(message.zAdd, options);
                    if (options.oneofs)
                        object.operation = "zAdd";
                }
                if (message.ref != null && message.hasOwnProperty("ref")) {
                    object.ref = $root.immudb.schema.ReferenceRequest.toObject(message.ref, options);
                    if (options.oneofs)
                        object.operation = "ref";
                }
                return object;
            };

            /**
             * Converts this Op to JSON.
             * @function toJSON
             * @memberof immudb.schema.Op
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Op.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Op
             * @function getTypeUrl
             * @memberof immudb.schema.Op
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Op.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.Op";
            };

            return Op;
        })();

        schema.ExecAllRequest = (function() {

            /**
             * Properties of an ExecAllRequest.
             * @memberof immudb.schema
             * @interface IExecAllRequest
             * @property {Array.<immudb.schema.IOp>|null} [Operations] ExecAllRequest Operations
             * @property {boolean|null} [noWait] ExecAllRequest noWait
             * @property {Array.<immudb.schema.IPrecondition>|null} [preconditions] ExecAllRequest preconditions
             */

            /**
             * Constructs a new ExecAllRequest.
             * @memberof immudb.schema
             * @classdesc Represents an ExecAllRequest.
             * @implements IExecAllRequest
             * @constructor
             * @param {immudb.schema.IExecAllRequest=} [properties] Properties to set
             */
            function ExecAllRequest(properties) {
                this.Operations = [];
                this.preconditions = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecAllRequest Operations.
             * @member {Array.<immudb.schema.IOp>} Operations
             * @memberof immudb.schema.ExecAllRequest
             * @instance
             */
            ExecAllRequest.prototype.Operations = $util.emptyArray;

            /**
             * ExecAllRequest noWait.
             * @member {boolean} noWait
             * @memberof immudb.schema.ExecAllRequest
             * @instance
             */
            ExecAllRequest.prototype.noWait = false;

            /**
             * ExecAllRequest preconditions.
             * @member {Array.<immudb.schema.IPrecondition>} preconditions
             * @memberof immudb.schema.ExecAllRequest
             * @instance
             */
            ExecAllRequest.prototype.preconditions = $util.emptyArray;

            /**
             * Creates a new ExecAllRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.ExecAllRequest
             * @static
             * @param {immudb.schema.IExecAllRequest=} [properties] Properties to set
             * @returns {immudb.schema.ExecAllRequest} ExecAllRequest instance
             */
            ExecAllRequest.create = function create(properties) {
                return new ExecAllRequest(properties);
            };

            /**
             * Encodes the specified ExecAllRequest message. Does not implicitly {@link immudb.schema.ExecAllRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.ExecAllRequest
             * @static
             * @param {immudb.schema.IExecAllRequest} message ExecAllRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecAllRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.Operations != null && message.Operations.length)
                    for (let i = 0; i < message.Operations.length; ++i)
                        $root.immudb.schema.Op.encode(message.Operations[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.noWait != null && Object.hasOwnProperty.call(message, "noWait"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.noWait);
                if (message.preconditions != null && message.preconditions.length)
                    for (let i = 0; i < message.preconditions.length; ++i)
                        $root.immudb.schema.Precondition.encode(message.preconditions[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExecAllRequest message, length delimited. Does not implicitly {@link immudb.schema.ExecAllRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.ExecAllRequest
             * @static
             * @param {immudb.schema.IExecAllRequest} message ExecAllRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecAllRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecAllRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.ExecAllRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.ExecAllRequest} ExecAllRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecAllRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.ExecAllRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.Operations && message.Operations.length))
                                message.Operations = [];
                            message.Operations.push($root.immudb.schema.Op.decode(reader, reader.uint32()));
                            break;
                        }
                    case 2: {
                            message.noWait = reader.bool();
                            break;
                        }
                    case 3: {
                            if (!(message.preconditions && message.preconditions.length))
                                message.preconditions = [];
                            message.preconditions.push($root.immudb.schema.Precondition.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecAllRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.ExecAllRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.ExecAllRequest} ExecAllRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecAllRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecAllRequest message.
             * @function verify
             * @memberof immudb.schema.ExecAllRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecAllRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.Operations != null && message.hasOwnProperty("Operations")) {
                    if (!Array.isArray(message.Operations))
                        return "Operations: array expected";
                    for (let i = 0; i < message.Operations.length; ++i) {
                        let error = $root.immudb.schema.Op.verify(message.Operations[i]);
                        if (error)
                            return "Operations." + error;
                    }
                }
                if (message.noWait != null && message.hasOwnProperty("noWait"))
                    if (typeof message.noWait !== "boolean")
                        return "noWait: boolean expected";
                if (message.preconditions != null && message.hasOwnProperty("preconditions")) {
                    if (!Array.isArray(message.preconditions))
                        return "preconditions: array expected";
                    for (let i = 0; i < message.preconditions.length; ++i) {
                        let error = $root.immudb.schema.Precondition.verify(message.preconditions[i]);
                        if (error)
                            return "preconditions." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an ExecAllRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.ExecAllRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.ExecAllRequest} ExecAllRequest
             */
            ExecAllRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.ExecAllRequest)
                    return object;
                let message = new $root.immudb.schema.ExecAllRequest();
                if (object.Operations) {
                    if (!Array.isArray(object.Operations))
                        throw TypeError(".immudb.schema.ExecAllRequest.Operations: array expected");
                    message.Operations = [];
                    for (let i = 0; i < object.Operations.length; ++i) {
                        if (typeof object.Operations[i] !== "object")
                            throw TypeError(".immudb.schema.ExecAllRequest.Operations: object expected");
                        message.Operations[i] = $root.immudb.schema.Op.fromObject(object.Operations[i]);
                    }
                }
                if (object.noWait != null)
                    message.noWait = Boolean(object.noWait);
                if (object.preconditions) {
                    if (!Array.isArray(object.preconditions))
                        throw TypeError(".immudb.schema.ExecAllRequest.preconditions: array expected");
                    message.preconditions = [];
                    for (let i = 0; i < object.preconditions.length; ++i) {
                        if (typeof object.preconditions[i] !== "object")
                            throw TypeError(".immudb.schema.ExecAllRequest.preconditions: object expected");
                        message.preconditions[i] = $root.immudb.schema.Precondition.fromObject(object.preconditions[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an ExecAllRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.ExecAllRequest
             * @static
             * @param {immudb.schema.ExecAllRequest} message ExecAllRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecAllRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.Operations = [];
                    object.preconditions = [];
                }
                if (options.defaults)
                    object.noWait = false;
                if (message.Operations && message.Operations.length) {
                    object.Operations = [];
                    for (let j = 0; j < message.Operations.length; ++j)
                        object.Operations[j] = $root.immudb.schema.Op.toObject(message.Operations[j], options);
                }
                if (message.noWait != null && message.hasOwnProperty("noWait"))
                    object.noWait = message.noWait;
                if (message.preconditions && message.preconditions.length) {
                    object.preconditions = [];
                    for (let j = 0; j < message.preconditions.length; ++j)
                        object.preconditions[j] = $root.immudb.schema.Precondition.toObject(message.preconditions[j], options);
                }
                return object;
            };

            /**
             * Converts this ExecAllRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.ExecAllRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecAllRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ExecAllRequest
             * @function getTypeUrl
             * @memberof immudb.schema.ExecAllRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ExecAllRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.ExecAllRequest";
            };

            return ExecAllRequest;
        })();

        schema.Entries = (function() {

            /**
             * Properties of an Entries.
             * @memberof immudb.schema
             * @interface IEntries
             * @property {Array.<immudb.schema.IEntry>|null} [entries] Entries entries
             */

            /**
             * Constructs a new Entries.
             * @memberof immudb.schema
             * @classdesc Represents an Entries.
             * @implements IEntries
             * @constructor
             * @param {immudb.schema.IEntries=} [properties] Properties to set
             */
            function Entries(properties) {
                this.entries = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Entries entries.
             * @member {Array.<immudb.schema.IEntry>} entries
             * @memberof immudb.schema.Entries
             * @instance
             */
            Entries.prototype.entries = $util.emptyArray;

            /**
             * Creates a new Entries instance using the specified properties.
             * @function create
             * @memberof immudb.schema.Entries
             * @static
             * @param {immudb.schema.IEntries=} [properties] Properties to set
             * @returns {immudb.schema.Entries} Entries instance
             */
            Entries.create = function create(properties) {
                return new Entries(properties);
            };

            /**
             * Encodes the specified Entries message. Does not implicitly {@link immudb.schema.Entries.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.Entries
             * @static
             * @param {immudb.schema.IEntries} message Entries message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Entries.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.entries != null && message.entries.length)
                    for (let i = 0; i < message.entries.length; ++i)
                        $root.immudb.schema.Entry.encode(message.entries[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Entries message, length delimited. Does not implicitly {@link immudb.schema.Entries.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.Entries
             * @static
             * @param {immudb.schema.IEntries} message Entries message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Entries.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Entries message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.Entries
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.Entries} Entries
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Entries.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.Entries();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.entries && message.entries.length))
                                message.entries = [];
                            message.entries.push($root.immudb.schema.Entry.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Entries message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.Entries
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.Entries} Entries
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Entries.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Entries message.
             * @function verify
             * @memberof immudb.schema.Entries
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Entries.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.entries != null && message.hasOwnProperty("entries")) {
                    if (!Array.isArray(message.entries))
                        return "entries: array expected";
                    for (let i = 0; i < message.entries.length; ++i) {
                        let error = $root.immudb.schema.Entry.verify(message.entries[i]);
                        if (error)
                            return "entries." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an Entries message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.Entries
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.Entries} Entries
             */
            Entries.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.Entries)
                    return object;
                let message = new $root.immudb.schema.Entries();
                if (object.entries) {
                    if (!Array.isArray(object.entries))
                        throw TypeError(".immudb.schema.Entries.entries: array expected");
                    message.entries = [];
                    for (let i = 0; i < object.entries.length; ++i) {
                        if (typeof object.entries[i] !== "object")
                            throw TypeError(".immudb.schema.Entries.entries: object expected");
                        message.entries[i] = $root.immudb.schema.Entry.fromObject(object.entries[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an Entries message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.Entries
             * @static
             * @param {immudb.schema.Entries} message Entries
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Entries.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.entries = [];
                if (message.entries && message.entries.length) {
                    object.entries = [];
                    for (let j = 0; j < message.entries.length; ++j)
                        object.entries[j] = $root.immudb.schema.Entry.toObject(message.entries[j], options);
                }
                return object;
            };

            /**
             * Converts this Entries to JSON.
             * @function toJSON
             * @memberof immudb.schema.Entries
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Entries.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Entries
             * @function getTypeUrl
             * @memberof immudb.schema.Entries
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Entries.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.Entries";
            };

            return Entries;
        })();

        schema.ZEntry = (function() {

            /**
             * Properties of a ZEntry.
             * @memberof immudb.schema
             * @interface IZEntry
             * @property {Uint8Array|null} [set] ZEntry set
             * @property {Uint8Array|null} [key] ZEntry key
             * @property {immudb.schema.IEntry|null} [entry] ZEntry entry
             * @property {number|null} [score] ZEntry score
             * @property {Long|null} [atTx] ZEntry atTx
             */

            /**
             * Constructs a new ZEntry.
             * @memberof immudb.schema
             * @classdesc Represents a ZEntry.
             * @implements IZEntry
             * @constructor
             * @param {immudb.schema.IZEntry=} [properties] Properties to set
             */
            function ZEntry(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ZEntry set.
             * @member {Uint8Array} set
             * @memberof immudb.schema.ZEntry
             * @instance
             */
            ZEntry.prototype.set = $util.newBuffer([]);

            /**
             * ZEntry key.
             * @member {Uint8Array} key
             * @memberof immudb.schema.ZEntry
             * @instance
             */
            ZEntry.prototype.key = $util.newBuffer([]);

            /**
             * ZEntry entry.
             * @member {immudb.schema.IEntry|null|undefined} entry
             * @memberof immudb.schema.ZEntry
             * @instance
             */
            ZEntry.prototype.entry = null;

            /**
             * ZEntry score.
             * @member {number} score
             * @memberof immudb.schema.ZEntry
             * @instance
             */
            ZEntry.prototype.score = 0;

            /**
             * ZEntry atTx.
             * @member {Long} atTx
             * @memberof immudb.schema.ZEntry
             * @instance
             */
            ZEntry.prototype.atTx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new ZEntry instance using the specified properties.
             * @function create
             * @memberof immudb.schema.ZEntry
             * @static
             * @param {immudb.schema.IZEntry=} [properties] Properties to set
             * @returns {immudb.schema.ZEntry} ZEntry instance
             */
            ZEntry.create = function create(properties) {
                return new ZEntry(properties);
            };

            /**
             * Encodes the specified ZEntry message. Does not implicitly {@link immudb.schema.ZEntry.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.ZEntry
             * @static
             * @param {immudb.schema.IZEntry} message ZEntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ZEntry.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.set != null && Object.hasOwnProperty.call(message, "set"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.set);
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.key);
                if (message.entry != null && Object.hasOwnProperty.call(message, "entry"))
                    $root.immudb.schema.Entry.encode(message.entry, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                    writer.uint32(/* id 4, wireType 1 =*/33).double(message.score);
                if (message.atTx != null && Object.hasOwnProperty.call(message, "atTx"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.atTx);
                return writer;
            };

            /**
             * Encodes the specified ZEntry message, length delimited. Does not implicitly {@link immudb.schema.ZEntry.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.ZEntry
             * @static
             * @param {immudb.schema.IZEntry} message ZEntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ZEntry.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ZEntry message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.ZEntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.ZEntry} ZEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ZEntry.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.ZEntry();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.set = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.key = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.entry = $root.immudb.schema.Entry.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.score = reader.double();
                            break;
                        }
                    case 5: {
                            message.atTx = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ZEntry message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.ZEntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.ZEntry} ZEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ZEntry.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ZEntry message.
             * @function verify
             * @memberof immudb.schema.ZEntry
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ZEntry.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.set != null && message.hasOwnProperty("set"))
                    if (!(message.set && typeof message.set.length === "number" || $util.isString(message.set)))
                        return "set: buffer expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                        return "key: buffer expected";
                if (message.entry != null && message.hasOwnProperty("entry")) {
                    let error = $root.immudb.schema.Entry.verify(message.entry);
                    if (error)
                        return "entry." + error;
                }
                if (message.score != null && message.hasOwnProperty("score"))
                    if (typeof message.score !== "number")
                        return "score: number expected";
                if (message.atTx != null && message.hasOwnProperty("atTx"))
                    if (!$util.isInteger(message.atTx) && !(message.atTx && $util.isInteger(message.atTx.low) && $util.isInteger(message.atTx.high)))
                        return "atTx: integer|Long expected";
                return null;
            };

            /**
             * Creates a ZEntry message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.ZEntry
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.ZEntry} ZEntry
             */
            ZEntry.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.ZEntry)
                    return object;
                let message = new $root.immudb.schema.ZEntry();
                if (object.set != null)
                    if (typeof object.set === "string")
                        $util.base64.decode(object.set, message.set = $util.newBuffer($util.base64.length(object.set)), 0);
                    else if (object.set.length >= 0)
                        message.set = object.set;
                if (object.key != null)
                    if (typeof object.key === "string")
                        $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                    else if (object.key.length >= 0)
                        message.key = object.key;
                if (object.entry != null) {
                    if (typeof object.entry !== "object")
                        throw TypeError(".immudb.schema.ZEntry.entry: object expected");
                    message.entry = $root.immudb.schema.Entry.fromObject(object.entry);
                }
                if (object.score != null)
                    message.score = Number(object.score);
                if (object.atTx != null)
                    if ($util.Long)
                        (message.atTx = $util.Long.fromValue(object.atTx)).unsigned = true;
                    else if (typeof object.atTx === "string")
                        message.atTx = parseInt(object.atTx, 10);
                    else if (typeof object.atTx === "number")
                        message.atTx = object.atTx;
                    else if (typeof object.atTx === "object")
                        message.atTx = new $util.LongBits(object.atTx.low >>> 0, object.atTx.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a ZEntry message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.ZEntry
             * @static
             * @param {immudb.schema.ZEntry} message ZEntry
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ZEntry.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.set = "";
                    else {
                        object.set = [];
                        if (options.bytes !== Array)
                            object.set = $util.newBuffer(object.set);
                    }
                    if (options.bytes === String)
                        object.key = "";
                    else {
                        object.key = [];
                        if (options.bytes !== Array)
                            object.key = $util.newBuffer(object.key);
                    }
                    object.entry = null;
                    object.score = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.atTx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.atTx = options.longs === String ? "0" : 0;
                }
                if (message.set != null && message.hasOwnProperty("set"))
                    object.set = options.bytes === String ? $util.base64.encode(message.set, 0, message.set.length) : options.bytes === Array ? Array.prototype.slice.call(message.set) : message.set;
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                if (message.entry != null && message.hasOwnProperty("entry"))
                    object.entry = $root.immudb.schema.Entry.toObject(message.entry, options);
                if (message.score != null && message.hasOwnProperty("score"))
                    object.score = options.json && !isFinite(message.score) ? String(message.score) : message.score;
                if (message.atTx != null && message.hasOwnProperty("atTx"))
                    if (typeof message.atTx === "number")
                        object.atTx = options.longs === String ? String(message.atTx) : message.atTx;
                    else
                        object.atTx = options.longs === String ? $util.Long.prototype.toString.call(message.atTx) : options.longs === Number ? new $util.LongBits(message.atTx.low >>> 0, message.atTx.high >>> 0).toNumber(true) : message.atTx;
                return object;
            };

            /**
             * Converts this ZEntry to JSON.
             * @function toJSON
             * @memberof immudb.schema.ZEntry
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ZEntry.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ZEntry
             * @function getTypeUrl
             * @memberof immudb.schema.ZEntry
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ZEntry.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.ZEntry";
            };

            return ZEntry;
        })();

        schema.ZEntries = (function() {

            /**
             * Properties of a ZEntries.
             * @memberof immudb.schema
             * @interface IZEntries
             * @property {Array.<immudb.schema.IZEntry>|null} [entries] ZEntries entries
             */

            /**
             * Constructs a new ZEntries.
             * @memberof immudb.schema
             * @classdesc Represents a ZEntries.
             * @implements IZEntries
             * @constructor
             * @param {immudb.schema.IZEntries=} [properties] Properties to set
             */
            function ZEntries(properties) {
                this.entries = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ZEntries entries.
             * @member {Array.<immudb.schema.IZEntry>} entries
             * @memberof immudb.schema.ZEntries
             * @instance
             */
            ZEntries.prototype.entries = $util.emptyArray;

            /**
             * Creates a new ZEntries instance using the specified properties.
             * @function create
             * @memberof immudb.schema.ZEntries
             * @static
             * @param {immudb.schema.IZEntries=} [properties] Properties to set
             * @returns {immudb.schema.ZEntries} ZEntries instance
             */
            ZEntries.create = function create(properties) {
                return new ZEntries(properties);
            };

            /**
             * Encodes the specified ZEntries message. Does not implicitly {@link immudb.schema.ZEntries.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.ZEntries
             * @static
             * @param {immudb.schema.IZEntries} message ZEntries message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ZEntries.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.entries != null && message.entries.length)
                    for (let i = 0; i < message.entries.length; ++i)
                        $root.immudb.schema.ZEntry.encode(message.entries[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ZEntries message, length delimited. Does not implicitly {@link immudb.schema.ZEntries.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.ZEntries
             * @static
             * @param {immudb.schema.IZEntries} message ZEntries message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ZEntries.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ZEntries message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.ZEntries
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.ZEntries} ZEntries
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ZEntries.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.ZEntries();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.entries && message.entries.length))
                                message.entries = [];
                            message.entries.push($root.immudb.schema.ZEntry.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ZEntries message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.ZEntries
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.ZEntries} ZEntries
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ZEntries.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ZEntries message.
             * @function verify
             * @memberof immudb.schema.ZEntries
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ZEntries.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.entries != null && message.hasOwnProperty("entries")) {
                    if (!Array.isArray(message.entries))
                        return "entries: array expected";
                    for (let i = 0; i < message.entries.length; ++i) {
                        let error = $root.immudb.schema.ZEntry.verify(message.entries[i]);
                        if (error)
                            return "entries." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ZEntries message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.ZEntries
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.ZEntries} ZEntries
             */
            ZEntries.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.ZEntries)
                    return object;
                let message = new $root.immudb.schema.ZEntries();
                if (object.entries) {
                    if (!Array.isArray(object.entries))
                        throw TypeError(".immudb.schema.ZEntries.entries: array expected");
                    message.entries = [];
                    for (let i = 0; i < object.entries.length; ++i) {
                        if (typeof object.entries[i] !== "object")
                            throw TypeError(".immudb.schema.ZEntries.entries: object expected");
                        message.entries[i] = $root.immudb.schema.ZEntry.fromObject(object.entries[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ZEntries message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.ZEntries
             * @static
             * @param {immudb.schema.ZEntries} message ZEntries
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ZEntries.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.entries = [];
                if (message.entries && message.entries.length) {
                    object.entries = [];
                    for (let j = 0; j < message.entries.length; ++j)
                        object.entries[j] = $root.immudb.schema.ZEntry.toObject(message.entries[j], options);
                }
                return object;
            };

            /**
             * Converts this ZEntries to JSON.
             * @function toJSON
             * @memberof immudb.schema.ZEntries
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ZEntries.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ZEntries
             * @function getTypeUrl
             * @memberof immudb.schema.ZEntries
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ZEntries.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.ZEntries";
            };

            return ZEntries;
        })();

        schema.ScanRequest = (function() {

            /**
             * Properties of a ScanRequest.
             * @memberof immudb.schema
             * @interface IScanRequest
             * @property {Uint8Array|null} [seekKey] ScanRequest seekKey
             * @property {Uint8Array|null} [endKey] ScanRequest endKey
             * @property {Uint8Array|null} [prefix] ScanRequest prefix
             * @property {boolean|null} [desc] ScanRequest desc
             * @property {Long|null} [limit] ScanRequest limit
             * @property {Long|null} [sinceTx] ScanRequest sinceTx
             * @property {boolean|null} [noWait] ScanRequest noWait
             * @property {boolean|null} [inclusiveSeek] ScanRequest inclusiveSeek
             * @property {boolean|null} [inclusiveEnd] ScanRequest inclusiveEnd
             */

            /**
             * Constructs a new ScanRequest.
             * @memberof immudb.schema
             * @classdesc Represents a ScanRequest.
             * @implements IScanRequest
             * @constructor
             * @param {immudb.schema.IScanRequest=} [properties] Properties to set
             */
            function ScanRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ScanRequest seekKey.
             * @member {Uint8Array} seekKey
             * @memberof immudb.schema.ScanRequest
             * @instance
             */
            ScanRequest.prototype.seekKey = $util.newBuffer([]);

            /**
             * ScanRequest endKey.
             * @member {Uint8Array} endKey
             * @memberof immudb.schema.ScanRequest
             * @instance
             */
            ScanRequest.prototype.endKey = $util.newBuffer([]);

            /**
             * ScanRequest prefix.
             * @member {Uint8Array} prefix
             * @memberof immudb.schema.ScanRequest
             * @instance
             */
            ScanRequest.prototype.prefix = $util.newBuffer([]);

            /**
             * ScanRequest desc.
             * @member {boolean} desc
             * @memberof immudb.schema.ScanRequest
             * @instance
             */
            ScanRequest.prototype.desc = false;

            /**
             * ScanRequest limit.
             * @member {Long} limit
             * @memberof immudb.schema.ScanRequest
             * @instance
             */
            ScanRequest.prototype.limit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ScanRequest sinceTx.
             * @member {Long} sinceTx
             * @memberof immudb.schema.ScanRequest
             * @instance
             */
            ScanRequest.prototype.sinceTx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ScanRequest noWait.
             * @member {boolean} noWait
             * @memberof immudb.schema.ScanRequest
             * @instance
             */
            ScanRequest.prototype.noWait = false;

            /**
             * ScanRequest inclusiveSeek.
             * @member {boolean} inclusiveSeek
             * @memberof immudb.schema.ScanRequest
             * @instance
             */
            ScanRequest.prototype.inclusiveSeek = false;

            /**
             * ScanRequest inclusiveEnd.
             * @member {boolean} inclusiveEnd
             * @memberof immudb.schema.ScanRequest
             * @instance
             */
            ScanRequest.prototype.inclusiveEnd = false;

            /**
             * Creates a new ScanRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.ScanRequest
             * @static
             * @param {immudb.schema.IScanRequest=} [properties] Properties to set
             * @returns {immudb.schema.ScanRequest} ScanRequest instance
             */
            ScanRequest.create = function create(properties) {
                return new ScanRequest(properties);
            };

            /**
             * Encodes the specified ScanRequest message. Does not implicitly {@link immudb.schema.ScanRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.ScanRequest
             * @static
             * @param {immudb.schema.IScanRequest} message ScanRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ScanRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.seekKey != null && Object.hasOwnProperty.call(message, "seekKey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.seekKey);
                if (message.prefix != null && Object.hasOwnProperty.call(message, "prefix"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.prefix);
                if (message.desc != null && Object.hasOwnProperty.call(message, "desc"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.desc);
                if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.limit);
                if (message.sinceTx != null && Object.hasOwnProperty.call(message, "sinceTx"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.sinceTx);
                if (message.noWait != null && Object.hasOwnProperty.call(message, "noWait"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.noWait);
                if (message.endKey != null && Object.hasOwnProperty.call(message, "endKey"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.endKey);
                if (message.inclusiveSeek != null && Object.hasOwnProperty.call(message, "inclusiveSeek"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.inclusiveSeek);
                if (message.inclusiveEnd != null && Object.hasOwnProperty.call(message, "inclusiveEnd"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.inclusiveEnd);
                return writer;
            };

            /**
             * Encodes the specified ScanRequest message, length delimited. Does not implicitly {@link immudb.schema.ScanRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.ScanRequest
             * @static
             * @param {immudb.schema.IScanRequest} message ScanRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ScanRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ScanRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.ScanRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.ScanRequest} ScanRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ScanRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.ScanRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.seekKey = reader.bytes();
                            break;
                        }
                    case 7: {
                            message.endKey = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.prefix = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.desc = reader.bool();
                            break;
                        }
                    case 4: {
                            message.limit = reader.uint64();
                            break;
                        }
                    case 5: {
                            message.sinceTx = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.noWait = reader.bool();
                            break;
                        }
                    case 8: {
                            message.inclusiveSeek = reader.bool();
                            break;
                        }
                    case 9: {
                            message.inclusiveEnd = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ScanRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.ScanRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.ScanRequest} ScanRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ScanRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ScanRequest message.
             * @function verify
             * @memberof immudb.schema.ScanRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ScanRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.seekKey != null && message.hasOwnProperty("seekKey"))
                    if (!(message.seekKey && typeof message.seekKey.length === "number" || $util.isString(message.seekKey)))
                        return "seekKey: buffer expected";
                if (message.endKey != null && message.hasOwnProperty("endKey"))
                    if (!(message.endKey && typeof message.endKey.length === "number" || $util.isString(message.endKey)))
                        return "endKey: buffer expected";
                if (message.prefix != null && message.hasOwnProperty("prefix"))
                    if (!(message.prefix && typeof message.prefix.length === "number" || $util.isString(message.prefix)))
                        return "prefix: buffer expected";
                if (message.desc != null && message.hasOwnProperty("desc"))
                    if (typeof message.desc !== "boolean")
                        return "desc: boolean expected";
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (!$util.isInteger(message.limit) && !(message.limit && $util.isInteger(message.limit.low) && $util.isInteger(message.limit.high)))
                        return "limit: integer|Long expected";
                if (message.sinceTx != null && message.hasOwnProperty("sinceTx"))
                    if (!$util.isInteger(message.sinceTx) && !(message.sinceTx && $util.isInteger(message.sinceTx.low) && $util.isInteger(message.sinceTx.high)))
                        return "sinceTx: integer|Long expected";
                if (message.noWait != null && message.hasOwnProperty("noWait"))
                    if (typeof message.noWait !== "boolean")
                        return "noWait: boolean expected";
                if (message.inclusiveSeek != null && message.hasOwnProperty("inclusiveSeek"))
                    if (typeof message.inclusiveSeek !== "boolean")
                        return "inclusiveSeek: boolean expected";
                if (message.inclusiveEnd != null && message.hasOwnProperty("inclusiveEnd"))
                    if (typeof message.inclusiveEnd !== "boolean")
                        return "inclusiveEnd: boolean expected";
                return null;
            };

            /**
             * Creates a ScanRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.ScanRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.ScanRequest} ScanRequest
             */
            ScanRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.ScanRequest)
                    return object;
                let message = new $root.immudb.schema.ScanRequest();
                if (object.seekKey != null)
                    if (typeof object.seekKey === "string")
                        $util.base64.decode(object.seekKey, message.seekKey = $util.newBuffer($util.base64.length(object.seekKey)), 0);
                    else if (object.seekKey.length >= 0)
                        message.seekKey = object.seekKey;
                if (object.endKey != null)
                    if (typeof object.endKey === "string")
                        $util.base64.decode(object.endKey, message.endKey = $util.newBuffer($util.base64.length(object.endKey)), 0);
                    else if (object.endKey.length >= 0)
                        message.endKey = object.endKey;
                if (object.prefix != null)
                    if (typeof object.prefix === "string")
                        $util.base64.decode(object.prefix, message.prefix = $util.newBuffer($util.base64.length(object.prefix)), 0);
                    else if (object.prefix.length >= 0)
                        message.prefix = object.prefix;
                if (object.desc != null)
                    message.desc = Boolean(object.desc);
                if (object.limit != null)
                    if ($util.Long)
                        (message.limit = $util.Long.fromValue(object.limit)).unsigned = true;
                    else if (typeof object.limit === "string")
                        message.limit = parseInt(object.limit, 10);
                    else if (typeof object.limit === "number")
                        message.limit = object.limit;
                    else if (typeof object.limit === "object")
                        message.limit = new $util.LongBits(object.limit.low >>> 0, object.limit.high >>> 0).toNumber(true);
                if (object.sinceTx != null)
                    if ($util.Long)
                        (message.sinceTx = $util.Long.fromValue(object.sinceTx)).unsigned = true;
                    else if (typeof object.sinceTx === "string")
                        message.sinceTx = parseInt(object.sinceTx, 10);
                    else if (typeof object.sinceTx === "number")
                        message.sinceTx = object.sinceTx;
                    else if (typeof object.sinceTx === "object")
                        message.sinceTx = new $util.LongBits(object.sinceTx.low >>> 0, object.sinceTx.high >>> 0).toNumber(true);
                if (object.noWait != null)
                    message.noWait = Boolean(object.noWait);
                if (object.inclusiveSeek != null)
                    message.inclusiveSeek = Boolean(object.inclusiveSeek);
                if (object.inclusiveEnd != null)
                    message.inclusiveEnd = Boolean(object.inclusiveEnd);
                return message;
            };

            /**
             * Creates a plain object from a ScanRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.ScanRequest
             * @static
             * @param {immudb.schema.ScanRequest} message ScanRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ScanRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.seekKey = "";
                    else {
                        object.seekKey = [];
                        if (options.bytes !== Array)
                            object.seekKey = $util.newBuffer(object.seekKey);
                    }
                    if (options.bytes === String)
                        object.prefix = "";
                    else {
                        object.prefix = [];
                        if (options.bytes !== Array)
                            object.prefix = $util.newBuffer(object.prefix);
                    }
                    object.desc = false;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.limit = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.sinceTx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sinceTx = options.longs === String ? "0" : 0;
                    object.noWait = false;
                    if (options.bytes === String)
                        object.endKey = "";
                    else {
                        object.endKey = [];
                        if (options.bytes !== Array)
                            object.endKey = $util.newBuffer(object.endKey);
                    }
                    object.inclusiveSeek = false;
                    object.inclusiveEnd = false;
                }
                if (message.seekKey != null && message.hasOwnProperty("seekKey"))
                    object.seekKey = options.bytes === String ? $util.base64.encode(message.seekKey, 0, message.seekKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.seekKey) : message.seekKey;
                if (message.prefix != null && message.hasOwnProperty("prefix"))
                    object.prefix = options.bytes === String ? $util.base64.encode(message.prefix, 0, message.prefix.length) : options.bytes === Array ? Array.prototype.slice.call(message.prefix) : message.prefix;
                if (message.desc != null && message.hasOwnProperty("desc"))
                    object.desc = message.desc;
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (typeof message.limit === "number")
                        object.limit = options.longs === String ? String(message.limit) : message.limit;
                    else
                        object.limit = options.longs === String ? $util.Long.prototype.toString.call(message.limit) : options.longs === Number ? new $util.LongBits(message.limit.low >>> 0, message.limit.high >>> 0).toNumber(true) : message.limit;
                if (message.sinceTx != null && message.hasOwnProperty("sinceTx"))
                    if (typeof message.sinceTx === "number")
                        object.sinceTx = options.longs === String ? String(message.sinceTx) : message.sinceTx;
                    else
                        object.sinceTx = options.longs === String ? $util.Long.prototype.toString.call(message.sinceTx) : options.longs === Number ? new $util.LongBits(message.sinceTx.low >>> 0, message.sinceTx.high >>> 0).toNumber(true) : message.sinceTx;
                if (message.noWait != null && message.hasOwnProperty("noWait"))
                    object.noWait = message.noWait;
                if (message.endKey != null && message.hasOwnProperty("endKey"))
                    object.endKey = options.bytes === String ? $util.base64.encode(message.endKey, 0, message.endKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.endKey) : message.endKey;
                if (message.inclusiveSeek != null && message.hasOwnProperty("inclusiveSeek"))
                    object.inclusiveSeek = message.inclusiveSeek;
                if (message.inclusiveEnd != null && message.hasOwnProperty("inclusiveEnd"))
                    object.inclusiveEnd = message.inclusiveEnd;
                return object;
            };

            /**
             * Converts this ScanRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.ScanRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ScanRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ScanRequest
             * @function getTypeUrl
             * @memberof immudb.schema.ScanRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ScanRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.ScanRequest";
            };

            return ScanRequest;
        })();

        schema.KeyPrefix = (function() {

            /**
             * Properties of a KeyPrefix.
             * @memberof immudb.schema
             * @interface IKeyPrefix
             * @property {Uint8Array|null} [prefix] KeyPrefix prefix
             */

            /**
             * Constructs a new KeyPrefix.
             * @memberof immudb.schema
             * @classdesc Represents a KeyPrefix.
             * @implements IKeyPrefix
             * @constructor
             * @param {immudb.schema.IKeyPrefix=} [properties] Properties to set
             */
            function KeyPrefix(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KeyPrefix prefix.
             * @member {Uint8Array} prefix
             * @memberof immudb.schema.KeyPrefix
             * @instance
             */
            KeyPrefix.prototype.prefix = $util.newBuffer([]);

            /**
             * Creates a new KeyPrefix instance using the specified properties.
             * @function create
             * @memberof immudb.schema.KeyPrefix
             * @static
             * @param {immudb.schema.IKeyPrefix=} [properties] Properties to set
             * @returns {immudb.schema.KeyPrefix} KeyPrefix instance
             */
            KeyPrefix.create = function create(properties) {
                return new KeyPrefix(properties);
            };

            /**
             * Encodes the specified KeyPrefix message. Does not implicitly {@link immudb.schema.KeyPrefix.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.KeyPrefix
             * @static
             * @param {immudb.schema.IKeyPrefix} message KeyPrefix message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyPrefix.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.prefix != null && Object.hasOwnProperty.call(message, "prefix"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.prefix);
                return writer;
            };

            /**
             * Encodes the specified KeyPrefix message, length delimited. Does not implicitly {@link immudb.schema.KeyPrefix.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.KeyPrefix
             * @static
             * @param {immudb.schema.IKeyPrefix} message KeyPrefix message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyPrefix.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KeyPrefix message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.KeyPrefix
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.KeyPrefix} KeyPrefix
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyPrefix.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.KeyPrefix();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.prefix = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KeyPrefix message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.KeyPrefix
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.KeyPrefix} KeyPrefix
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyPrefix.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KeyPrefix message.
             * @function verify
             * @memberof immudb.schema.KeyPrefix
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KeyPrefix.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.prefix != null && message.hasOwnProperty("prefix"))
                    if (!(message.prefix && typeof message.prefix.length === "number" || $util.isString(message.prefix)))
                        return "prefix: buffer expected";
                return null;
            };

            /**
             * Creates a KeyPrefix message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.KeyPrefix
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.KeyPrefix} KeyPrefix
             */
            KeyPrefix.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.KeyPrefix)
                    return object;
                let message = new $root.immudb.schema.KeyPrefix();
                if (object.prefix != null)
                    if (typeof object.prefix === "string")
                        $util.base64.decode(object.prefix, message.prefix = $util.newBuffer($util.base64.length(object.prefix)), 0);
                    else if (object.prefix.length >= 0)
                        message.prefix = object.prefix;
                return message;
            };

            /**
             * Creates a plain object from a KeyPrefix message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.KeyPrefix
             * @static
             * @param {immudb.schema.KeyPrefix} message KeyPrefix
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KeyPrefix.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.prefix = "";
                    else {
                        object.prefix = [];
                        if (options.bytes !== Array)
                            object.prefix = $util.newBuffer(object.prefix);
                    }
                if (message.prefix != null && message.hasOwnProperty("prefix"))
                    object.prefix = options.bytes === String ? $util.base64.encode(message.prefix, 0, message.prefix.length) : options.bytes === Array ? Array.prototype.slice.call(message.prefix) : message.prefix;
                return object;
            };

            /**
             * Converts this KeyPrefix to JSON.
             * @function toJSON
             * @memberof immudb.schema.KeyPrefix
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KeyPrefix.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for KeyPrefix
             * @function getTypeUrl
             * @memberof immudb.schema.KeyPrefix
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            KeyPrefix.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.KeyPrefix";
            };

            return KeyPrefix;
        })();

        schema.EntryCount = (function() {

            /**
             * Properties of an EntryCount.
             * @memberof immudb.schema
             * @interface IEntryCount
             * @property {Long|null} [count] EntryCount count
             */

            /**
             * Constructs a new EntryCount.
             * @memberof immudb.schema
             * @classdesc Represents an EntryCount.
             * @implements IEntryCount
             * @constructor
             * @param {immudb.schema.IEntryCount=} [properties] Properties to set
             */
            function EntryCount(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EntryCount count.
             * @member {Long} count
             * @memberof immudb.schema.EntryCount
             * @instance
             */
            EntryCount.prototype.count = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new EntryCount instance using the specified properties.
             * @function create
             * @memberof immudb.schema.EntryCount
             * @static
             * @param {immudb.schema.IEntryCount=} [properties] Properties to set
             * @returns {immudb.schema.EntryCount} EntryCount instance
             */
            EntryCount.create = function create(properties) {
                return new EntryCount(properties);
            };

            /**
             * Encodes the specified EntryCount message. Does not implicitly {@link immudb.schema.EntryCount.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.EntryCount
             * @static
             * @param {immudb.schema.IEntryCount} message EntryCount message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EntryCount.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.count);
                return writer;
            };

            /**
             * Encodes the specified EntryCount message, length delimited. Does not implicitly {@link immudb.schema.EntryCount.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.EntryCount
             * @static
             * @param {immudb.schema.IEntryCount} message EntryCount message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EntryCount.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EntryCount message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.EntryCount
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.EntryCount} EntryCount
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EntryCount.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.EntryCount();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.count = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EntryCount message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.EntryCount
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.EntryCount} EntryCount
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EntryCount.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EntryCount message.
             * @function verify
             * @memberof immudb.schema.EntryCount
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EntryCount.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.count != null && message.hasOwnProperty("count"))
                    if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))
                        return "count: integer|Long expected";
                return null;
            };

            /**
             * Creates an EntryCount message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.EntryCount
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.EntryCount} EntryCount
             */
            EntryCount.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.EntryCount)
                    return object;
                let message = new $root.immudb.schema.EntryCount();
                if (object.count != null)
                    if ($util.Long)
                        (message.count = $util.Long.fromValue(object.count)).unsigned = true;
                    else if (typeof object.count === "string")
                        message.count = parseInt(object.count, 10);
                    else if (typeof object.count === "number")
                        message.count = object.count;
                    else if (typeof object.count === "object")
                        message.count = new $util.LongBits(object.count.low >>> 0, object.count.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from an EntryCount message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.EntryCount
             * @static
             * @param {immudb.schema.EntryCount} message EntryCount
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EntryCount.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.count = options.longs === String ? "0" : 0;
                if (message.count != null && message.hasOwnProperty("count"))
                    if (typeof message.count === "number")
                        object.count = options.longs === String ? String(message.count) : message.count;
                    else
                        object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber(true) : message.count;
                return object;
            };

            /**
             * Converts this EntryCount to JSON.
             * @function toJSON
             * @memberof immudb.schema.EntryCount
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EntryCount.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for EntryCount
             * @function getTypeUrl
             * @memberof immudb.schema.EntryCount
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            EntryCount.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.EntryCount";
            };

            return EntryCount;
        })();

        schema.Signature = (function() {

            /**
             * Properties of a Signature.
             * @memberof immudb.schema
             * @interface ISignature
             * @property {Uint8Array|null} [publicKey] Signature publicKey
             * @property {Uint8Array|null} [signature] Signature signature
             */

            /**
             * Constructs a new Signature.
             * @memberof immudb.schema
             * @classdesc Represents a Signature.
             * @implements ISignature
             * @constructor
             * @param {immudb.schema.ISignature=} [properties] Properties to set
             */
            function Signature(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Signature publicKey.
             * @member {Uint8Array} publicKey
             * @memberof immudb.schema.Signature
             * @instance
             */
            Signature.prototype.publicKey = $util.newBuffer([]);

            /**
             * Signature signature.
             * @member {Uint8Array} signature
             * @memberof immudb.schema.Signature
             * @instance
             */
            Signature.prototype.signature = $util.newBuffer([]);

            /**
             * Creates a new Signature instance using the specified properties.
             * @function create
             * @memberof immudb.schema.Signature
             * @static
             * @param {immudb.schema.ISignature=} [properties] Properties to set
             * @returns {immudb.schema.Signature} Signature instance
             */
            Signature.create = function create(properties) {
                return new Signature(properties);
            };

            /**
             * Encodes the specified Signature message. Does not implicitly {@link immudb.schema.Signature.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.Signature
             * @static
             * @param {immudb.schema.ISignature} message Signature message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Signature.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicKey);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                return writer;
            };

            /**
             * Encodes the specified Signature message, length delimited. Does not implicitly {@link immudb.schema.Signature.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.Signature
             * @static
             * @param {immudb.schema.ISignature} message Signature message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Signature.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Signature message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.Signature
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.Signature} Signature
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Signature.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.Signature();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.publicKey = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.signature = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Signature message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.Signature
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.Signature} Signature
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Signature.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Signature message.
             * @function verify
             * @memberof immudb.schema.Signature
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Signature.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                    if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                        return "publicKey: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };

            /**
             * Creates a Signature message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.Signature
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.Signature} Signature
             */
            Signature.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.Signature)
                    return object;
                let message = new $root.immudb.schema.Signature();
                if (object.publicKey != null)
                    if (typeof object.publicKey === "string")
                        $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                    else if (object.publicKey.length >= 0)
                        message.publicKey = object.publicKey;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                return message;
            };

            /**
             * Creates a plain object from a Signature message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.Signature
             * @static
             * @param {immudb.schema.Signature} message Signature
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Signature.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.publicKey = "";
                    else {
                        object.publicKey = [];
                        if (options.bytes !== Array)
                            object.publicKey = $util.newBuffer(object.publicKey);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                    object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };

            /**
             * Converts this Signature to JSON.
             * @function toJSON
             * @memberof immudb.schema.Signature
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Signature.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Signature
             * @function getTypeUrl
             * @memberof immudb.schema.Signature
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Signature.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.Signature";
            };

            return Signature;
        })();

        schema.TxHeader = (function() {

            /**
             * Properties of a TxHeader.
             * @memberof immudb.schema
             * @interface ITxHeader
             * @property {Long|null} [id] TxHeader id
             * @property {Uint8Array|null} [prevAlh] TxHeader prevAlh
             * @property {Long|null} [ts] TxHeader ts
             * @property {number|null} [nentries] TxHeader nentries
             * @property {Uint8Array|null} [eH] TxHeader eH
             * @property {Long|null} [blTxId] TxHeader blTxId
             * @property {Uint8Array|null} [blRoot] TxHeader blRoot
             * @property {number|null} [version] TxHeader version
             * @property {immudb.schema.ITxMetadata|null} [metadata] TxHeader metadata
             */

            /**
             * Constructs a new TxHeader.
             * @memberof immudb.schema
             * @classdesc Represents a TxHeader.
             * @implements ITxHeader
             * @constructor
             * @param {immudb.schema.ITxHeader=} [properties] Properties to set
             */
            function TxHeader(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TxHeader id.
             * @member {Long} id
             * @memberof immudb.schema.TxHeader
             * @instance
             */
            TxHeader.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * TxHeader prevAlh.
             * @member {Uint8Array} prevAlh
             * @memberof immudb.schema.TxHeader
             * @instance
             */
            TxHeader.prototype.prevAlh = $util.newBuffer([]);

            /**
             * TxHeader ts.
             * @member {Long} ts
             * @memberof immudb.schema.TxHeader
             * @instance
             */
            TxHeader.prototype.ts = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * TxHeader nentries.
             * @member {number} nentries
             * @memberof immudb.schema.TxHeader
             * @instance
             */
            TxHeader.prototype.nentries = 0;

            /**
             * TxHeader eH.
             * @member {Uint8Array} eH
             * @memberof immudb.schema.TxHeader
             * @instance
             */
            TxHeader.prototype.eH = $util.newBuffer([]);

            /**
             * TxHeader blTxId.
             * @member {Long} blTxId
             * @memberof immudb.schema.TxHeader
             * @instance
             */
            TxHeader.prototype.blTxId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * TxHeader blRoot.
             * @member {Uint8Array} blRoot
             * @memberof immudb.schema.TxHeader
             * @instance
             */
            TxHeader.prototype.blRoot = $util.newBuffer([]);

            /**
             * TxHeader version.
             * @member {number} version
             * @memberof immudb.schema.TxHeader
             * @instance
             */
            TxHeader.prototype.version = 0;

            /**
             * TxHeader metadata.
             * @member {immudb.schema.ITxMetadata|null|undefined} metadata
             * @memberof immudb.schema.TxHeader
             * @instance
             */
            TxHeader.prototype.metadata = null;

            /**
             * Creates a new TxHeader instance using the specified properties.
             * @function create
             * @memberof immudb.schema.TxHeader
             * @static
             * @param {immudb.schema.ITxHeader=} [properties] Properties to set
             * @returns {immudb.schema.TxHeader} TxHeader instance
             */
            TxHeader.create = function create(properties) {
                return new TxHeader(properties);
            };

            /**
             * Encodes the specified TxHeader message. Does not implicitly {@link immudb.schema.TxHeader.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.TxHeader
             * @static
             * @param {immudb.schema.ITxHeader} message TxHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxHeader.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
                if (message.prevAlh != null && Object.hasOwnProperty.call(message, "prevAlh"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.prevAlh);
                if (message.ts != null && Object.hasOwnProperty.call(message, "ts"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.ts);
                if (message.nentries != null && Object.hasOwnProperty.call(message, "nentries"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.nentries);
                if (message.eH != null && Object.hasOwnProperty.call(message, "eH"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.eH);
                if (message.blTxId != null && Object.hasOwnProperty.call(message, "blTxId"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.blTxId);
                if (message.blRoot != null && Object.hasOwnProperty.call(message, "blRoot"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.blRoot);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.version);
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    $root.immudb.schema.TxMetadata.encode(message.metadata, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TxHeader message, length delimited. Does not implicitly {@link immudb.schema.TxHeader.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.TxHeader
             * @static
             * @param {immudb.schema.ITxHeader} message TxHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxHeader.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TxHeader message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.TxHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.TxHeader} TxHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxHeader.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.TxHeader();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.prevAlh = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.ts = reader.int64();
                            break;
                        }
                    case 4: {
                            message.nentries = reader.int32();
                            break;
                        }
                    case 5: {
                            message.eH = reader.bytes();
                            break;
                        }
                    case 6: {
                            message.blTxId = reader.uint64();
                            break;
                        }
                    case 7: {
                            message.blRoot = reader.bytes();
                            break;
                        }
                    case 8: {
                            message.version = reader.int32();
                            break;
                        }
                    case 9: {
                            message.metadata = $root.immudb.schema.TxMetadata.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TxHeader message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.TxHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.TxHeader} TxHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxHeader.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TxHeader message.
             * @function verify
             * @memberof immudb.schema.TxHeader
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TxHeader.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                        return "id: integer|Long expected";
                if (message.prevAlh != null && message.hasOwnProperty("prevAlh"))
                    if (!(message.prevAlh && typeof message.prevAlh.length === "number" || $util.isString(message.prevAlh)))
                        return "prevAlh: buffer expected";
                if (message.ts != null && message.hasOwnProperty("ts"))
                    if (!$util.isInteger(message.ts) && !(message.ts && $util.isInteger(message.ts.low) && $util.isInteger(message.ts.high)))
                        return "ts: integer|Long expected";
                if (message.nentries != null && message.hasOwnProperty("nentries"))
                    if (!$util.isInteger(message.nentries))
                        return "nentries: integer expected";
                if (message.eH != null && message.hasOwnProperty("eH"))
                    if (!(message.eH && typeof message.eH.length === "number" || $util.isString(message.eH)))
                        return "eH: buffer expected";
                if (message.blTxId != null && message.hasOwnProperty("blTxId"))
                    if (!$util.isInteger(message.blTxId) && !(message.blTxId && $util.isInteger(message.blTxId.low) && $util.isInteger(message.blTxId.high)))
                        return "blTxId: integer|Long expected";
                if (message.blRoot != null && message.hasOwnProperty("blRoot"))
                    if (!(message.blRoot && typeof message.blRoot.length === "number" || $util.isString(message.blRoot)))
                        return "blRoot: buffer expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isInteger(message.version))
                        return "version: integer expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    let error = $root.immudb.schema.TxMetadata.verify(message.metadata);
                    if (error)
                        return "metadata." + error;
                }
                return null;
            };

            /**
             * Creates a TxHeader message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.TxHeader
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.TxHeader} TxHeader
             */
            TxHeader.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.TxHeader)
                    return object;
                let message = new $root.immudb.schema.TxHeader();
                if (object.id != null)
                    if ($util.Long)
                        (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                    else if (typeof object.id === "string")
                        message.id = parseInt(object.id, 10);
                    else if (typeof object.id === "number")
                        message.id = object.id;
                    else if (typeof object.id === "object")
                        message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
                if (object.prevAlh != null)
                    if (typeof object.prevAlh === "string")
                        $util.base64.decode(object.prevAlh, message.prevAlh = $util.newBuffer($util.base64.length(object.prevAlh)), 0);
                    else if (object.prevAlh.length >= 0)
                        message.prevAlh = object.prevAlh;
                if (object.ts != null)
                    if ($util.Long)
                        (message.ts = $util.Long.fromValue(object.ts)).unsigned = false;
                    else if (typeof object.ts === "string")
                        message.ts = parseInt(object.ts, 10);
                    else if (typeof object.ts === "number")
                        message.ts = object.ts;
                    else if (typeof object.ts === "object")
                        message.ts = new $util.LongBits(object.ts.low >>> 0, object.ts.high >>> 0).toNumber();
                if (object.nentries != null)
                    message.nentries = object.nentries | 0;
                if (object.eH != null)
                    if (typeof object.eH === "string")
                        $util.base64.decode(object.eH, message.eH = $util.newBuffer($util.base64.length(object.eH)), 0);
                    else if (object.eH.length >= 0)
                        message.eH = object.eH;
                if (object.blTxId != null)
                    if ($util.Long)
                        (message.blTxId = $util.Long.fromValue(object.blTxId)).unsigned = true;
                    else if (typeof object.blTxId === "string")
                        message.blTxId = parseInt(object.blTxId, 10);
                    else if (typeof object.blTxId === "number")
                        message.blTxId = object.blTxId;
                    else if (typeof object.blTxId === "object")
                        message.blTxId = new $util.LongBits(object.blTxId.low >>> 0, object.blTxId.high >>> 0).toNumber(true);
                if (object.blRoot != null)
                    if (typeof object.blRoot === "string")
                        $util.base64.decode(object.blRoot, message.blRoot = $util.newBuffer($util.base64.length(object.blRoot)), 0);
                    else if (object.blRoot.length >= 0)
                        message.blRoot = object.blRoot;
                if (object.version != null)
                    message.version = object.version | 0;
                if (object.metadata != null) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".immudb.schema.TxHeader.metadata: object expected");
                    message.metadata = $root.immudb.schema.TxMetadata.fromObject(object.metadata);
                }
                return message;
            };

            /**
             * Creates a plain object from a TxHeader message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.TxHeader
             * @static
             * @param {immudb.schema.TxHeader} message TxHeader
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TxHeader.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.id = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.prevAlh = "";
                    else {
                        object.prevAlh = [];
                        if (options.bytes !== Array)
                            object.prevAlh = $util.newBuffer(object.prevAlh);
                    }
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.ts = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ts = options.longs === String ? "0" : 0;
                    object.nentries = 0;
                    if (options.bytes === String)
                        object.eH = "";
                    else {
                        object.eH = [];
                        if (options.bytes !== Array)
                            object.eH = $util.newBuffer(object.eH);
                    }
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.blTxId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.blTxId = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.blRoot = "";
                    else {
                        object.blRoot = [];
                        if (options.bytes !== Array)
                            object.blRoot = $util.newBuffer(object.blRoot);
                    }
                    object.version = 0;
                    object.metadata = null;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    if (typeof message.id === "number")
                        object.id = options.longs === String ? String(message.id) : message.id;
                    else
                        object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
                if (message.prevAlh != null && message.hasOwnProperty("prevAlh"))
                    object.prevAlh = options.bytes === String ? $util.base64.encode(message.prevAlh, 0, message.prevAlh.length) : options.bytes === Array ? Array.prototype.slice.call(message.prevAlh) : message.prevAlh;
                if (message.ts != null && message.hasOwnProperty("ts"))
                    if (typeof message.ts === "number")
                        object.ts = options.longs === String ? String(message.ts) : message.ts;
                    else
                        object.ts = options.longs === String ? $util.Long.prototype.toString.call(message.ts) : options.longs === Number ? new $util.LongBits(message.ts.low >>> 0, message.ts.high >>> 0).toNumber() : message.ts;
                if (message.nentries != null && message.hasOwnProperty("nentries"))
                    object.nentries = message.nentries;
                if (message.eH != null && message.hasOwnProperty("eH"))
                    object.eH = options.bytes === String ? $util.base64.encode(message.eH, 0, message.eH.length) : options.bytes === Array ? Array.prototype.slice.call(message.eH) : message.eH;
                if (message.blTxId != null && message.hasOwnProperty("blTxId"))
                    if (typeof message.blTxId === "number")
                        object.blTxId = options.longs === String ? String(message.blTxId) : message.blTxId;
                    else
                        object.blTxId = options.longs === String ? $util.Long.prototype.toString.call(message.blTxId) : options.longs === Number ? new $util.LongBits(message.blTxId.low >>> 0, message.blTxId.high >>> 0).toNumber(true) : message.blTxId;
                if (message.blRoot != null && message.hasOwnProperty("blRoot"))
                    object.blRoot = options.bytes === String ? $util.base64.encode(message.blRoot, 0, message.blRoot.length) : options.bytes === Array ? Array.prototype.slice.call(message.blRoot) : message.blRoot;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = $root.immudb.schema.TxMetadata.toObject(message.metadata, options);
                return object;
            };

            /**
             * Converts this TxHeader to JSON.
             * @function toJSON
             * @memberof immudb.schema.TxHeader
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TxHeader.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TxHeader
             * @function getTypeUrl
             * @memberof immudb.schema.TxHeader
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TxHeader.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.TxHeader";
            };

            return TxHeader;
        })();

        schema.TxMetadata = (function() {

            /**
             * Properties of a TxMetadata.
             * @memberof immudb.schema
             * @interface ITxMetadata
             */

            /**
             * Constructs a new TxMetadata.
             * @memberof immudb.schema
             * @classdesc Represents a TxMetadata.
             * @implements ITxMetadata
             * @constructor
             * @param {immudb.schema.ITxMetadata=} [properties] Properties to set
             */
            function TxMetadata(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new TxMetadata instance using the specified properties.
             * @function create
             * @memberof immudb.schema.TxMetadata
             * @static
             * @param {immudb.schema.ITxMetadata=} [properties] Properties to set
             * @returns {immudb.schema.TxMetadata} TxMetadata instance
             */
            TxMetadata.create = function create(properties) {
                return new TxMetadata(properties);
            };

            /**
             * Encodes the specified TxMetadata message. Does not implicitly {@link immudb.schema.TxMetadata.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.TxMetadata
             * @static
             * @param {immudb.schema.ITxMetadata} message TxMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified TxMetadata message, length delimited. Does not implicitly {@link immudb.schema.TxMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.TxMetadata
             * @static
             * @param {immudb.schema.ITxMetadata} message TxMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TxMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.TxMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.TxMetadata} TxMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.TxMetadata();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TxMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.TxMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.TxMetadata} TxMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TxMetadata message.
             * @function verify
             * @memberof immudb.schema.TxMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TxMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a TxMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.TxMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.TxMetadata} TxMetadata
             */
            TxMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.TxMetadata)
                    return object;
                return new $root.immudb.schema.TxMetadata();
            };

            /**
             * Creates a plain object from a TxMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.TxMetadata
             * @static
             * @param {immudb.schema.TxMetadata} message TxMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TxMetadata.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this TxMetadata to JSON.
             * @function toJSON
             * @memberof immudb.schema.TxMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TxMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TxMetadata
             * @function getTypeUrl
             * @memberof immudb.schema.TxMetadata
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TxMetadata.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.TxMetadata";
            };

            return TxMetadata;
        })();

        schema.LinearProof = (function() {

            /**
             * Properties of a LinearProof.
             * @memberof immudb.schema
             * @interface ILinearProof
             * @property {Long|null} [sourceTxId] LinearProof sourceTxId
             * @property {Long|null} [TargetTxId] LinearProof TargetTxId
             * @property {Array.<Uint8Array>|null} [terms] LinearProof terms
             */

            /**
             * Constructs a new LinearProof.
             * @memberof immudb.schema
             * @classdesc Represents a LinearProof.
             * @implements ILinearProof
             * @constructor
             * @param {immudb.schema.ILinearProof=} [properties] Properties to set
             */
            function LinearProof(properties) {
                this.terms = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LinearProof sourceTxId.
             * @member {Long} sourceTxId
             * @memberof immudb.schema.LinearProof
             * @instance
             */
            LinearProof.prototype.sourceTxId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * LinearProof TargetTxId.
             * @member {Long} TargetTxId
             * @memberof immudb.schema.LinearProof
             * @instance
             */
            LinearProof.prototype.TargetTxId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * LinearProof terms.
             * @member {Array.<Uint8Array>} terms
             * @memberof immudb.schema.LinearProof
             * @instance
             */
            LinearProof.prototype.terms = $util.emptyArray;

            /**
             * Creates a new LinearProof instance using the specified properties.
             * @function create
             * @memberof immudb.schema.LinearProof
             * @static
             * @param {immudb.schema.ILinearProof=} [properties] Properties to set
             * @returns {immudb.schema.LinearProof} LinearProof instance
             */
            LinearProof.create = function create(properties) {
                return new LinearProof(properties);
            };

            /**
             * Encodes the specified LinearProof message. Does not implicitly {@link immudb.schema.LinearProof.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.LinearProof
             * @static
             * @param {immudb.schema.ILinearProof} message LinearProof message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LinearProof.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sourceTxId != null && Object.hasOwnProperty.call(message, "sourceTxId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.sourceTxId);
                if (message.TargetTxId != null && Object.hasOwnProperty.call(message, "TargetTxId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.TargetTxId);
                if (message.terms != null && message.terms.length)
                    for (let i = 0; i < message.terms.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.terms[i]);
                return writer;
            };

            /**
             * Encodes the specified LinearProof message, length delimited. Does not implicitly {@link immudb.schema.LinearProof.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.LinearProof
             * @static
             * @param {immudb.schema.ILinearProof} message LinearProof message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LinearProof.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LinearProof message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.LinearProof
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.LinearProof} LinearProof
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LinearProof.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.LinearProof();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.sourceTxId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.TargetTxId = reader.uint64();
                            break;
                        }
                    case 3: {
                            if (!(message.terms && message.terms.length))
                                message.terms = [];
                            message.terms.push(reader.bytes());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LinearProof message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.LinearProof
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.LinearProof} LinearProof
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LinearProof.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LinearProof message.
             * @function verify
             * @memberof immudb.schema.LinearProof
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LinearProof.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sourceTxId != null && message.hasOwnProperty("sourceTxId"))
                    if (!$util.isInteger(message.sourceTxId) && !(message.sourceTxId && $util.isInteger(message.sourceTxId.low) && $util.isInteger(message.sourceTxId.high)))
                        return "sourceTxId: integer|Long expected";
                if (message.TargetTxId != null && message.hasOwnProperty("TargetTxId"))
                    if (!$util.isInteger(message.TargetTxId) && !(message.TargetTxId && $util.isInteger(message.TargetTxId.low) && $util.isInteger(message.TargetTxId.high)))
                        return "TargetTxId: integer|Long expected";
                if (message.terms != null && message.hasOwnProperty("terms")) {
                    if (!Array.isArray(message.terms))
                        return "terms: array expected";
                    for (let i = 0; i < message.terms.length; ++i)
                        if (!(message.terms[i] && typeof message.terms[i].length === "number" || $util.isString(message.terms[i])))
                            return "terms: buffer[] expected";
                }
                return null;
            };

            /**
             * Creates a LinearProof message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.LinearProof
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.LinearProof} LinearProof
             */
            LinearProof.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.LinearProof)
                    return object;
                let message = new $root.immudb.schema.LinearProof();
                if (object.sourceTxId != null)
                    if ($util.Long)
                        (message.sourceTxId = $util.Long.fromValue(object.sourceTxId)).unsigned = true;
                    else if (typeof object.sourceTxId === "string")
                        message.sourceTxId = parseInt(object.sourceTxId, 10);
                    else if (typeof object.sourceTxId === "number")
                        message.sourceTxId = object.sourceTxId;
                    else if (typeof object.sourceTxId === "object")
                        message.sourceTxId = new $util.LongBits(object.sourceTxId.low >>> 0, object.sourceTxId.high >>> 0).toNumber(true);
                if (object.TargetTxId != null)
                    if ($util.Long)
                        (message.TargetTxId = $util.Long.fromValue(object.TargetTxId)).unsigned = true;
                    else if (typeof object.TargetTxId === "string")
                        message.TargetTxId = parseInt(object.TargetTxId, 10);
                    else if (typeof object.TargetTxId === "number")
                        message.TargetTxId = object.TargetTxId;
                    else if (typeof object.TargetTxId === "object")
                        message.TargetTxId = new $util.LongBits(object.TargetTxId.low >>> 0, object.TargetTxId.high >>> 0).toNumber(true);
                if (object.terms) {
                    if (!Array.isArray(object.terms))
                        throw TypeError(".immudb.schema.LinearProof.terms: array expected");
                    message.terms = [];
                    for (let i = 0; i < object.terms.length; ++i)
                        if (typeof object.terms[i] === "string")
                            $util.base64.decode(object.terms[i], message.terms[i] = $util.newBuffer($util.base64.length(object.terms[i])), 0);
                        else if (object.terms[i].length >= 0)
                            message.terms[i] = object.terms[i];
                }
                return message;
            };

            /**
             * Creates a plain object from a LinearProof message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.LinearProof
             * @static
             * @param {immudb.schema.LinearProof} message LinearProof
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LinearProof.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.terms = [];
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.sourceTxId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sourceTxId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.TargetTxId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.TargetTxId = options.longs === String ? "0" : 0;
                }
                if (message.sourceTxId != null && message.hasOwnProperty("sourceTxId"))
                    if (typeof message.sourceTxId === "number")
                        object.sourceTxId = options.longs === String ? String(message.sourceTxId) : message.sourceTxId;
                    else
                        object.sourceTxId = options.longs === String ? $util.Long.prototype.toString.call(message.sourceTxId) : options.longs === Number ? new $util.LongBits(message.sourceTxId.low >>> 0, message.sourceTxId.high >>> 0).toNumber(true) : message.sourceTxId;
                if (message.TargetTxId != null && message.hasOwnProperty("TargetTxId"))
                    if (typeof message.TargetTxId === "number")
                        object.TargetTxId = options.longs === String ? String(message.TargetTxId) : message.TargetTxId;
                    else
                        object.TargetTxId = options.longs === String ? $util.Long.prototype.toString.call(message.TargetTxId) : options.longs === Number ? new $util.LongBits(message.TargetTxId.low >>> 0, message.TargetTxId.high >>> 0).toNumber(true) : message.TargetTxId;
                if (message.terms && message.terms.length) {
                    object.terms = [];
                    for (let j = 0; j < message.terms.length; ++j)
                        object.terms[j] = options.bytes === String ? $util.base64.encode(message.terms[j], 0, message.terms[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.terms[j]) : message.terms[j];
                }
                return object;
            };

            /**
             * Converts this LinearProof to JSON.
             * @function toJSON
             * @memberof immudb.schema.LinearProof
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LinearProof.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LinearProof
             * @function getTypeUrl
             * @memberof immudb.schema.LinearProof
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LinearProof.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.LinearProof";
            };

            return LinearProof;
        })();

        schema.DualProof = (function() {

            /**
             * Properties of a DualProof.
             * @memberof immudb.schema
             * @interface IDualProof
             * @property {immudb.schema.ITxHeader|null} [sourceTxHeader] DualProof sourceTxHeader
             * @property {immudb.schema.ITxHeader|null} [targetTxHeader] DualProof targetTxHeader
             * @property {Array.<Uint8Array>|null} [inclusionProof] DualProof inclusionProof
             * @property {Array.<Uint8Array>|null} [consistencyProof] DualProof consistencyProof
             * @property {Uint8Array|null} [targetBlTxAlh] DualProof targetBlTxAlh
             * @property {Array.<Uint8Array>|null} [lastInclusionProof] DualProof lastInclusionProof
             * @property {immudb.schema.ILinearProof|null} [linearProof] DualProof linearProof
             */

            /**
             * Constructs a new DualProof.
             * @memberof immudb.schema
             * @classdesc Represents a DualProof.
             * @implements IDualProof
             * @constructor
             * @param {immudb.schema.IDualProof=} [properties] Properties to set
             */
            function DualProof(properties) {
                this.inclusionProof = [];
                this.consistencyProof = [];
                this.lastInclusionProof = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DualProof sourceTxHeader.
             * @member {immudb.schema.ITxHeader|null|undefined} sourceTxHeader
             * @memberof immudb.schema.DualProof
             * @instance
             */
            DualProof.prototype.sourceTxHeader = null;

            /**
             * DualProof targetTxHeader.
             * @member {immudb.schema.ITxHeader|null|undefined} targetTxHeader
             * @memberof immudb.schema.DualProof
             * @instance
             */
            DualProof.prototype.targetTxHeader = null;

            /**
             * DualProof inclusionProof.
             * @member {Array.<Uint8Array>} inclusionProof
             * @memberof immudb.schema.DualProof
             * @instance
             */
            DualProof.prototype.inclusionProof = $util.emptyArray;

            /**
             * DualProof consistencyProof.
             * @member {Array.<Uint8Array>} consistencyProof
             * @memberof immudb.schema.DualProof
             * @instance
             */
            DualProof.prototype.consistencyProof = $util.emptyArray;

            /**
             * DualProof targetBlTxAlh.
             * @member {Uint8Array} targetBlTxAlh
             * @memberof immudb.schema.DualProof
             * @instance
             */
            DualProof.prototype.targetBlTxAlh = $util.newBuffer([]);

            /**
             * DualProof lastInclusionProof.
             * @member {Array.<Uint8Array>} lastInclusionProof
             * @memberof immudb.schema.DualProof
             * @instance
             */
            DualProof.prototype.lastInclusionProof = $util.emptyArray;

            /**
             * DualProof linearProof.
             * @member {immudb.schema.ILinearProof|null|undefined} linearProof
             * @memberof immudb.schema.DualProof
             * @instance
             */
            DualProof.prototype.linearProof = null;

            /**
             * Creates a new DualProof instance using the specified properties.
             * @function create
             * @memberof immudb.schema.DualProof
             * @static
             * @param {immudb.schema.IDualProof=} [properties] Properties to set
             * @returns {immudb.schema.DualProof} DualProof instance
             */
            DualProof.create = function create(properties) {
                return new DualProof(properties);
            };

            /**
             * Encodes the specified DualProof message. Does not implicitly {@link immudb.schema.DualProof.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.DualProof
             * @static
             * @param {immudb.schema.IDualProof} message DualProof message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DualProof.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sourceTxHeader != null && Object.hasOwnProperty.call(message, "sourceTxHeader"))
                    $root.immudb.schema.TxHeader.encode(message.sourceTxHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.targetTxHeader != null && Object.hasOwnProperty.call(message, "targetTxHeader"))
                    $root.immudb.schema.TxHeader.encode(message.targetTxHeader, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.inclusionProof != null && message.inclusionProof.length)
                    for (let i = 0; i < message.inclusionProof.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.inclusionProof[i]);
                if (message.consistencyProof != null && message.consistencyProof.length)
                    for (let i = 0; i < message.consistencyProof.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.consistencyProof[i]);
                if (message.targetBlTxAlh != null && Object.hasOwnProperty.call(message, "targetBlTxAlh"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.targetBlTxAlh);
                if (message.lastInclusionProof != null && message.lastInclusionProof.length)
                    for (let i = 0; i < message.lastInclusionProof.length; ++i)
                        writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.lastInclusionProof[i]);
                if (message.linearProof != null && Object.hasOwnProperty.call(message, "linearProof"))
                    $root.immudb.schema.LinearProof.encode(message.linearProof, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DualProof message, length delimited. Does not implicitly {@link immudb.schema.DualProof.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.DualProof
             * @static
             * @param {immudb.schema.IDualProof} message DualProof message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DualProof.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DualProof message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.DualProof
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.DualProof} DualProof
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DualProof.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.DualProof();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.sourceTxHeader = $root.immudb.schema.TxHeader.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.targetTxHeader = $root.immudb.schema.TxHeader.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            if (!(message.inclusionProof && message.inclusionProof.length))
                                message.inclusionProof = [];
                            message.inclusionProof.push(reader.bytes());
                            break;
                        }
                    case 4: {
                            if (!(message.consistencyProof && message.consistencyProof.length))
                                message.consistencyProof = [];
                            message.consistencyProof.push(reader.bytes());
                            break;
                        }
                    case 5: {
                            message.targetBlTxAlh = reader.bytes();
                            break;
                        }
                    case 6: {
                            if (!(message.lastInclusionProof && message.lastInclusionProof.length))
                                message.lastInclusionProof = [];
                            message.lastInclusionProof.push(reader.bytes());
                            break;
                        }
                    case 7: {
                            message.linearProof = $root.immudb.schema.LinearProof.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DualProof message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.DualProof
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.DualProof} DualProof
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DualProof.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DualProof message.
             * @function verify
             * @memberof immudb.schema.DualProof
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DualProof.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sourceTxHeader != null && message.hasOwnProperty("sourceTxHeader")) {
                    let error = $root.immudb.schema.TxHeader.verify(message.sourceTxHeader);
                    if (error)
                        return "sourceTxHeader." + error;
                }
                if (message.targetTxHeader != null && message.hasOwnProperty("targetTxHeader")) {
                    let error = $root.immudb.schema.TxHeader.verify(message.targetTxHeader);
                    if (error)
                        return "targetTxHeader." + error;
                }
                if (message.inclusionProof != null && message.hasOwnProperty("inclusionProof")) {
                    if (!Array.isArray(message.inclusionProof))
                        return "inclusionProof: array expected";
                    for (let i = 0; i < message.inclusionProof.length; ++i)
                        if (!(message.inclusionProof[i] && typeof message.inclusionProof[i].length === "number" || $util.isString(message.inclusionProof[i])))
                            return "inclusionProof: buffer[] expected";
                }
                if (message.consistencyProof != null && message.hasOwnProperty("consistencyProof")) {
                    if (!Array.isArray(message.consistencyProof))
                        return "consistencyProof: array expected";
                    for (let i = 0; i < message.consistencyProof.length; ++i)
                        if (!(message.consistencyProof[i] && typeof message.consistencyProof[i].length === "number" || $util.isString(message.consistencyProof[i])))
                            return "consistencyProof: buffer[] expected";
                }
                if (message.targetBlTxAlh != null && message.hasOwnProperty("targetBlTxAlh"))
                    if (!(message.targetBlTxAlh && typeof message.targetBlTxAlh.length === "number" || $util.isString(message.targetBlTxAlh)))
                        return "targetBlTxAlh: buffer expected";
                if (message.lastInclusionProof != null && message.hasOwnProperty("lastInclusionProof")) {
                    if (!Array.isArray(message.lastInclusionProof))
                        return "lastInclusionProof: array expected";
                    for (let i = 0; i < message.lastInclusionProof.length; ++i)
                        if (!(message.lastInclusionProof[i] && typeof message.lastInclusionProof[i].length === "number" || $util.isString(message.lastInclusionProof[i])))
                            return "lastInclusionProof: buffer[] expected";
                }
                if (message.linearProof != null && message.hasOwnProperty("linearProof")) {
                    let error = $root.immudb.schema.LinearProof.verify(message.linearProof);
                    if (error)
                        return "linearProof." + error;
                }
                return null;
            };

            /**
             * Creates a DualProof message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.DualProof
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.DualProof} DualProof
             */
            DualProof.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.DualProof)
                    return object;
                let message = new $root.immudb.schema.DualProof();
                if (object.sourceTxHeader != null) {
                    if (typeof object.sourceTxHeader !== "object")
                        throw TypeError(".immudb.schema.DualProof.sourceTxHeader: object expected");
                    message.sourceTxHeader = $root.immudb.schema.TxHeader.fromObject(object.sourceTxHeader);
                }
                if (object.targetTxHeader != null) {
                    if (typeof object.targetTxHeader !== "object")
                        throw TypeError(".immudb.schema.DualProof.targetTxHeader: object expected");
                    message.targetTxHeader = $root.immudb.schema.TxHeader.fromObject(object.targetTxHeader);
                }
                if (object.inclusionProof) {
                    if (!Array.isArray(object.inclusionProof))
                        throw TypeError(".immudb.schema.DualProof.inclusionProof: array expected");
                    message.inclusionProof = [];
                    for (let i = 0; i < object.inclusionProof.length; ++i)
                        if (typeof object.inclusionProof[i] === "string")
                            $util.base64.decode(object.inclusionProof[i], message.inclusionProof[i] = $util.newBuffer($util.base64.length(object.inclusionProof[i])), 0);
                        else if (object.inclusionProof[i].length >= 0)
                            message.inclusionProof[i] = object.inclusionProof[i];
                }
                if (object.consistencyProof) {
                    if (!Array.isArray(object.consistencyProof))
                        throw TypeError(".immudb.schema.DualProof.consistencyProof: array expected");
                    message.consistencyProof = [];
                    for (let i = 0; i < object.consistencyProof.length; ++i)
                        if (typeof object.consistencyProof[i] === "string")
                            $util.base64.decode(object.consistencyProof[i], message.consistencyProof[i] = $util.newBuffer($util.base64.length(object.consistencyProof[i])), 0);
                        else if (object.consistencyProof[i].length >= 0)
                            message.consistencyProof[i] = object.consistencyProof[i];
                }
                if (object.targetBlTxAlh != null)
                    if (typeof object.targetBlTxAlh === "string")
                        $util.base64.decode(object.targetBlTxAlh, message.targetBlTxAlh = $util.newBuffer($util.base64.length(object.targetBlTxAlh)), 0);
                    else if (object.targetBlTxAlh.length >= 0)
                        message.targetBlTxAlh = object.targetBlTxAlh;
                if (object.lastInclusionProof) {
                    if (!Array.isArray(object.lastInclusionProof))
                        throw TypeError(".immudb.schema.DualProof.lastInclusionProof: array expected");
                    message.lastInclusionProof = [];
                    for (let i = 0; i < object.lastInclusionProof.length; ++i)
                        if (typeof object.lastInclusionProof[i] === "string")
                            $util.base64.decode(object.lastInclusionProof[i], message.lastInclusionProof[i] = $util.newBuffer($util.base64.length(object.lastInclusionProof[i])), 0);
                        else if (object.lastInclusionProof[i].length >= 0)
                            message.lastInclusionProof[i] = object.lastInclusionProof[i];
                }
                if (object.linearProof != null) {
                    if (typeof object.linearProof !== "object")
                        throw TypeError(".immudb.schema.DualProof.linearProof: object expected");
                    message.linearProof = $root.immudb.schema.LinearProof.fromObject(object.linearProof);
                }
                return message;
            };

            /**
             * Creates a plain object from a DualProof message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.DualProof
             * @static
             * @param {immudb.schema.DualProof} message DualProof
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DualProof.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.inclusionProof = [];
                    object.consistencyProof = [];
                    object.lastInclusionProof = [];
                }
                if (options.defaults) {
                    object.sourceTxHeader = null;
                    object.targetTxHeader = null;
                    if (options.bytes === String)
                        object.targetBlTxAlh = "";
                    else {
                        object.targetBlTxAlh = [];
                        if (options.bytes !== Array)
                            object.targetBlTxAlh = $util.newBuffer(object.targetBlTxAlh);
                    }
                    object.linearProof = null;
                }
                if (message.sourceTxHeader != null && message.hasOwnProperty("sourceTxHeader"))
                    object.sourceTxHeader = $root.immudb.schema.TxHeader.toObject(message.sourceTxHeader, options);
                if (message.targetTxHeader != null && message.hasOwnProperty("targetTxHeader"))
                    object.targetTxHeader = $root.immudb.schema.TxHeader.toObject(message.targetTxHeader, options);
                if (message.inclusionProof && message.inclusionProof.length) {
                    object.inclusionProof = [];
                    for (let j = 0; j < message.inclusionProof.length; ++j)
                        object.inclusionProof[j] = options.bytes === String ? $util.base64.encode(message.inclusionProof[j], 0, message.inclusionProof[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.inclusionProof[j]) : message.inclusionProof[j];
                }
                if (message.consistencyProof && message.consistencyProof.length) {
                    object.consistencyProof = [];
                    for (let j = 0; j < message.consistencyProof.length; ++j)
                        object.consistencyProof[j] = options.bytes === String ? $util.base64.encode(message.consistencyProof[j], 0, message.consistencyProof[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.consistencyProof[j]) : message.consistencyProof[j];
                }
                if (message.targetBlTxAlh != null && message.hasOwnProperty("targetBlTxAlh"))
                    object.targetBlTxAlh = options.bytes === String ? $util.base64.encode(message.targetBlTxAlh, 0, message.targetBlTxAlh.length) : options.bytes === Array ? Array.prototype.slice.call(message.targetBlTxAlh) : message.targetBlTxAlh;
                if (message.lastInclusionProof && message.lastInclusionProof.length) {
                    object.lastInclusionProof = [];
                    for (let j = 0; j < message.lastInclusionProof.length; ++j)
                        object.lastInclusionProof[j] = options.bytes === String ? $util.base64.encode(message.lastInclusionProof[j], 0, message.lastInclusionProof[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.lastInclusionProof[j]) : message.lastInclusionProof[j];
                }
                if (message.linearProof != null && message.hasOwnProperty("linearProof"))
                    object.linearProof = $root.immudb.schema.LinearProof.toObject(message.linearProof, options);
                return object;
            };

            /**
             * Converts this DualProof to JSON.
             * @function toJSON
             * @memberof immudb.schema.DualProof
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DualProof.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DualProof
             * @function getTypeUrl
             * @memberof immudb.schema.DualProof
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DualProof.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.DualProof";
            };

            return DualProof;
        })();

        schema.Tx = (function() {

            /**
             * Properties of a Tx.
             * @memberof immudb.schema
             * @interface ITx
             * @property {immudb.schema.ITxHeader|null} [header] Tx header
             * @property {Array.<immudb.schema.ITxEntry>|null} [entries] Tx entries
             * @property {Array.<immudb.schema.IEntry>|null} [kvEntries] Tx kvEntries
             * @property {Array.<immudb.schema.IZEntry>|null} [zEntries] Tx zEntries
             */

            /**
             * Constructs a new Tx.
             * @memberof immudb.schema
             * @classdesc Represents a Tx.
             * @implements ITx
             * @constructor
             * @param {immudb.schema.ITx=} [properties] Properties to set
             */
            function Tx(properties) {
                this.entries = [];
                this.kvEntries = [];
                this.zEntries = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Tx header.
             * @member {immudb.schema.ITxHeader|null|undefined} header
             * @memberof immudb.schema.Tx
             * @instance
             */
            Tx.prototype.header = null;

            /**
             * Tx entries.
             * @member {Array.<immudb.schema.ITxEntry>} entries
             * @memberof immudb.schema.Tx
             * @instance
             */
            Tx.prototype.entries = $util.emptyArray;

            /**
             * Tx kvEntries.
             * @member {Array.<immudb.schema.IEntry>} kvEntries
             * @memberof immudb.schema.Tx
             * @instance
             */
            Tx.prototype.kvEntries = $util.emptyArray;

            /**
             * Tx zEntries.
             * @member {Array.<immudb.schema.IZEntry>} zEntries
             * @memberof immudb.schema.Tx
             * @instance
             */
            Tx.prototype.zEntries = $util.emptyArray;

            /**
             * Creates a new Tx instance using the specified properties.
             * @function create
             * @memberof immudb.schema.Tx
             * @static
             * @param {immudb.schema.ITx=} [properties] Properties to set
             * @returns {immudb.schema.Tx} Tx instance
             */
            Tx.create = function create(properties) {
                return new Tx(properties);
            };

            /**
             * Encodes the specified Tx message. Does not implicitly {@link immudb.schema.Tx.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.Tx
             * @static
             * @param {immudb.schema.ITx} message Tx message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Tx.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.header != null && Object.hasOwnProperty.call(message, "header"))
                    $root.immudb.schema.TxHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.entries != null && message.entries.length)
                    for (let i = 0; i < message.entries.length; ++i)
                        $root.immudb.schema.TxEntry.encode(message.entries[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.kvEntries != null && message.kvEntries.length)
                    for (let i = 0; i < message.kvEntries.length; ++i)
                        $root.immudb.schema.Entry.encode(message.kvEntries[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.zEntries != null && message.zEntries.length)
                    for (let i = 0; i < message.zEntries.length; ++i)
                        $root.immudb.schema.ZEntry.encode(message.zEntries[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Tx message, length delimited. Does not implicitly {@link immudb.schema.Tx.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.Tx
             * @static
             * @param {immudb.schema.ITx} message Tx message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Tx.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Tx message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.Tx
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.Tx} Tx
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Tx.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.Tx();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.header = $root.immudb.schema.TxHeader.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            if (!(message.entries && message.entries.length))
                                message.entries = [];
                            message.entries.push($root.immudb.schema.TxEntry.decode(reader, reader.uint32()));
                            break;
                        }
                    case 3: {
                            if (!(message.kvEntries && message.kvEntries.length))
                                message.kvEntries = [];
                            message.kvEntries.push($root.immudb.schema.Entry.decode(reader, reader.uint32()));
                            break;
                        }
                    case 4: {
                            if (!(message.zEntries && message.zEntries.length))
                                message.zEntries = [];
                            message.zEntries.push($root.immudb.schema.ZEntry.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Tx message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.Tx
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.Tx} Tx
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Tx.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Tx message.
             * @function verify
             * @memberof immudb.schema.Tx
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Tx.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.header != null && message.hasOwnProperty("header")) {
                    let error = $root.immudb.schema.TxHeader.verify(message.header);
                    if (error)
                        return "header." + error;
                }
                if (message.entries != null && message.hasOwnProperty("entries")) {
                    if (!Array.isArray(message.entries))
                        return "entries: array expected";
                    for (let i = 0; i < message.entries.length; ++i) {
                        let error = $root.immudb.schema.TxEntry.verify(message.entries[i]);
                        if (error)
                            return "entries." + error;
                    }
                }
                if (message.kvEntries != null && message.hasOwnProperty("kvEntries")) {
                    if (!Array.isArray(message.kvEntries))
                        return "kvEntries: array expected";
                    for (let i = 0; i < message.kvEntries.length; ++i) {
                        let error = $root.immudb.schema.Entry.verify(message.kvEntries[i]);
                        if (error)
                            return "kvEntries." + error;
                    }
                }
                if (message.zEntries != null && message.hasOwnProperty("zEntries")) {
                    if (!Array.isArray(message.zEntries))
                        return "zEntries: array expected";
                    for (let i = 0; i < message.zEntries.length; ++i) {
                        let error = $root.immudb.schema.ZEntry.verify(message.zEntries[i]);
                        if (error)
                            return "zEntries." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Tx message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.Tx
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.Tx} Tx
             */
            Tx.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.Tx)
                    return object;
                let message = new $root.immudb.schema.Tx();
                if (object.header != null) {
                    if (typeof object.header !== "object")
                        throw TypeError(".immudb.schema.Tx.header: object expected");
                    message.header = $root.immudb.schema.TxHeader.fromObject(object.header);
                }
                if (object.entries) {
                    if (!Array.isArray(object.entries))
                        throw TypeError(".immudb.schema.Tx.entries: array expected");
                    message.entries = [];
                    for (let i = 0; i < object.entries.length; ++i) {
                        if (typeof object.entries[i] !== "object")
                            throw TypeError(".immudb.schema.Tx.entries: object expected");
                        message.entries[i] = $root.immudb.schema.TxEntry.fromObject(object.entries[i]);
                    }
                }
                if (object.kvEntries) {
                    if (!Array.isArray(object.kvEntries))
                        throw TypeError(".immudb.schema.Tx.kvEntries: array expected");
                    message.kvEntries = [];
                    for (let i = 0; i < object.kvEntries.length; ++i) {
                        if (typeof object.kvEntries[i] !== "object")
                            throw TypeError(".immudb.schema.Tx.kvEntries: object expected");
                        message.kvEntries[i] = $root.immudb.schema.Entry.fromObject(object.kvEntries[i]);
                    }
                }
                if (object.zEntries) {
                    if (!Array.isArray(object.zEntries))
                        throw TypeError(".immudb.schema.Tx.zEntries: array expected");
                    message.zEntries = [];
                    for (let i = 0; i < object.zEntries.length; ++i) {
                        if (typeof object.zEntries[i] !== "object")
                            throw TypeError(".immudb.schema.Tx.zEntries: object expected");
                        message.zEntries[i] = $root.immudb.schema.ZEntry.fromObject(object.zEntries[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Tx message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.Tx
             * @static
             * @param {immudb.schema.Tx} message Tx
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Tx.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.entries = [];
                    object.kvEntries = [];
                    object.zEntries = [];
                }
                if (options.defaults)
                    object.header = null;
                if (message.header != null && message.hasOwnProperty("header"))
                    object.header = $root.immudb.schema.TxHeader.toObject(message.header, options);
                if (message.entries && message.entries.length) {
                    object.entries = [];
                    for (let j = 0; j < message.entries.length; ++j)
                        object.entries[j] = $root.immudb.schema.TxEntry.toObject(message.entries[j], options);
                }
                if (message.kvEntries && message.kvEntries.length) {
                    object.kvEntries = [];
                    for (let j = 0; j < message.kvEntries.length; ++j)
                        object.kvEntries[j] = $root.immudb.schema.Entry.toObject(message.kvEntries[j], options);
                }
                if (message.zEntries && message.zEntries.length) {
                    object.zEntries = [];
                    for (let j = 0; j < message.zEntries.length; ++j)
                        object.zEntries[j] = $root.immudb.schema.ZEntry.toObject(message.zEntries[j], options);
                }
                return object;
            };

            /**
             * Converts this Tx to JSON.
             * @function toJSON
             * @memberof immudb.schema.Tx
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Tx.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Tx
             * @function getTypeUrl
             * @memberof immudb.schema.Tx
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Tx.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.Tx";
            };

            return Tx;
        })();

        schema.TxEntry = (function() {

            /**
             * Properties of a TxEntry.
             * @memberof immudb.schema
             * @interface ITxEntry
             * @property {Uint8Array|null} [key] TxEntry key
             * @property {Uint8Array|null} [hValue] TxEntry hValue
             * @property {number|null} [vLen] TxEntry vLen
             * @property {immudb.schema.IKVMetadata|null} [metadata] TxEntry metadata
             * @property {Uint8Array|null} [value] TxEntry value
             */

            /**
             * Constructs a new TxEntry.
             * @memberof immudb.schema
             * @classdesc Represents a TxEntry.
             * @implements ITxEntry
             * @constructor
             * @param {immudb.schema.ITxEntry=} [properties] Properties to set
             */
            function TxEntry(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TxEntry key.
             * @member {Uint8Array} key
             * @memberof immudb.schema.TxEntry
             * @instance
             */
            TxEntry.prototype.key = $util.newBuffer([]);

            /**
             * TxEntry hValue.
             * @member {Uint8Array} hValue
             * @memberof immudb.schema.TxEntry
             * @instance
             */
            TxEntry.prototype.hValue = $util.newBuffer([]);

            /**
             * TxEntry vLen.
             * @member {number} vLen
             * @memberof immudb.schema.TxEntry
             * @instance
             */
            TxEntry.prototype.vLen = 0;

            /**
             * TxEntry metadata.
             * @member {immudb.schema.IKVMetadata|null|undefined} metadata
             * @memberof immudb.schema.TxEntry
             * @instance
             */
            TxEntry.prototype.metadata = null;

            /**
             * TxEntry value.
             * @member {Uint8Array} value
             * @memberof immudb.schema.TxEntry
             * @instance
             */
            TxEntry.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new TxEntry instance using the specified properties.
             * @function create
             * @memberof immudb.schema.TxEntry
             * @static
             * @param {immudb.schema.ITxEntry=} [properties] Properties to set
             * @returns {immudb.schema.TxEntry} TxEntry instance
             */
            TxEntry.create = function create(properties) {
                return new TxEntry(properties);
            };

            /**
             * Encodes the specified TxEntry message. Does not implicitly {@link immudb.schema.TxEntry.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.TxEntry
             * @static
             * @param {immudb.schema.ITxEntry} message TxEntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxEntry.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
                if (message.hValue != null && Object.hasOwnProperty.call(message, "hValue"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.hValue);
                if (message.vLen != null && Object.hasOwnProperty.call(message, "vLen"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.vLen);
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    $root.immudb.schema.KVMetadata.encode(message.metadata, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified TxEntry message, length delimited. Does not implicitly {@link immudb.schema.TxEntry.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.TxEntry
             * @static
             * @param {immudb.schema.ITxEntry} message TxEntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxEntry.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TxEntry message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.TxEntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.TxEntry} TxEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxEntry.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.TxEntry();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.key = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.hValue = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.vLen = reader.int32();
                            break;
                        }
                    case 4: {
                            message.metadata = $root.immudb.schema.KVMetadata.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.value = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TxEntry message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.TxEntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.TxEntry} TxEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxEntry.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TxEntry message.
             * @function verify
             * @memberof immudb.schema.TxEntry
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TxEntry.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                        return "key: buffer expected";
                if (message.hValue != null && message.hasOwnProperty("hValue"))
                    if (!(message.hValue && typeof message.hValue.length === "number" || $util.isString(message.hValue)))
                        return "hValue: buffer expected";
                if (message.vLen != null && message.hasOwnProperty("vLen"))
                    if (!$util.isInteger(message.vLen))
                        return "vLen: integer expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    let error = $root.immudb.schema.KVMetadata.verify(message.metadata);
                    if (error)
                        return "metadata." + error;
                }
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates a TxEntry message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.TxEntry
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.TxEntry} TxEntry
             */
            TxEntry.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.TxEntry)
                    return object;
                let message = new $root.immudb.schema.TxEntry();
                if (object.key != null)
                    if (typeof object.key === "string")
                        $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                    else if (object.key.length >= 0)
                        message.key = object.key;
                if (object.hValue != null)
                    if (typeof object.hValue === "string")
                        $util.base64.decode(object.hValue, message.hValue = $util.newBuffer($util.base64.length(object.hValue)), 0);
                    else if (object.hValue.length >= 0)
                        message.hValue = object.hValue;
                if (object.vLen != null)
                    message.vLen = object.vLen | 0;
                if (object.metadata != null) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".immudb.schema.TxEntry.metadata: object expected");
                    message.metadata = $root.immudb.schema.KVMetadata.fromObject(object.metadata);
                }
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length >= 0)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from a TxEntry message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.TxEntry
             * @static
             * @param {immudb.schema.TxEntry} message TxEntry
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TxEntry.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.key = "";
                    else {
                        object.key = [];
                        if (options.bytes !== Array)
                            object.key = $util.newBuffer(object.key);
                    }
                    if (options.bytes === String)
                        object.hValue = "";
                    else {
                        object.hValue = [];
                        if (options.bytes !== Array)
                            object.hValue = $util.newBuffer(object.hValue);
                    }
                    object.vLen = 0;
                    object.metadata = null;
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                if (message.hValue != null && message.hasOwnProperty("hValue"))
                    object.hValue = options.bytes === String ? $util.base64.encode(message.hValue, 0, message.hValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.hValue) : message.hValue;
                if (message.vLen != null && message.hasOwnProperty("vLen"))
                    object.vLen = message.vLen;
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = $root.immudb.schema.KVMetadata.toObject(message.metadata, options);
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this TxEntry to JSON.
             * @function toJSON
             * @memberof immudb.schema.TxEntry
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TxEntry.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TxEntry
             * @function getTypeUrl
             * @memberof immudb.schema.TxEntry
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TxEntry.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.TxEntry";
            };

            return TxEntry;
        })();

        schema.KVMetadata = (function() {

            /**
             * Properties of a KVMetadata.
             * @memberof immudb.schema
             * @interface IKVMetadata
             * @property {boolean|null} [deleted] KVMetadata deleted
             * @property {immudb.schema.IExpiration|null} [expiration] KVMetadata expiration
             * @property {boolean|null} [nonIndexable] KVMetadata nonIndexable
             */

            /**
             * Constructs a new KVMetadata.
             * @memberof immudb.schema
             * @classdesc Represents a KVMetadata.
             * @implements IKVMetadata
             * @constructor
             * @param {immudb.schema.IKVMetadata=} [properties] Properties to set
             */
            function KVMetadata(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KVMetadata deleted.
             * @member {boolean} deleted
             * @memberof immudb.schema.KVMetadata
             * @instance
             */
            KVMetadata.prototype.deleted = false;

            /**
             * KVMetadata expiration.
             * @member {immudb.schema.IExpiration|null|undefined} expiration
             * @memberof immudb.schema.KVMetadata
             * @instance
             */
            KVMetadata.prototype.expiration = null;

            /**
             * KVMetadata nonIndexable.
             * @member {boolean} nonIndexable
             * @memberof immudb.schema.KVMetadata
             * @instance
             */
            KVMetadata.prototype.nonIndexable = false;

            /**
             * Creates a new KVMetadata instance using the specified properties.
             * @function create
             * @memberof immudb.schema.KVMetadata
             * @static
             * @param {immudb.schema.IKVMetadata=} [properties] Properties to set
             * @returns {immudb.schema.KVMetadata} KVMetadata instance
             */
            KVMetadata.create = function create(properties) {
                return new KVMetadata(properties);
            };

            /**
             * Encodes the specified KVMetadata message. Does not implicitly {@link immudb.schema.KVMetadata.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.KVMetadata
             * @static
             * @param {immudb.schema.IKVMetadata} message KVMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deleted != null && Object.hasOwnProperty.call(message, "deleted"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.deleted);
                if (message.expiration != null && Object.hasOwnProperty.call(message, "expiration"))
                    $root.immudb.schema.Expiration.encode(message.expiration, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.nonIndexable != null && Object.hasOwnProperty.call(message, "nonIndexable"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.nonIndexable);
                return writer;
            };

            /**
             * Encodes the specified KVMetadata message, length delimited. Does not implicitly {@link immudb.schema.KVMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.KVMetadata
             * @static
             * @param {immudb.schema.IKVMetadata} message KVMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KVMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.KVMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.KVMetadata} KVMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.KVMetadata();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.deleted = reader.bool();
                            break;
                        }
                    case 2: {
                            message.expiration = $root.immudb.schema.Expiration.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.nonIndexable = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KVMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.KVMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.KVMetadata} KVMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KVMetadata message.
             * @function verify
             * @memberof immudb.schema.KVMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KVMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deleted != null && message.hasOwnProperty("deleted"))
                    if (typeof message.deleted !== "boolean")
                        return "deleted: boolean expected";
                if (message.expiration != null && message.hasOwnProperty("expiration")) {
                    let error = $root.immudb.schema.Expiration.verify(message.expiration);
                    if (error)
                        return "expiration." + error;
                }
                if (message.nonIndexable != null && message.hasOwnProperty("nonIndexable"))
                    if (typeof message.nonIndexable !== "boolean")
                        return "nonIndexable: boolean expected";
                return null;
            };

            /**
             * Creates a KVMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.KVMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.KVMetadata} KVMetadata
             */
            KVMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.KVMetadata)
                    return object;
                let message = new $root.immudb.schema.KVMetadata();
                if (object.deleted != null)
                    message.deleted = Boolean(object.deleted);
                if (object.expiration != null) {
                    if (typeof object.expiration !== "object")
                        throw TypeError(".immudb.schema.KVMetadata.expiration: object expected");
                    message.expiration = $root.immudb.schema.Expiration.fromObject(object.expiration);
                }
                if (object.nonIndexable != null)
                    message.nonIndexable = Boolean(object.nonIndexable);
                return message;
            };

            /**
             * Creates a plain object from a KVMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.KVMetadata
             * @static
             * @param {immudb.schema.KVMetadata} message KVMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KVMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.deleted = false;
                    object.expiration = null;
                    object.nonIndexable = false;
                }
                if (message.deleted != null && message.hasOwnProperty("deleted"))
                    object.deleted = message.deleted;
                if (message.expiration != null && message.hasOwnProperty("expiration"))
                    object.expiration = $root.immudb.schema.Expiration.toObject(message.expiration, options);
                if (message.nonIndexable != null && message.hasOwnProperty("nonIndexable"))
                    object.nonIndexable = message.nonIndexable;
                return object;
            };

            /**
             * Converts this KVMetadata to JSON.
             * @function toJSON
             * @memberof immudb.schema.KVMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KVMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for KVMetadata
             * @function getTypeUrl
             * @memberof immudb.schema.KVMetadata
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            KVMetadata.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.KVMetadata";
            };

            return KVMetadata;
        })();

        schema.Expiration = (function() {

            /**
             * Properties of an Expiration.
             * @memberof immudb.schema
             * @interface IExpiration
             * @property {Long|null} [expiresAt] Expiration expiresAt
             */

            /**
             * Constructs a new Expiration.
             * @memberof immudb.schema
             * @classdesc Represents an Expiration.
             * @implements IExpiration
             * @constructor
             * @param {immudb.schema.IExpiration=} [properties] Properties to set
             */
            function Expiration(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Expiration expiresAt.
             * @member {Long} expiresAt
             * @memberof immudb.schema.Expiration
             * @instance
             */
            Expiration.prototype.expiresAt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Expiration instance using the specified properties.
             * @function create
             * @memberof immudb.schema.Expiration
             * @static
             * @param {immudb.schema.IExpiration=} [properties] Properties to set
             * @returns {immudb.schema.Expiration} Expiration instance
             */
            Expiration.create = function create(properties) {
                return new Expiration(properties);
            };

            /**
             * Encodes the specified Expiration message. Does not implicitly {@link immudb.schema.Expiration.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.Expiration
             * @static
             * @param {immudb.schema.IExpiration} message Expiration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Expiration.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.expiresAt != null && Object.hasOwnProperty.call(message, "expiresAt"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.expiresAt);
                return writer;
            };

            /**
             * Encodes the specified Expiration message, length delimited. Does not implicitly {@link immudb.schema.Expiration.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.Expiration
             * @static
             * @param {immudb.schema.IExpiration} message Expiration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Expiration.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Expiration message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.Expiration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.Expiration} Expiration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Expiration.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.Expiration();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.expiresAt = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Expiration message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.Expiration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.Expiration} Expiration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Expiration.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Expiration message.
             * @function verify
             * @memberof immudb.schema.Expiration
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Expiration.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.expiresAt != null && message.hasOwnProperty("expiresAt"))
                    if (!$util.isInteger(message.expiresAt) && !(message.expiresAt && $util.isInteger(message.expiresAt.low) && $util.isInteger(message.expiresAt.high)))
                        return "expiresAt: integer|Long expected";
                return null;
            };

            /**
             * Creates an Expiration message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.Expiration
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.Expiration} Expiration
             */
            Expiration.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.Expiration)
                    return object;
                let message = new $root.immudb.schema.Expiration();
                if (object.expiresAt != null)
                    if ($util.Long)
                        (message.expiresAt = $util.Long.fromValue(object.expiresAt)).unsigned = false;
                    else if (typeof object.expiresAt === "string")
                        message.expiresAt = parseInt(object.expiresAt, 10);
                    else if (typeof object.expiresAt === "number")
                        message.expiresAt = object.expiresAt;
                    else if (typeof object.expiresAt === "object")
                        message.expiresAt = new $util.LongBits(object.expiresAt.low >>> 0, object.expiresAt.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from an Expiration message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.Expiration
             * @static
             * @param {immudb.schema.Expiration} message Expiration
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Expiration.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.expiresAt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.expiresAt = options.longs === String ? "0" : 0;
                if (message.expiresAt != null && message.hasOwnProperty("expiresAt"))
                    if (typeof message.expiresAt === "number")
                        object.expiresAt = options.longs === String ? String(message.expiresAt) : message.expiresAt;
                    else
                        object.expiresAt = options.longs === String ? $util.Long.prototype.toString.call(message.expiresAt) : options.longs === Number ? new $util.LongBits(message.expiresAt.low >>> 0, message.expiresAt.high >>> 0).toNumber() : message.expiresAt;
                return object;
            };

            /**
             * Converts this Expiration to JSON.
             * @function toJSON
             * @memberof immudb.schema.Expiration
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Expiration.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Expiration
             * @function getTypeUrl
             * @memberof immudb.schema.Expiration
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Expiration.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.Expiration";
            };

            return Expiration;
        })();

        schema.VerifiableTx = (function() {

            /**
             * Properties of a VerifiableTx.
             * @memberof immudb.schema
             * @interface IVerifiableTx
             * @property {immudb.schema.ITx|null} [tx] VerifiableTx tx
             * @property {immudb.schema.IDualProof|null} [dualProof] VerifiableTx dualProof
             * @property {immudb.schema.ISignature|null} [signature] VerifiableTx signature
             */

            /**
             * Constructs a new VerifiableTx.
             * @memberof immudb.schema
             * @classdesc Represents a VerifiableTx.
             * @implements IVerifiableTx
             * @constructor
             * @param {immudb.schema.IVerifiableTx=} [properties] Properties to set
             */
            function VerifiableTx(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VerifiableTx tx.
             * @member {immudb.schema.ITx|null|undefined} tx
             * @memberof immudb.schema.VerifiableTx
             * @instance
             */
            VerifiableTx.prototype.tx = null;

            /**
             * VerifiableTx dualProof.
             * @member {immudb.schema.IDualProof|null|undefined} dualProof
             * @memberof immudb.schema.VerifiableTx
             * @instance
             */
            VerifiableTx.prototype.dualProof = null;

            /**
             * VerifiableTx signature.
             * @member {immudb.schema.ISignature|null|undefined} signature
             * @memberof immudb.schema.VerifiableTx
             * @instance
             */
            VerifiableTx.prototype.signature = null;

            /**
             * Creates a new VerifiableTx instance using the specified properties.
             * @function create
             * @memberof immudb.schema.VerifiableTx
             * @static
             * @param {immudb.schema.IVerifiableTx=} [properties] Properties to set
             * @returns {immudb.schema.VerifiableTx} VerifiableTx instance
             */
            VerifiableTx.create = function create(properties) {
                return new VerifiableTx(properties);
            };

            /**
             * Encodes the specified VerifiableTx message. Does not implicitly {@link immudb.schema.VerifiableTx.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.VerifiableTx
             * @static
             * @param {immudb.schema.IVerifiableTx} message VerifiableTx message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VerifiableTx.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tx != null && Object.hasOwnProperty.call(message, "tx"))
                    $root.immudb.schema.Tx.encode(message.tx, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.dualProof != null && Object.hasOwnProperty.call(message, "dualProof"))
                    $root.immudb.schema.DualProof.encode(message.dualProof, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    $root.immudb.schema.Signature.encode(message.signature, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified VerifiableTx message, length delimited. Does not implicitly {@link immudb.schema.VerifiableTx.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.VerifiableTx
             * @static
             * @param {immudb.schema.IVerifiableTx} message VerifiableTx message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VerifiableTx.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VerifiableTx message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.VerifiableTx
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.VerifiableTx} VerifiableTx
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VerifiableTx.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.VerifiableTx();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.tx = $root.immudb.schema.Tx.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.dualProof = $root.immudb.schema.DualProof.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.signature = $root.immudb.schema.Signature.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VerifiableTx message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.VerifiableTx
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.VerifiableTx} VerifiableTx
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VerifiableTx.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VerifiableTx message.
             * @function verify
             * @memberof immudb.schema.VerifiableTx
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VerifiableTx.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tx != null && message.hasOwnProperty("tx")) {
                    let error = $root.immudb.schema.Tx.verify(message.tx);
                    if (error)
                        return "tx." + error;
                }
                if (message.dualProof != null && message.hasOwnProperty("dualProof")) {
                    let error = $root.immudb.schema.DualProof.verify(message.dualProof);
                    if (error)
                        return "dualProof." + error;
                }
                if (message.signature != null && message.hasOwnProperty("signature")) {
                    let error = $root.immudb.schema.Signature.verify(message.signature);
                    if (error)
                        return "signature." + error;
                }
                return null;
            };

            /**
             * Creates a VerifiableTx message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.VerifiableTx
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.VerifiableTx} VerifiableTx
             */
            VerifiableTx.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.VerifiableTx)
                    return object;
                let message = new $root.immudb.schema.VerifiableTx();
                if (object.tx != null) {
                    if (typeof object.tx !== "object")
                        throw TypeError(".immudb.schema.VerifiableTx.tx: object expected");
                    message.tx = $root.immudb.schema.Tx.fromObject(object.tx);
                }
                if (object.dualProof != null) {
                    if (typeof object.dualProof !== "object")
                        throw TypeError(".immudb.schema.VerifiableTx.dualProof: object expected");
                    message.dualProof = $root.immudb.schema.DualProof.fromObject(object.dualProof);
                }
                if (object.signature != null) {
                    if (typeof object.signature !== "object")
                        throw TypeError(".immudb.schema.VerifiableTx.signature: object expected");
                    message.signature = $root.immudb.schema.Signature.fromObject(object.signature);
                }
                return message;
            };

            /**
             * Creates a plain object from a VerifiableTx message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.VerifiableTx
             * @static
             * @param {immudb.schema.VerifiableTx} message VerifiableTx
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VerifiableTx.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.tx = null;
                    object.dualProof = null;
                    object.signature = null;
                }
                if (message.tx != null && message.hasOwnProperty("tx"))
                    object.tx = $root.immudb.schema.Tx.toObject(message.tx, options);
                if (message.dualProof != null && message.hasOwnProperty("dualProof"))
                    object.dualProof = $root.immudb.schema.DualProof.toObject(message.dualProof, options);
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = $root.immudb.schema.Signature.toObject(message.signature, options);
                return object;
            };

            /**
             * Converts this VerifiableTx to JSON.
             * @function toJSON
             * @memberof immudb.schema.VerifiableTx
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VerifiableTx.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for VerifiableTx
             * @function getTypeUrl
             * @memberof immudb.schema.VerifiableTx
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            VerifiableTx.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.VerifiableTx";
            };

            return VerifiableTx;
        })();

        schema.VerifiableEntry = (function() {

            /**
             * Properties of a VerifiableEntry.
             * @memberof immudb.schema
             * @interface IVerifiableEntry
             * @property {immudb.schema.IEntry|null} [entry] VerifiableEntry entry
             * @property {immudb.schema.IVerifiableTx|null} [verifiableTx] VerifiableEntry verifiableTx
             * @property {immudb.schema.IInclusionProof|null} [inclusionProof] VerifiableEntry inclusionProof
             */

            /**
             * Constructs a new VerifiableEntry.
             * @memberof immudb.schema
             * @classdesc Represents a VerifiableEntry.
             * @implements IVerifiableEntry
             * @constructor
             * @param {immudb.schema.IVerifiableEntry=} [properties] Properties to set
             */
            function VerifiableEntry(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VerifiableEntry entry.
             * @member {immudb.schema.IEntry|null|undefined} entry
             * @memberof immudb.schema.VerifiableEntry
             * @instance
             */
            VerifiableEntry.prototype.entry = null;

            /**
             * VerifiableEntry verifiableTx.
             * @member {immudb.schema.IVerifiableTx|null|undefined} verifiableTx
             * @memberof immudb.schema.VerifiableEntry
             * @instance
             */
            VerifiableEntry.prototype.verifiableTx = null;

            /**
             * VerifiableEntry inclusionProof.
             * @member {immudb.schema.IInclusionProof|null|undefined} inclusionProof
             * @memberof immudb.schema.VerifiableEntry
             * @instance
             */
            VerifiableEntry.prototype.inclusionProof = null;

            /**
             * Creates a new VerifiableEntry instance using the specified properties.
             * @function create
             * @memberof immudb.schema.VerifiableEntry
             * @static
             * @param {immudb.schema.IVerifiableEntry=} [properties] Properties to set
             * @returns {immudb.schema.VerifiableEntry} VerifiableEntry instance
             */
            VerifiableEntry.create = function create(properties) {
                return new VerifiableEntry(properties);
            };

            /**
             * Encodes the specified VerifiableEntry message. Does not implicitly {@link immudb.schema.VerifiableEntry.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.VerifiableEntry
             * @static
             * @param {immudb.schema.IVerifiableEntry} message VerifiableEntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VerifiableEntry.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.entry != null && Object.hasOwnProperty.call(message, "entry"))
                    $root.immudb.schema.Entry.encode(message.entry, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.verifiableTx != null && Object.hasOwnProperty.call(message, "verifiableTx"))
                    $root.immudb.schema.VerifiableTx.encode(message.verifiableTx, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.inclusionProof != null && Object.hasOwnProperty.call(message, "inclusionProof"))
                    $root.immudb.schema.InclusionProof.encode(message.inclusionProof, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified VerifiableEntry message, length delimited. Does not implicitly {@link immudb.schema.VerifiableEntry.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.VerifiableEntry
             * @static
             * @param {immudb.schema.IVerifiableEntry} message VerifiableEntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VerifiableEntry.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VerifiableEntry message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.VerifiableEntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.VerifiableEntry} VerifiableEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VerifiableEntry.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.VerifiableEntry();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.entry = $root.immudb.schema.Entry.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.verifiableTx = $root.immudb.schema.VerifiableTx.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.inclusionProof = $root.immudb.schema.InclusionProof.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VerifiableEntry message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.VerifiableEntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.VerifiableEntry} VerifiableEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VerifiableEntry.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VerifiableEntry message.
             * @function verify
             * @memberof immudb.schema.VerifiableEntry
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VerifiableEntry.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.entry != null && message.hasOwnProperty("entry")) {
                    let error = $root.immudb.schema.Entry.verify(message.entry);
                    if (error)
                        return "entry." + error;
                }
                if (message.verifiableTx != null && message.hasOwnProperty("verifiableTx")) {
                    let error = $root.immudb.schema.VerifiableTx.verify(message.verifiableTx);
                    if (error)
                        return "verifiableTx." + error;
                }
                if (message.inclusionProof != null && message.hasOwnProperty("inclusionProof")) {
                    let error = $root.immudb.schema.InclusionProof.verify(message.inclusionProof);
                    if (error)
                        return "inclusionProof." + error;
                }
                return null;
            };

            /**
             * Creates a VerifiableEntry message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.VerifiableEntry
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.VerifiableEntry} VerifiableEntry
             */
            VerifiableEntry.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.VerifiableEntry)
                    return object;
                let message = new $root.immudb.schema.VerifiableEntry();
                if (object.entry != null) {
                    if (typeof object.entry !== "object")
                        throw TypeError(".immudb.schema.VerifiableEntry.entry: object expected");
                    message.entry = $root.immudb.schema.Entry.fromObject(object.entry);
                }
                if (object.verifiableTx != null) {
                    if (typeof object.verifiableTx !== "object")
                        throw TypeError(".immudb.schema.VerifiableEntry.verifiableTx: object expected");
                    message.verifiableTx = $root.immudb.schema.VerifiableTx.fromObject(object.verifiableTx);
                }
                if (object.inclusionProof != null) {
                    if (typeof object.inclusionProof !== "object")
                        throw TypeError(".immudb.schema.VerifiableEntry.inclusionProof: object expected");
                    message.inclusionProof = $root.immudb.schema.InclusionProof.fromObject(object.inclusionProof);
                }
                return message;
            };

            /**
             * Creates a plain object from a VerifiableEntry message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.VerifiableEntry
             * @static
             * @param {immudb.schema.VerifiableEntry} message VerifiableEntry
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VerifiableEntry.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.entry = null;
                    object.verifiableTx = null;
                    object.inclusionProof = null;
                }
                if (message.entry != null && message.hasOwnProperty("entry"))
                    object.entry = $root.immudb.schema.Entry.toObject(message.entry, options);
                if (message.verifiableTx != null && message.hasOwnProperty("verifiableTx"))
                    object.verifiableTx = $root.immudb.schema.VerifiableTx.toObject(message.verifiableTx, options);
                if (message.inclusionProof != null && message.hasOwnProperty("inclusionProof"))
                    object.inclusionProof = $root.immudb.schema.InclusionProof.toObject(message.inclusionProof, options);
                return object;
            };

            /**
             * Converts this VerifiableEntry to JSON.
             * @function toJSON
             * @memberof immudb.schema.VerifiableEntry
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VerifiableEntry.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for VerifiableEntry
             * @function getTypeUrl
             * @memberof immudb.schema.VerifiableEntry
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            VerifiableEntry.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.VerifiableEntry";
            };

            return VerifiableEntry;
        })();

        schema.InclusionProof = (function() {

            /**
             * Properties of an InclusionProof.
             * @memberof immudb.schema
             * @interface IInclusionProof
             * @property {number|null} [leaf] InclusionProof leaf
             * @property {number|null} [width] InclusionProof width
             * @property {Array.<Uint8Array>|null} [terms] InclusionProof terms
             */

            /**
             * Constructs a new InclusionProof.
             * @memberof immudb.schema
             * @classdesc Represents an InclusionProof.
             * @implements IInclusionProof
             * @constructor
             * @param {immudb.schema.IInclusionProof=} [properties] Properties to set
             */
            function InclusionProof(properties) {
                this.terms = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * InclusionProof leaf.
             * @member {number} leaf
             * @memberof immudb.schema.InclusionProof
             * @instance
             */
            InclusionProof.prototype.leaf = 0;

            /**
             * InclusionProof width.
             * @member {number} width
             * @memberof immudb.schema.InclusionProof
             * @instance
             */
            InclusionProof.prototype.width = 0;

            /**
             * InclusionProof terms.
             * @member {Array.<Uint8Array>} terms
             * @memberof immudb.schema.InclusionProof
             * @instance
             */
            InclusionProof.prototype.terms = $util.emptyArray;

            /**
             * Creates a new InclusionProof instance using the specified properties.
             * @function create
             * @memberof immudb.schema.InclusionProof
             * @static
             * @param {immudb.schema.IInclusionProof=} [properties] Properties to set
             * @returns {immudb.schema.InclusionProof} InclusionProof instance
             */
            InclusionProof.create = function create(properties) {
                return new InclusionProof(properties);
            };

            /**
             * Encodes the specified InclusionProof message. Does not implicitly {@link immudb.schema.InclusionProof.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.InclusionProof
             * @static
             * @param {immudb.schema.IInclusionProof} message InclusionProof message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InclusionProof.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.leaf != null && Object.hasOwnProperty.call(message, "leaf"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.leaf);
                if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.width);
                if (message.terms != null && message.terms.length)
                    for (let i = 0; i < message.terms.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.terms[i]);
                return writer;
            };

            /**
             * Encodes the specified InclusionProof message, length delimited. Does not implicitly {@link immudb.schema.InclusionProof.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.InclusionProof
             * @static
             * @param {immudb.schema.IInclusionProof} message InclusionProof message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InclusionProof.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an InclusionProof message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.InclusionProof
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.InclusionProof} InclusionProof
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InclusionProof.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.InclusionProof();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.leaf = reader.int32();
                            break;
                        }
                    case 2: {
                            message.width = reader.int32();
                            break;
                        }
                    case 3: {
                            if (!(message.terms && message.terms.length))
                                message.terms = [];
                            message.terms.push(reader.bytes());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an InclusionProof message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.InclusionProof
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.InclusionProof} InclusionProof
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InclusionProof.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an InclusionProof message.
             * @function verify
             * @memberof immudb.schema.InclusionProof
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            InclusionProof.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.leaf != null && message.hasOwnProperty("leaf"))
                    if (!$util.isInteger(message.leaf))
                        return "leaf: integer expected";
                if (message.width != null && message.hasOwnProperty("width"))
                    if (!$util.isInteger(message.width))
                        return "width: integer expected";
                if (message.terms != null && message.hasOwnProperty("terms")) {
                    if (!Array.isArray(message.terms))
                        return "terms: array expected";
                    for (let i = 0; i < message.terms.length; ++i)
                        if (!(message.terms[i] && typeof message.terms[i].length === "number" || $util.isString(message.terms[i])))
                            return "terms: buffer[] expected";
                }
                return null;
            };

            /**
             * Creates an InclusionProof message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.InclusionProof
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.InclusionProof} InclusionProof
             */
            InclusionProof.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.InclusionProof)
                    return object;
                let message = new $root.immudb.schema.InclusionProof();
                if (object.leaf != null)
                    message.leaf = object.leaf | 0;
                if (object.width != null)
                    message.width = object.width | 0;
                if (object.terms) {
                    if (!Array.isArray(object.terms))
                        throw TypeError(".immudb.schema.InclusionProof.terms: array expected");
                    message.terms = [];
                    for (let i = 0; i < object.terms.length; ++i)
                        if (typeof object.terms[i] === "string")
                            $util.base64.decode(object.terms[i], message.terms[i] = $util.newBuffer($util.base64.length(object.terms[i])), 0);
                        else if (object.terms[i].length >= 0)
                            message.terms[i] = object.terms[i];
                }
                return message;
            };

            /**
             * Creates a plain object from an InclusionProof message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.InclusionProof
             * @static
             * @param {immudb.schema.InclusionProof} message InclusionProof
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            InclusionProof.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.terms = [];
                if (options.defaults) {
                    object.leaf = 0;
                    object.width = 0;
                }
                if (message.leaf != null && message.hasOwnProperty("leaf"))
                    object.leaf = message.leaf;
                if (message.width != null && message.hasOwnProperty("width"))
                    object.width = message.width;
                if (message.terms && message.terms.length) {
                    object.terms = [];
                    for (let j = 0; j < message.terms.length; ++j)
                        object.terms[j] = options.bytes === String ? $util.base64.encode(message.terms[j], 0, message.terms[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.terms[j]) : message.terms[j];
                }
                return object;
            };

            /**
             * Converts this InclusionProof to JSON.
             * @function toJSON
             * @memberof immudb.schema.InclusionProof
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            InclusionProof.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for InclusionProof
             * @function getTypeUrl
             * @memberof immudb.schema.InclusionProof
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            InclusionProof.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.InclusionProof";
            };

            return InclusionProof;
        })();

        schema.SetRequest = (function() {

            /**
             * Properties of a SetRequest.
             * @memberof immudb.schema
             * @interface ISetRequest
             * @property {Array.<immudb.schema.IKeyValue>|null} [KVs] SetRequest KVs
             * @property {boolean|null} [noWait] SetRequest noWait
             * @property {Array.<immudb.schema.IPrecondition>|null} [preconditions] SetRequest preconditions
             */

            /**
             * Constructs a new SetRequest.
             * @memberof immudb.schema
             * @classdesc Represents a SetRequest.
             * @implements ISetRequest
             * @constructor
             * @param {immudb.schema.ISetRequest=} [properties] Properties to set
             */
            function SetRequest(properties) {
                this.KVs = [];
                this.preconditions = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetRequest KVs.
             * @member {Array.<immudb.schema.IKeyValue>} KVs
             * @memberof immudb.schema.SetRequest
             * @instance
             */
            SetRequest.prototype.KVs = $util.emptyArray;

            /**
             * SetRequest noWait.
             * @member {boolean} noWait
             * @memberof immudb.schema.SetRequest
             * @instance
             */
            SetRequest.prototype.noWait = false;

            /**
             * SetRequest preconditions.
             * @member {Array.<immudb.schema.IPrecondition>} preconditions
             * @memberof immudb.schema.SetRequest
             * @instance
             */
            SetRequest.prototype.preconditions = $util.emptyArray;

            /**
             * Creates a new SetRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.SetRequest
             * @static
             * @param {immudb.schema.ISetRequest=} [properties] Properties to set
             * @returns {immudb.schema.SetRequest} SetRequest instance
             */
            SetRequest.create = function create(properties) {
                return new SetRequest(properties);
            };

            /**
             * Encodes the specified SetRequest message. Does not implicitly {@link immudb.schema.SetRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.SetRequest
             * @static
             * @param {immudb.schema.ISetRequest} message SetRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.KVs != null && message.KVs.length)
                    for (let i = 0; i < message.KVs.length; ++i)
                        $root.immudb.schema.KeyValue.encode(message.KVs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.noWait != null && Object.hasOwnProperty.call(message, "noWait"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.noWait);
                if (message.preconditions != null && message.preconditions.length)
                    for (let i = 0; i < message.preconditions.length; ++i)
                        $root.immudb.schema.Precondition.encode(message.preconditions[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SetRequest message, length delimited. Does not implicitly {@link immudb.schema.SetRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.SetRequest
             * @static
             * @param {immudb.schema.ISetRequest} message SetRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.SetRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.SetRequest} SetRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.SetRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.KVs && message.KVs.length))
                                message.KVs = [];
                            message.KVs.push($root.immudb.schema.KeyValue.decode(reader, reader.uint32()));
                            break;
                        }
                    case 2: {
                            message.noWait = reader.bool();
                            break;
                        }
                    case 3: {
                            if (!(message.preconditions && message.preconditions.length))
                                message.preconditions = [];
                            message.preconditions.push($root.immudb.schema.Precondition.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.SetRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.SetRequest} SetRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetRequest message.
             * @function verify
             * @memberof immudb.schema.SetRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.KVs != null && message.hasOwnProperty("KVs")) {
                    if (!Array.isArray(message.KVs))
                        return "KVs: array expected";
                    for (let i = 0; i < message.KVs.length; ++i) {
                        let error = $root.immudb.schema.KeyValue.verify(message.KVs[i]);
                        if (error)
                            return "KVs." + error;
                    }
                }
                if (message.noWait != null && message.hasOwnProperty("noWait"))
                    if (typeof message.noWait !== "boolean")
                        return "noWait: boolean expected";
                if (message.preconditions != null && message.hasOwnProperty("preconditions")) {
                    if (!Array.isArray(message.preconditions))
                        return "preconditions: array expected";
                    for (let i = 0; i < message.preconditions.length; ++i) {
                        let error = $root.immudb.schema.Precondition.verify(message.preconditions[i]);
                        if (error)
                            return "preconditions." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a SetRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.SetRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.SetRequest} SetRequest
             */
            SetRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.SetRequest)
                    return object;
                let message = new $root.immudb.schema.SetRequest();
                if (object.KVs) {
                    if (!Array.isArray(object.KVs))
                        throw TypeError(".immudb.schema.SetRequest.KVs: array expected");
                    message.KVs = [];
                    for (let i = 0; i < object.KVs.length; ++i) {
                        if (typeof object.KVs[i] !== "object")
                            throw TypeError(".immudb.schema.SetRequest.KVs: object expected");
                        message.KVs[i] = $root.immudb.schema.KeyValue.fromObject(object.KVs[i]);
                    }
                }
                if (object.noWait != null)
                    message.noWait = Boolean(object.noWait);
                if (object.preconditions) {
                    if (!Array.isArray(object.preconditions))
                        throw TypeError(".immudb.schema.SetRequest.preconditions: array expected");
                    message.preconditions = [];
                    for (let i = 0; i < object.preconditions.length; ++i) {
                        if (typeof object.preconditions[i] !== "object")
                            throw TypeError(".immudb.schema.SetRequest.preconditions: object expected");
                        message.preconditions[i] = $root.immudb.schema.Precondition.fromObject(object.preconditions[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a SetRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.SetRequest
             * @static
             * @param {immudb.schema.SetRequest} message SetRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.KVs = [];
                    object.preconditions = [];
                }
                if (options.defaults)
                    object.noWait = false;
                if (message.KVs && message.KVs.length) {
                    object.KVs = [];
                    for (let j = 0; j < message.KVs.length; ++j)
                        object.KVs[j] = $root.immudb.schema.KeyValue.toObject(message.KVs[j], options);
                }
                if (message.noWait != null && message.hasOwnProperty("noWait"))
                    object.noWait = message.noWait;
                if (message.preconditions && message.preconditions.length) {
                    object.preconditions = [];
                    for (let j = 0; j < message.preconditions.length; ++j)
                        object.preconditions[j] = $root.immudb.schema.Precondition.toObject(message.preconditions[j], options);
                }
                return object;
            };

            /**
             * Converts this SetRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.SetRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetRequest
             * @function getTypeUrl
             * @memberof immudb.schema.SetRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.SetRequest";
            };

            return SetRequest;
        })();

        schema.KeyRequest = (function() {

            /**
             * Properties of a KeyRequest.
             * @memberof immudb.schema
             * @interface IKeyRequest
             * @property {Uint8Array|null} [key] KeyRequest key
             * @property {Long|null} [atTx] KeyRequest atTx
             * @property {Long|null} [sinceTx] KeyRequest sinceTx
             * @property {boolean|null} [noWait] KeyRequest noWait
             * @property {Long|null} [atRevision] KeyRequest atRevision
             */

            /**
             * Constructs a new KeyRequest.
             * @memberof immudb.schema
             * @classdesc Represents a KeyRequest.
             * @implements IKeyRequest
             * @constructor
             * @param {immudb.schema.IKeyRequest=} [properties] Properties to set
             */
            function KeyRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KeyRequest key.
             * @member {Uint8Array} key
             * @memberof immudb.schema.KeyRequest
             * @instance
             */
            KeyRequest.prototype.key = $util.newBuffer([]);

            /**
             * KeyRequest atTx.
             * @member {Long} atTx
             * @memberof immudb.schema.KeyRequest
             * @instance
             */
            KeyRequest.prototype.atTx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * KeyRequest sinceTx.
             * @member {Long} sinceTx
             * @memberof immudb.schema.KeyRequest
             * @instance
             */
            KeyRequest.prototype.sinceTx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * KeyRequest noWait.
             * @member {boolean} noWait
             * @memberof immudb.schema.KeyRequest
             * @instance
             */
            KeyRequest.prototype.noWait = false;

            /**
             * KeyRequest atRevision.
             * @member {Long} atRevision
             * @memberof immudb.schema.KeyRequest
             * @instance
             */
            KeyRequest.prototype.atRevision = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new KeyRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.KeyRequest
             * @static
             * @param {immudb.schema.IKeyRequest=} [properties] Properties to set
             * @returns {immudb.schema.KeyRequest} KeyRequest instance
             */
            KeyRequest.create = function create(properties) {
                return new KeyRequest(properties);
            };

            /**
             * Encodes the specified KeyRequest message. Does not implicitly {@link immudb.schema.KeyRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.KeyRequest
             * @static
             * @param {immudb.schema.IKeyRequest} message KeyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
                if (message.atTx != null && Object.hasOwnProperty.call(message, "atTx"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.atTx);
                if (message.sinceTx != null && Object.hasOwnProperty.call(message, "sinceTx"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.sinceTx);
                if (message.noWait != null && Object.hasOwnProperty.call(message, "noWait"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.noWait);
                if (message.atRevision != null && Object.hasOwnProperty.call(message, "atRevision"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.atRevision);
                return writer;
            };

            /**
             * Encodes the specified KeyRequest message, length delimited. Does not implicitly {@link immudb.schema.KeyRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.KeyRequest
             * @static
             * @param {immudb.schema.IKeyRequest} message KeyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KeyRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.KeyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.KeyRequest} KeyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.KeyRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.key = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.atTx = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.sinceTx = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.noWait = reader.bool();
                            break;
                        }
                    case 5: {
                            message.atRevision = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KeyRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.KeyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.KeyRequest} KeyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KeyRequest message.
             * @function verify
             * @memberof immudb.schema.KeyRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KeyRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                        return "key: buffer expected";
                if (message.atTx != null && message.hasOwnProperty("atTx"))
                    if (!$util.isInteger(message.atTx) && !(message.atTx && $util.isInteger(message.atTx.low) && $util.isInteger(message.atTx.high)))
                        return "atTx: integer|Long expected";
                if (message.sinceTx != null && message.hasOwnProperty("sinceTx"))
                    if (!$util.isInteger(message.sinceTx) && !(message.sinceTx && $util.isInteger(message.sinceTx.low) && $util.isInteger(message.sinceTx.high)))
                        return "sinceTx: integer|Long expected";
                if (message.noWait != null && message.hasOwnProperty("noWait"))
                    if (typeof message.noWait !== "boolean")
                        return "noWait: boolean expected";
                if (message.atRevision != null && message.hasOwnProperty("atRevision"))
                    if (!$util.isInteger(message.atRevision) && !(message.atRevision && $util.isInteger(message.atRevision.low) && $util.isInteger(message.atRevision.high)))
                        return "atRevision: integer|Long expected";
                return null;
            };

            /**
             * Creates a KeyRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.KeyRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.KeyRequest} KeyRequest
             */
            KeyRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.KeyRequest)
                    return object;
                let message = new $root.immudb.schema.KeyRequest();
                if (object.key != null)
                    if (typeof object.key === "string")
                        $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                    else if (object.key.length >= 0)
                        message.key = object.key;
                if (object.atTx != null)
                    if ($util.Long)
                        (message.atTx = $util.Long.fromValue(object.atTx)).unsigned = true;
                    else if (typeof object.atTx === "string")
                        message.atTx = parseInt(object.atTx, 10);
                    else if (typeof object.atTx === "number")
                        message.atTx = object.atTx;
                    else if (typeof object.atTx === "object")
                        message.atTx = new $util.LongBits(object.atTx.low >>> 0, object.atTx.high >>> 0).toNumber(true);
                if (object.sinceTx != null)
                    if ($util.Long)
                        (message.sinceTx = $util.Long.fromValue(object.sinceTx)).unsigned = true;
                    else if (typeof object.sinceTx === "string")
                        message.sinceTx = parseInt(object.sinceTx, 10);
                    else if (typeof object.sinceTx === "number")
                        message.sinceTx = object.sinceTx;
                    else if (typeof object.sinceTx === "object")
                        message.sinceTx = new $util.LongBits(object.sinceTx.low >>> 0, object.sinceTx.high >>> 0).toNumber(true);
                if (object.noWait != null)
                    message.noWait = Boolean(object.noWait);
                if (object.atRevision != null)
                    if ($util.Long)
                        (message.atRevision = $util.Long.fromValue(object.atRevision)).unsigned = false;
                    else if (typeof object.atRevision === "string")
                        message.atRevision = parseInt(object.atRevision, 10);
                    else if (typeof object.atRevision === "number")
                        message.atRevision = object.atRevision;
                    else if (typeof object.atRevision === "object")
                        message.atRevision = new $util.LongBits(object.atRevision.low >>> 0, object.atRevision.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a KeyRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.KeyRequest
             * @static
             * @param {immudb.schema.KeyRequest} message KeyRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KeyRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.key = "";
                    else {
                        object.key = [];
                        if (options.bytes !== Array)
                            object.key = $util.newBuffer(object.key);
                    }
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.atTx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.atTx = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.sinceTx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sinceTx = options.longs === String ? "0" : 0;
                    object.noWait = false;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.atRevision = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.atRevision = options.longs === String ? "0" : 0;
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                if (message.atTx != null && message.hasOwnProperty("atTx"))
                    if (typeof message.atTx === "number")
                        object.atTx = options.longs === String ? String(message.atTx) : message.atTx;
                    else
                        object.atTx = options.longs === String ? $util.Long.prototype.toString.call(message.atTx) : options.longs === Number ? new $util.LongBits(message.atTx.low >>> 0, message.atTx.high >>> 0).toNumber(true) : message.atTx;
                if (message.sinceTx != null && message.hasOwnProperty("sinceTx"))
                    if (typeof message.sinceTx === "number")
                        object.sinceTx = options.longs === String ? String(message.sinceTx) : message.sinceTx;
                    else
                        object.sinceTx = options.longs === String ? $util.Long.prototype.toString.call(message.sinceTx) : options.longs === Number ? new $util.LongBits(message.sinceTx.low >>> 0, message.sinceTx.high >>> 0).toNumber(true) : message.sinceTx;
                if (message.noWait != null && message.hasOwnProperty("noWait"))
                    object.noWait = message.noWait;
                if (message.atRevision != null && message.hasOwnProperty("atRevision"))
                    if (typeof message.atRevision === "number")
                        object.atRevision = options.longs === String ? String(message.atRevision) : message.atRevision;
                    else
                        object.atRevision = options.longs === String ? $util.Long.prototype.toString.call(message.atRevision) : options.longs === Number ? new $util.LongBits(message.atRevision.low >>> 0, message.atRevision.high >>> 0).toNumber() : message.atRevision;
                return object;
            };

            /**
             * Converts this KeyRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.KeyRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KeyRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for KeyRequest
             * @function getTypeUrl
             * @memberof immudb.schema.KeyRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            KeyRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.KeyRequest";
            };

            return KeyRequest;
        })();

        schema.KeyListRequest = (function() {

            /**
             * Properties of a KeyListRequest.
             * @memberof immudb.schema
             * @interface IKeyListRequest
             * @property {Array.<Uint8Array>|null} [keys] KeyListRequest keys
             * @property {Long|null} [sinceTx] KeyListRequest sinceTx
             */

            /**
             * Constructs a new KeyListRequest.
             * @memberof immudb.schema
             * @classdesc Represents a KeyListRequest.
             * @implements IKeyListRequest
             * @constructor
             * @param {immudb.schema.IKeyListRequest=} [properties] Properties to set
             */
            function KeyListRequest(properties) {
                this.keys = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KeyListRequest keys.
             * @member {Array.<Uint8Array>} keys
             * @memberof immudb.schema.KeyListRequest
             * @instance
             */
            KeyListRequest.prototype.keys = $util.emptyArray;

            /**
             * KeyListRequest sinceTx.
             * @member {Long} sinceTx
             * @memberof immudb.schema.KeyListRequest
             * @instance
             */
            KeyListRequest.prototype.sinceTx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new KeyListRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.KeyListRequest
             * @static
             * @param {immudb.schema.IKeyListRequest=} [properties] Properties to set
             * @returns {immudb.schema.KeyListRequest} KeyListRequest instance
             */
            KeyListRequest.create = function create(properties) {
                return new KeyListRequest(properties);
            };

            /**
             * Encodes the specified KeyListRequest message. Does not implicitly {@link immudb.schema.KeyListRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.KeyListRequest
             * @static
             * @param {immudb.schema.IKeyListRequest} message KeyListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.keys != null && message.keys.length)
                    for (let i = 0; i < message.keys.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.keys[i]);
                if (message.sinceTx != null && Object.hasOwnProperty.call(message, "sinceTx"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.sinceTx);
                return writer;
            };

            /**
             * Encodes the specified KeyListRequest message, length delimited. Does not implicitly {@link immudb.schema.KeyListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.KeyListRequest
             * @static
             * @param {immudb.schema.IKeyListRequest} message KeyListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KeyListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.KeyListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.KeyListRequest} KeyListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.KeyListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.keys && message.keys.length))
                                message.keys = [];
                            message.keys.push(reader.bytes());
                            break;
                        }
                    case 2: {
                            message.sinceTx = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KeyListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.KeyListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.KeyListRequest} KeyListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KeyListRequest message.
             * @function verify
             * @memberof immudb.schema.KeyListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KeyListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.keys != null && message.hasOwnProperty("keys")) {
                    if (!Array.isArray(message.keys))
                        return "keys: array expected";
                    for (let i = 0; i < message.keys.length; ++i)
                        if (!(message.keys[i] && typeof message.keys[i].length === "number" || $util.isString(message.keys[i])))
                            return "keys: buffer[] expected";
                }
                if (message.sinceTx != null && message.hasOwnProperty("sinceTx"))
                    if (!$util.isInteger(message.sinceTx) && !(message.sinceTx && $util.isInteger(message.sinceTx.low) && $util.isInteger(message.sinceTx.high)))
                        return "sinceTx: integer|Long expected";
                return null;
            };

            /**
             * Creates a KeyListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.KeyListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.KeyListRequest} KeyListRequest
             */
            KeyListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.KeyListRequest)
                    return object;
                let message = new $root.immudb.schema.KeyListRequest();
                if (object.keys) {
                    if (!Array.isArray(object.keys))
                        throw TypeError(".immudb.schema.KeyListRequest.keys: array expected");
                    message.keys = [];
                    for (let i = 0; i < object.keys.length; ++i)
                        if (typeof object.keys[i] === "string")
                            $util.base64.decode(object.keys[i], message.keys[i] = $util.newBuffer($util.base64.length(object.keys[i])), 0);
                        else if (object.keys[i].length >= 0)
                            message.keys[i] = object.keys[i];
                }
                if (object.sinceTx != null)
                    if ($util.Long)
                        (message.sinceTx = $util.Long.fromValue(object.sinceTx)).unsigned = true;
                    else if (typeof object.sinceTx === "string")
                        message.sinceTx = parseInt(object.sinceTx, 10);
                    else if (typeof object.sinceTx === "number")
                        message.sinceTx = object.sinceTx;
                    else if (typeof object.sinceTx === "object")
                        message.sinceTx = new $util.LongBits(object.sinceTx.low >>> 0, object.sinceTx.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a KeyListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.KeyListRequest
             * @static
             * @param {immudb.schema.KeyListRequest} message KeyListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KeyListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.keys = [];
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.sinceTx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sinceTx = options.longs === String ? "0" : 0;
                if (message.keys && message.keys.length) {
                    object.keys = [];
                    for (let j = 0; j < message.keys.length; ++j)
                        object.keys[j] = options.bytes === String ? $util.base64.encode(message.keys[j], 0, message.keys[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.keys[j]) : message.keys[j];
                }
                if (message.sinceTx != null && message.hasOwnProperty("sinceTx"))
                    if (typeof message.sinceTx === "number")
                        object.sinceTx = options.longs === String ? String(message.sinceTx) : message.sinceTx;
                    else
                        object.sinceTx = options.longs === String ? $util.Long.prototype.toString.call(message.sinceTx) : options.longs === Number ? new $util.LongBits(message.sinceTx.low >>> 0, message.sinceTx.high >>> 0).toNumber(true) : message.sinceTx;
                return object;
            };

            /**
             * Converts this KeyListRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.KeyListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KeyListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for KeyListRequest
             * @function getTypeUrl
             * @memberof immudb.schema.KeyListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            KeyListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.KeyListRequest";
            };

            return KeyListRequest;
        })();

        schema.DeleteKeysRequest = (function() {

            /**
             * Properties of a DeleteKeysRequest.
             * @memberof immudb.schema
             * @interface IDeleteKeysRequest
             * @property {Array.<Uint8Array>|null} [keys] DeleteKeysRequest keys
             * @property {Long|null} [sinceTx] DeleteKeysRequest sinceTx
             * @property {boolean|null} [noWait] DeleteKeysRequest noWait
             */

            /**
             * Constructs a new DeleteKeysRequest.
             * @memberof immudb.schema
             * @classdesc Represents a DeleteKeysRequest.
             * @implements IDeleteKeysRequest
             * @constructor
             * @param {immudb.schema.IDeleteKeysRequest=} [properties] Properties to set
             */
            function DeleteKeysRequest(properties) {
                this.keys = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteKeysRequest keys.
             * @member {Array.<Uint8Array>} keys
             * @memberof immudb.schema.DeleteKeysRequest
             * @instance
             */
            DeleteKeysRequest.prototype.keys = $util.emptyArray;

            /**
             * DeleteKeysRequest sinceTx.
             * @member {Long} sinceTx
             * @memberof immudb.schema.DeleteKeysRequest
             * @instance
             */
            DeleteKeysRequest.prototype.sinceTx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * DeleteKeysRequest noWait.
             * @member {boolean} noWait
             * @memberof immudb.schema.DeleteKeysRequest
             * @instance
             */
            DeleteKeysRequest.prototype.noWait = false;

            /**
             * Creates a new DeleteKeysRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.DeleteKeysRequest
             * @static
             * @param {immudb.schema.IDeleteKeysRequest=} [properties] Properties to set
             * @returns {immudb.schema.DeleteKeysRequest} DeleteKeysRequest instance
             */
            DeleteKeysRequest.create = function create(properties) {
                return new DeleteKeysRequest(properties);
            };

            /**
             * Encodes the specified DeleteKeysRequest message. Does not implicitly {@link immudb.schema.DeleteKeysRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.DeleteKeysRequest
             * @static
             * @param {immudb.schema.IDeleteKeysRequest} message DeleteKeysRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteKeysRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.keys != null && message.keys.length)
                    for (let i = 0; i < message.keys.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.keys[i]);
                if (message.sinceTx != null && Object.hasOwnProperty.call(message, "sinceTx"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.sinceTx);
                if (message.noWait != null && Object.hasOwnProperty.call(message, "noWait"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.noWait);
                return writer;
            };

            /**
             * Encodes the specified DeleteKeysRequest message, length delimited. Does not implicitly {@link immudb.schema.DeleteKeysRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.DeleteKeysRequest
             * @static
             * @param {immudb.schema.IDeleteKeysRequest} message DeleteKeysRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteKeysRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteKeysRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.DeleteKeysRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.DeleteKeysRequest} DeleteKeysRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteKeysRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.DeleteKeysRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.keys && message.keys.length))
                                message.keys = [];
                            message.keys.push(reader.bytes());
                            break;
                        }
                    case 2: {
                            message.sinceTx = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.noWait = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteKeysRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.DeleteKeysRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.DeleteKeysRequest} DeleteKeysRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteKeysRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteKeysRequest message.
             * @function verify
             * @memberof immudb.schema.DeleteKeysRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteKeysRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.keys != null && message.hasOwnProperty("keys")) {
                    if (!Array.isArray(message.keys))
                        return "keys: array expected";
                    for (let i = 0; i < message.keys.length; ++i)
                        if (!(message.keys[i] && typeof message.keys[i].length === "number" || $util.isString(message.keys[i])))
                            return "keys: buffer[] expected";
                }
                if (message.sinceTx != null && message.hasOwnProperty("sinceTx"))
                    if (!$util.isInteger(message.sinceTx) && !(message.sinceTx && $util.isInteger(message.sinceTx.low) && $util.isInteger(message.sinceTx.high)))
                        return "sinceTx: integer|Long expected";
                if (message.noWait != null && message.hasOwnProperty("noWait"))
                    if (typeof message.noWait !== "boolean")
                        return "noWait: boolean expected";
                return null;
            };

            /**
             * Creates a DeleteKeysRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.DeleteKeysRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.DeleteKeysRequest} DeleteKeysRequest
             */
            DeleteKeysRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.DeleteKeysRequest)
                    return object;
                let message = new $root.immudb.schema.DeleteKeysRequest();
                if (object.keys) {
                    if (!Array.isArray(object.keys))
                        throw TypeError(".immudb.schema.DeleteKeysRequest.keys: array expected");
                    message.keys = [];
                    for (let i = 0; i < object.keys.length; ++i)
                        if (typeof object.keys[i] === "string")
                            $util.base64.decode(object.keys[i], message.keys[i] = $util.newBuffer($util.base64.length(object.keys[i])), 0);
                        else if (object.keys[i].length >= 0)
                            message.keys[i] = object.keys[i];
                }
                if (object.sinceTx != null)
                    if ($util.Long)
                        (message.sinceTx = $util.Long.fromValue(object.sinceTx)).unsigned = true;
                    else if (typeof object.sinceTx === "string")
                        message.sinceTx = parseInt(object.sinceTx, 10);
                    else if (typeof object.sinceTx === "number")
                        message.sinceTx = object.sinceTx;
                    else if (typeof object.sinceTx === "object")
                        message.sinceTx = new $util.LongBits(object.sinceTx.low >>> 0, object.sinceTx.high >>> 0).toNumber(true);
                if (object.noWait != null)
                    message.noWait = Boolean(object.noWait);
                return message;
            };

            /**
             * Creates a plain object from a DeleteKeysRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.DeleteKeysRequest
             * @static
             * @param {immudb.schema.DeleteKeysRequest} message DeleteKeysRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteKeysRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.keys = [];
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.sinceTx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sinceTx = options.longs === String ? "0" : 0;
                    object.noWait = false;
                }
                if (message.keys && message.keys.length) {
                    object.keys = [];
                    for (let j = 0; j < message.keys.length; ++j)
                        object.keys[j] = options.bytes === String ? $util.base64.encode(message.keys[j], 0, message.keys[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.keys[j]) : message.keys[j];
                }
                if (message.sinceTx != null && message.hasOwnProperty("sinceTx"))
                    if (typeof message.sinceTx === "number")
                        object.sinceTx = options.longs === String ? String(message.sinceTx) : message.sinceTx;
                    else
                        object.sinceTx = options.longs === String ? $util.Long.prototype.toString.call(message.sinceTx) : options.longs === Number ? new $util.LongBits(message.sinceTx.low >>> 0, message.sinceTx.high >>> 0).toNumber(true) : message.sinceTx;
                if (message.noWait != null && message.hasOwnProperty("noWait"))
                    object.noWait = message.noWait;
                return object;
            };

            /**
             * Converts this DeleteKeysRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.DeleteKeysRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteKeysRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteKeysRequest
             * @function getTypeUrl
             * @memberof immudb.schema.DeleteKeysRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteKeysRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.DeleteKeysRequest";
            };

            return DeleteKeysRequest;
        })();

        schema.VerifiableSetRequest = (function() {

            /**
             * Properties of a VerifiableSetRequest.
             * @memberof immudb.schema
             * @interface IVerifiableSetRequest
             * @property {immudb.schema.ISetRequest|null} [setRequest] VerifiableSetRequest setRequest
             * @property {Long|null} [proveSinceTx] VerifiableSetRequest proveSinceTx
             */

            /**
             * Constructs a new VerifiableSetRequest.
             * @memberof immudb.schema
             * @classdesc Represents a VerifiableSetRequest.
             * @implements IVerifiableSetRequest
             * @constructor
             * @param {immudb.schema.IVerifiableSetRequest=} [properties] Properties to set
             */
            function VerifiableSetRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VerifiableSetRequest setRequest.
             * @member {immudb.schema.ISetRequest|null|undefined} setRequest
             * @memberof immudb.schema.VerifiableSetRequest
             * @instance
             */
            VerifiableSetRequest.prototype.setRequest = null;

            /**
             * VerifiableSetRequest proveSinceTx.
             * @member {Long} proveSinceTx
             * @memberof immudb.schema.VerifiableSetRequest
             * @instance
             */
            VerifiableSetRequest.prototype.proveSinceTx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new VerifiableSetRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.VerifiableSetRequest
             * @static
             * @param {immudb.schema.IVerifiableSetRequest=} [properties] Properties to set
             * @returns {immudb.schema.VerifiableSetRequest} VerifiableSetRequest instance
             */
            VerifiableSetRequest.create = function create(properties) {
                return new VerifiableSetRequest(properties);
            };

            /**
             * Encodes the specified VerifiableSetRequest message. Does not implicitly {@link immudb.schema.VerifiableSetRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.VerifiableSetRequest
             * @static
             * @param {immudb.schema.IVerifiableSetRequest} message VerifiableSetRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VerifiableSetRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.setRequest != null && Object.hasOwnProperty.call(message, "setRequest"))
                    $root.immudb.schema.SetRequest.encode(message.setRequest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.proveSinceTx != null && Object.hasOwnProperty.call(message, "proveSinceTx"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.proveSinceTx);
                return writer;
            };

            /**
             * Encodes the specified VerifiableSetRequest message, length delimited. Does not implicitly {@link immudb.schema.VerifiableSetRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.VerifiableSetRequest
             * @static
             * @param {immudb.schema.IVerifiableSetRequest} message VerifiableSetRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VerifiableSetRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VerifiableSetRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.VerifiableSetRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.VerifiableSetRequest} VerifiableSetRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VerifiableSetRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.VerifiableSetRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.setRequest = $root.immudb.schema.SetRequest.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.proveSinceTx = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VerifiableSetRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.VerifiableSetRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.VerifiableSetRequest} VerifiableSetRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VerifiableSetRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VerifiableSetRequest message.
             * @function verify
             * @memberof immudb.schema.VerifiableSetRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VerifiableSetRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.setRequest != null && message.hasOwnProperty("setRequest")) {
                    let error = $root.immudb.schema.SetRequest.verify(message.setRequest);
                    if (error)
                        return "setRequest." + error;
                }
                if (message.proveSinceTx != null && message.hasOwnProperty("proveSinceTx"))
                    if (!$util.isInteger(message.proveSinceTx) && !(message.proveSinceTx && $util.isInteger(message.proveSinceTx.low) && $util.isInteger(message.proveSinceTx.high)))
                        return "proveSinceTx: integer|Long expected";
                return null;
            };

            /**
             * Creates a VerifiableSetRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.VerifiableSetRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.VerifiableSetRequest} VerifiableSetRequest
             */
            VerifiableSetRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.VerifiableSetRequest)
                    return object;
                let message = new $root.immudb.schema.VerifiableSetRequest();
                if (object.setRequest != null) {
                    if (typeof object.setRequest !== "object")
                        throw TypeError(".immudb.schema.VerifiableSetRequest.setRequest: object expected");
                    message.setRequest = $root.immudb.schema.SetRequest.fromObject(object.setRequest);
                }
                if (object.proveSinceTx != null)
                    if ($util.Long)
                        (message.proveSinceTx = $util.Long.fromValue(object.proveSinceTx)).unsigned = true;
                    else if (typeof object.proveSinceTx === "string")
                        message.proveSinceTx = parseInt(object.proveSinceTx, 10);
                    else if (typeof object.proveSinceTx === "number")
                        message.proveSinceTx = object.proveSinceTx;
                    else if (typeof object.proveSinceTx === "object")
                        message.proveSinceTx = new $util.LongBits(object.proveSinceTx.low >>> 0, object.proveSinceTx.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a VerifiableSetRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.VerifiableSetRequest
             * @static
             * @param {immudb.schema.VerifiableSetRequest} message VerifiableSetRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VerifiableSetRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.setRequest = null;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.proveSinceTx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.proveSinceTx = options.longs === String ? "0" : 0;
                }
                if (message.setRequest != null && message.hasOwnProperty("setRequest"))
                    object.setRequest = $root.immudb.schema.SetRequest.toObject(message.setRequest, options);
                if (message.proveSinceTx != null && message.hasOwnProperty("proveSinceTx"))
                    if (typeof message.proveSinceTx === "number")
                        object.proveSinceTx = options.longs === String ? String(message.proveSinceTx) : message.proveSinceTx;
                    else
                        object.proveSinceTx = options.longs === String ? $util.Long.prototype.toString.call(message.proveSinceTx) : options.longs === Number ? new $util.LongBits(message.proveSinceTx.low >>> 0, message.proveSinceTx.high >>> 0).toNumber(true) : message.proveSinceTx;
                return object;
            };

            /**
             * Converts this VerifiableSetRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.VerifiableSetRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VerifiableSetRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for VerifiableSetRequest
             * @function getTypeUrl
             * @memberof immudb.schema.VerifiableSetRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            VerifiableSetRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.VerifiableSetRequest";
            };

            return VerifiableSetRequest;
        })();

        schema.VerifiableGetRequest = (function() {

            /**
             * Properties of a VerifiableGetRequest.
             * @memberof immudb.schema
             * @interface IVerifiableGetRequest
             * @property {immudb.schema.IKeyRequest|null} [keyRequest] VerifiableGetRequest keyRequest
             * @property {Long|null} [proveSinceTx] VerifiableGetRequest proveSinceTx
             */

            /**
             * Constructs a new VerifiableGetRequest.
             * @memberof immudb.schema
             * @classdesc Represents a VerifiableGetRequest.
             * @implements IVerifiableGetRequest
             * @constructor
             * @param {immudb.schema.IVerifiableGetRequest=} [properties] Properties to set
             */
            function VerifiableGetRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VerifiableGetRequest keyRequest.
             * @member {immudb.schema.IKeyRequest|null|undefined} keyRequest
             * @memberof immudb.schema.VerifiableGetRequest
             * @instance
             */
            VerifiableGetRequest.prototype.keyRequest = null;

            /**
             * VerifiableGetRequest proveSinceTx.
             * @member {Long} proveSinceTx
             * @memberof immudb.schema.VerifiableGetRequest
             * @instance
             */
            VerifiableGetRequest.prototype.proveSinceTx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new VerifiableGetRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.VerifiableGetRequest
             * @static
             * @param {immudb.schema.IVerifiableGetRequest=} [properties] Properties to set
             * @returns {immudb.schema.VerifiableGetRequest} VerifiableGetRequest instance
             */
            VerifiableGetRequest.create = function create(properties) {
                return new VerifiableGetRequest(properties);
            };

            /**
             * Encodes the specified VerifiableGetRequest message. Does not implicitly {@link immudb.schema.VerifiableGetRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.VerifiableGetRequest
             * @static
             * @param {immudb.schema.IVerifiableGetRequest} message VerifiableGetRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VerifiableGetRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.keyRequest != null && Object.hasOwnProperty.call(message, "keyRequest"))
                    $root.immudb.schema.KeyRequest.encode(message.keyRequest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.proveSinceTx != null && Object.hasOwnProperty.call(message, "proveSinceTx"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.proveSinceTx);
                return writer;
            };

            /**
             * Encodes the specified VerifiableGetRequest message, length delimited. Does not implicitly {@link immudb.schema.VerifiableGetRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.VerifiableGetRequest
             * @static
             * @param {immudb.schema.IVerifiableGetRequest} message VerifiableGetRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VerifiableGetRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VerifiableGetRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.VerifiableGetRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.VerifiableGetRequest} VerifiableGetRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VerifiableGetRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.VerifiableGetRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.keyRequest = $root.immudb.schema.KeyRequest.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.proveSinceTx = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VerifiableGetRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.VerifiableGetRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.VerifiableGetRequest} VerifiableGetRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VerifiableGetRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VerifiableGetRequest message.
             * @function verify
             * @memberof immudb.schema.VerifiableGetRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VerifiableGetRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.keyRequest != null && message.hasOwnProperty("keyRequest")) {
                    let error = $root.immudb.schema.KeyRequest.verify(message.keyRequest);
                    if (error)
                        return "keyRequest." + error;
                }
                if (message.proveSinceTx != null && message.hasOwnProperty("proveSinceTx"))
                    if (!$util.isInteger(message.proveSinceTx) && !(message.proveSinceTx && $util.isInteger(message.proveSinceTx.low) && $util.isInteger(message.proveSinceTx.high)))
                        return "proveSinceTx: integer|Long expected";
                return null;
            };

            /**
             * Creates a VerifiableGetRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.VerifiableGetRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.VerifiableGetRequest} VerifiableGetRequest
             */
            VerifiableGetRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.VerifiableGetRequest)
                    return object;
                let message = new $root.immudb.schema.VerifiableGetRequest();
                if (object.keyRequest != null) {
                    if (typeof object.keyRequest !== "object")
                        throw TypeError(".immudb.schema.VerifiableGetRequest.keyRequest: object expected");
                    message.keyRequest = $root.immudb.schema.KeyRequest.fromObject(object.keyRequest);
                }
                if (object.proveSinceTx != null)
                    if ($util.Long)
                        (message.proveSinceTx = $util.Long.fromValue(object.proveSinceTx)).unsigned = true;
                    else if (typeof object.proveSinceTx === "string")
                        message.proveSinceTx = parseInt(object.proveSinceTx, 10);
                    else if (typeof object.proveSinceTx === "number")
                        message.proveSinceTx = object.proveSinceTx;
                    else if (typeof object.proveSinceTx === "object")
                        message.proveSinceTx = new $util.LongBits(object.proveSinceTx.low >>> 0, object.proveSinceTx.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a VerifiableGetRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.VerifiableGetRequest
             * @static
             * @param {immudb.schema.VerifiableGetRequest} message VerifiableGetRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VerifiableGetRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.keyRequest = null;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.proveSinceTx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.proveSinceTx = options.longs === String ? "0" : 0;
                }
                if (message.keyRequest != null && message.hasOwnProperty("keyRequest"))
                    object.keyRequest = $root.immudb.schema.KeyRequest.toObject(message.keyRequest, options);
                if (message.proveSinceTx != null && message.hasOwnProperty("proveSinceTx"))
                    if (typeof message.proveSinceTx === "number")
                        object.proveSinceTx = options.longs === String ? String(message.proveSinceTx) : message.proveSinceTx;
                    else
                        object.proveSinceTx = options.longs === String ? $util.Long.prototype.toString.call(message.proveSinceTx) : options.longs === Number ? new $util.LongBits(message.proveSinceTx.low >>> 0, message.proveSinceTx.high >>> 0).toNumber(true) : message.proveSinceTx;
                return object;
            };

            /**
             * Converts this VerifiableGetRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.VerifiableGetRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VerifiableGetRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for VerifiableGetRequest
             * @function getTypeUrl
             * @memberof immudb.schema.VerifiableGetRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            VerifiableGetRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.VerifiableGetRequest";
            };

            return VerifiableGetRequest;
        })();

        schema.HealthResponse = (function() {

            /**
             * Properties of a HealthResponse.
             * @memberof immudb.schema
             * @interface IHealthResponse
             * @property {boolean|null} [status] HealthResponse status
             * @property {string|null} [version] HealthResponse version
             */

            /**
             * Constructs a new HealthResponse.
             * @memberof immudb.schema
             * @classdesc Represents a HealthResponse.
             * @implements IHealthResponse
             * @constructor
             * @param {immudb.schema.IHealthResponse=} [properties] Properties to set
             */
            function HealthResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HealthResponse status.
             * @member {boolean} status
             * @memberof immudb.schema.HealthResponse
             * @instance
             */
            HealthResponse.prototype.status = false;

            /**
             * HealthResponse version.
             * @member {string} version
             * @memberof immudb.schema.HealthResponse
             * @instance
             */
            HealthResponse.prototype.version = "";

            /**
             * Creates a new HealthResponse instance using the specified properties.
             * @function create
             * @memberof immudb.schema.HealthResponse
             * @static
             * @param {immudb.schema.IHealthResponse=} [properties] Properties to set
             * @returns {immudb.schema.HealthResponse} HealthResponse instance
             */
            HealthResponse.create = function create(properties) {
                return new HealthResponse(properties);
            };

            /**
             * Encodes the specified HealthResponse message. Does not implicitly {@link immudb.schema.HealthResponse.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.HealthResponse
             * @static
             * @param {immudb.schema.IHealthResponse} message HealthResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HealthResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.status);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);
                return writer;
            };

            /**
             * Encodes the specified HealthResponse message, length delimited. Does not implicitly {@link immudb.schema.HealthResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.HealthResponse
             * @static
             * @param {immudb.schema.IHealthResponse} message HealthResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HealthResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HealthResponse message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.HealthResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.HealthResponse} HealthResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HealthResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.HealthResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.status = reader.bool();
                            break;
                        }
                    case 2: {
                            message.version = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HealthResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.HealthResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.HealthResponse} HealthResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HealthResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HealthResponse message.
             * @function verify
             * @memberof immudb.schema.HealthResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HealthResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    if (typeof message.status !== "boolean")
                        return "status: boolean expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                return null;
            };

            /**
             * Creates a HealthResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.HealthResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.HealthResponse} HealthResponse
             */
            HealthResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.HealthResponse)
                    return object;
                let message = new $root.immudb.schema.HealthResponse();
                if (object.status != null)
                    message.status = Boolean(object.status);
                if (object.version != null)
                    message.version = String(object.version);
                return message;
            };

            /**
             * Creates a plain object from a HealthResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.HealthResponse
             * @static
             * @param {immudb.schema.HealthResponse} message HealthResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HealthResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.status = false;
                    object.version = "";
                }
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = message.status;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                return object;
            };

            /**
             * Converts this HealthResponse to JSON.
             * @function toJSON
             * @memberof immudb.schema.HealthResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HealthResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for HealthResponse
             * @function getTypeUrl
             * @memberof immudb.schema.HealthResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            HealthResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.HealthResponse";
            };

            return HealthResponse;
        })();

        schema.DatabaseHealthResponse = (function() {

            /**
             * Properties of a DatabaseHealthResponse.
             * @memberof immudb.schema
             * @interface IDatabaseHealthResponse
             * @property {number|null} [pendingRequests] DatabaseHealthResponse pendingRequests
             * @property {Long|null} [lastRequestCompletedAt] DatabaseHealthResponse lastRequestCompletedAt
             */

            /**
             * Constructs a new DatabaseHealthResponse.
             * @memberof immudb.schema
             * @classdesc Represents a DatabaseHealthResponse.
             * @implements IDatabaseHealthResponse
             * @constructor
             * @param {immudb.schema.IDatabaseHealthResponse=} [properties] Properties to set
             */
            function DatabaseHealthResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DatabaseHealthResponse pendingRequests.
             * @member {number} pendingRequests
             * @memberof immudb.schema.DatabaseHealthResponse
             * @instance
             */
            DatabaseHealthResponse.prototype.pendingRequests = 0;

            /**
             * DatabaseHealthResponse lastRequestCompletedAt.
             * @member {Long} lastRequestCompletedAt
             * @memberof immudb.schema.DatabaseHealthResponse
             * @instance
             */
            DatabaseHealthResponse.prototype.lastRequestCompletedAt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new DatabaseHealthResponse instance using the specified properties.
             * @function create
             * @memberof immudb.schema.DatabaseHealthResponse
             * @static
             * @param {immudb.schema.IDatabaseHealthResponse=} [properties] Properties to set
             * @returns {immudb.schema.DatabaseHealthResponse} DatabaseHealthResponse instance
             */
            DatabaseHealthResponse.create = function create(properties) {
                return new DatabaseHealthResponse(properties);
            };

            /**
             * Encodes the specified DatabaseHealthResponse message. Does not implicitly {@link immudb.schema.DatabaseHealthResponse.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.DatabaseHealthResponse
             * @static
             * @param {immudb.schema.IDatabaseHealthResponse} message DatabaseHealthResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DatabaseHealthResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pendingRequests != null && Object.hasOwnProperty.call(message, "pendingRequests"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.pendingRequests);
                if (message.lastRequestCompletedAt != null && Object.hasOwnProperty.call(message, "lastRequestCompletedAt"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.lastRequestCompletedAt);
                return writer;
            };

            /**
             * Encodes the specified DatabaseHealthResponse message, length delimited. Does not implicitly {@link immudb.schema.DatabaseHealthResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.DatabaseHealthResponse
             * @static
             * @param {immudb.schema.IDatabaseHealthResponse} message DatabaseHealthResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DatabaseHealthResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DatabaseHealthResponse message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.DatabaseHealthResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.DatabaseHealthResponse} DatabaseHealthResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DatabaseHealthResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.DatabaseHealthResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.pendingRequests = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.lastRequestCompletedAt = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DatabaseHealthResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.DatabaseHealthResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.DatabaseHealthResponse} DatabaseHealthResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DatabaseHealthResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DatabaseHealthResponse message.
             * @function verify
             * @memberof immudb.schema.DatabaseHealthResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DatabaseHealthResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pendingRequests != null && message.hasOwnProperty("pendingRequests"))
                    if (!$util.isInteger(message.pendingRequests))
                        return "pendingRequests: integer expected";
                if (message.lastRequestCompletedAt != null && message.hasOwnProperty("lastRequestCompletedAt"))
                    if (!$util.isInteger(message.lastRequestCompletedAt) && !(message.lastRequestCompletedAt && $util.isInteger(message.lastRequestCompletedAt.low) && $util.isInteger(message.lastRequestCompletedAt.high)))
                        return "lastRequestCompletedAt: integer|Long expected";
                return null;
            };

            /**
             * Creates a DatabaseHealthResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.DatabaseHealthResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.DatabaseHealthResponse} DatabaseHealthResponse
             */
            DatabaseHealthResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.DatabaseHealthResponse)
                    return object;
                let message = new $root.immudb.schema.DatabaseHealthResponse();
                if (object.pendingRequests != null)
                    message.pendingRequests = object.pendingRequests >>> 0;
                if (object.lastRequestCompletedAt != null)
                    if ($util.Long)
                        (message.lastRequestCompletedAt = $util.Long.fromValue(object.lastRequestCompletedAt)).unsigned = false;
                    else if (typeof object.lastRequestCompletedAt === "string")
                        message.lastRequestCompletedAt = parseInt(object.lastRequestCompletedAt, 10);
                    else if (typeof object.lastRequestCompletedAt === "number")
                        message.lastRequestCompletedAt = object.lastRequestCompletedAt;
                    else if (typeof object.lastRequestCompletedAt === "object")
                        message.lastRequestCompletedAt = new $util.LongBits(object.lastRequestCompletedAt.low >>> 0, object.lastRequestCompletedAt.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a DatabaseHealthResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.DatabaseHealthResponse
             * @static
             * @param {immudb.schema.DatabaseHealthResponse} message DatabaseHealthResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DatabaseHealthResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.pendingRequests = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.lastRequestCompletedAt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.lastRequestCompletedAt = options.longs === String ? "0" : 0;
                }
                if (message.pendingRequests != null && message.hasOwnProperty("pendingRequests"))
                    object.pendingRequests = message.pendingRequests;
                if (message.lastRequestCompletedAt != null && message.hasOwnProperty("lastRequestCompletedAt"))
                    if (typeof message.lastRequestCompletedAt === "number")
                        object.lastRequestCompletedAt = options.longs === String ? String(message.lastRequestCompletedAt) : message.lastRequestCompletedAt;
                    else
                        object.lastRequestCompletedAt = options.longs === String ? $util.Long.prototype.toString.call(message.lastRequestCompletedAt) : options.longs === Number ? new $util.LongBits(message.lastRequestCompletedAt.low >>> 0, message.lastRequestCompletedAt.high >>> 0).toNumber() : message.lastRequestCompletedAt;
                return object;
            };

            /**
             * Converts this DatabaseHealthResponse to JSON.
             * @function toJSON
             * @memberof immudb.schema.DatabaseHealthResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DatabaseHealthResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DatabaseHealthResponse
             * @function getTypeUrl
             * @memberof immudb.schema.DatabaseHealthResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DatabaseHealthResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.DatabaseHealthResponse";
            };

            return DatabaseHealthResponse;
        })();

        schema.ImmutableState = (function() {

            /**
             * Properties of an ImmutableState.
             * @memberof immudb.schema
             * @interface IImmutableState
             * @property {string|null} [db] ImmutableState db
             * @property {Long|null} [txId] ImmutableState txId
             * @property {Uint8Array|null} [txHash] ImmutableState txHash
             * @property {immudb.schema.ISignature|null} [signature] ImmutableState signature
             */

            /**
             * Constructs a new ImmutableState.
             * @memberof immudb.schema
             * @classdesc Represents an ImmutableState.
             * @implements IImmutableState
             * @constructor
             * @param {immudb.schema.IImmutableState=} [properties] Properties to set
             */
            function ImmutableState(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ImmutableState db.
             * @member {string} db
             * @memberof immudb.schema.ImmutableState
             * @instance
             */
            ImmutableState.prototype.db = "";

            /**
             * ImmutableState txId.
             * @member {Long} txId
             * @memberof immudb.schema.ImmutableState
             * @instance
             */
            ImmutableState.prototype.txId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ImmutableState txHash.
             * @member {Uint8Array} txHash
             * @memberof immudb.schema.ImmutableState
             * @instance
             */
            ImmutableState.prototype.txHash = $util.newBuffer([]);

            /**
             * ImmutableState signature.
             * @member {immudb.schema.ISignature|null|undefined} signature
             * @memberof immudb.schema.ImmutableState
             * @instance
             */
            ImmutableState.prototype.signature = null;

            /**
             * Creates a new ImmutableState instance using the specified properties.
             * @function create
             * @memberof immudb.schema.ImmutableState
             * @static
             * @param {immudb.schema.IImmutableState=} [properties] Properties to set
             * @returns {immudb.schema.ImmutableState} ImmutableState instance
             */
            ImmutableState.create = function create(properties) {
                return new ImmutableState(properties);
            };

            /**
             * Encodes the specified ImmutableState message. Does not implicitly {@link immudb.schema.ImmutableState.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.ImmutableState
             * @static
             * @param {immudb.schema.IImmutableState} message ImmutableState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ImmutableState.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.db != null && Object.hasOwnProperty.call(message, "db"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.db);
                if (message.txId != null && Object.hasOwnProperty.call(message, "txId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.txId);
                if (message.txHash != null && Object.hasOwnProperty.call(message, "txHash"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.txHash);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    $root.immudb.schema.Signature.encode(message.signature, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ImmutableState message, length delimited. Does not implicitly {@link immudb.schema.ImmutableState.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.ImmutableState
             * @static
             * @param {immudb.schema.IImmutableState} message ImmutableState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ImmutableState.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ImmutableState message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.ImmutableState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.ImmutableState} ImmutableState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ImmutableState.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.ImmutableState();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.db = reader.string();
                            break;
                        }
                    case 2: {
                            message.txId = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.txHash = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.signature = $root.immudb.schema.Signature.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ImmutableState message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.ImmutableState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.ImmutableState} ImmutableState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ImmutableState.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ImmutableState message.
             * @function verify
             * @memberof immudb.schema.ImmutableState
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ImmutableState.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.db != null && message.hasOwnProperty("db"))
                    if (!$util.isString(message.db))
                        return "db: string expected";
                if (message.txId != null && message.hasOwnProperty("txId"))
                    if (!$util.isInteger(message.txId) && !(message.txId && $util.isInteger(message.txId.low) && $util.isInteger(message.txId.high)))
                        return "txId: integer|Long expected";
                if (message.txHash != null && message.hasOwnProperty("txHash"))
                    if (!(message.txHash && typeof message.txHash.length === "number" || $util.isString(message.txHash)))
                        return "txHash: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature")) {
                    let error = $root.immudb.schema.Signature.verify(message.signature);
                    if (error)
                        return "signature." + error;
                }
                return null;
            };

            /**
             * Creates an ImmutableState message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.ImmutableState
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.ImmutableState} ImmutableState
             */
            ImmutableState.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.ImmutableState)
                    return object;
                let message = new $root.immudb.schema.ImmutableState();
                if (object.db != null)
                    message.db = String(object.db);
                if (object.txId != null)
                    if ($util.Long)
                        (message.txId = $util.Long.fromValue(object.txId)).unsigned = true;
                    else if (typeof object.txId === "string")
                        message.txId = parseInt(object.txId, 10);
                    else if (typeof object.txId === "number")
                        message.txId = object.txId;
                    else if (typeof object.txId === "object")
                        message.txId = new $util.LongBits(object.txId.low >>> 0, object.txId.high >>> 0).toNumber(true);
                if (object.txHash != null)
                    if (typeof object.txHash === "string")
                        $util.base64.decode(object.txHash, message.txHash = $util.newBuffer($util.base64.length(object.txHash)), 0);
                    else if (object.txHash.length >= 0)
                        message.txHash = object.txHash;
                if (object.signature != null) {
                    if (typeof object.signature !== "object")
                        throw TypeError(".immudb.schema.ImmutableState.signature: object expected");
                    message.signature = $root.immudb.schema.Signature.fromObject(object.signature);
                }
                return message;
            };

            /**
             * Creates a plain object from an ImmutableState message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.ImmutableState
             * @static
             * @param {immudb.schema.ImmutableState} message ImmutableState
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ImmutableState.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.db = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.txId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.txId = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.txHash = "";
                    else {
                        object.txHash = [];
                        if (options.bytes !== Array)
                            object.txHash = $util.newBuffer(object.txHash);
                    }
                    object.signature = null;
                }
                if (message.db != null && message.hasOwnProperty("db"))
                    object.db = message.db;
                if (message.txId != null && message.hasOwnProperty("txId"))
                    if (typeof message.txId === "number")
                        object.txId = options.longs === String ? String(message.txId) : message.txId;
                    else
                        object.txId = options.longs === String ? $util.Long.prototype.toString.call(message.txId) : options.longs === Number ? new $util.LongBits(message.txId.low >>> 0, message.txId.high >>> 0).toNumber(true) : message.txId;
                if (message.txHash != null && message.hasOwnProperty("txHash"))
                    object.txHash = options.bytes === String ? $util.base64.encode(message.txHash, 0, message.txHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.txHash) : message.txHash;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = $root.immudb.schema.Signature.toObject(message.signature, options);
                return object;
            };

            /**
             * Converts this ImmutableState to JSON.
             * @function toJSON
             * @memberof immudb.schema.ImmutableState
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ImmutableState.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ImmutableState
             * @function getTypeUrl
             * @memberof immudb.schema.ImmutableState
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ImmutableState.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.ImmutableState";
            };

            return ImmutableState;
        })();

        schema.ReferenceRequest = (function() {

            /**
             * Properties of a ReferenceRequest.
             * @memberof immudb.schema
             * @interface IReferenceRequest
             * @property {Uint8Array|null} [key] ReferenceRequest key
             * @property {Uint8Array|null} [referencedKey] ReferenceRequest referencedKey
             * @property {Long|null} [atTx] ReferenceRequest atTx
             * @property {boolean|null} [boundRef] ReferenceRequest boundRef
             * @property {boolean|null} [noWait] ReferenceRequest noWait
             * @property {Array.<immudb.schema.IPrecondition>|null} [preconditions] ReferenceRequest preconditions
             */

            /**
             * Constructs a new ReferenceRequest.
             * @memberof immudb.schema
             * @classdesc Represents a ReferenceRequest.
             * @implements IReferenceRequest
             * @constructor
             * @param {immudb.schema.IReferenceRequest=} [properties] Properties to set
             */
            function ReferenceRequest(properties) {
                this.preconditions = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReferenceRequest key.
             * @member {Uint8Array} key
             * @memberof immudb.schema.ReferenceRequest
             * @instance
             */
            ReferenceRequest.prototype.key = $util.newBuffer([]);

            /**
             * ReferenceRequest referencedKey.
             * @member {Uint8Array} referencedKey
             * @memberof immudb.schema.ReferenceRequest
             * @instance
             */
            ReferenceRequest.prototype.referencedKey = $util.newBuffer([]);

            /**
             * ReferenceRequest atTx.
             * @member {Long} atTx
             * @memberof immudb.schema.ReferenceRequest
             * @instance
             */
            ReferenceRequest.prototype.atTx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ReferenceRequest boundRef.
             * @member {boolean} boundRef
             * @memberof immudb.schema.ReferenceRequest
             * @instance
             */
            ReferenceRequest.prototype.boundRef = false;

            /**
             * ReferenceRequest noWait.
             * @member {boolean} noWait
             * @memberof immudb.schema.ReferenceRequest
             * @instance
             */
            ReferenceRequest.prototype.noWait = false;

            /**
             * ReferenceRequest preconditions.
             * @member {Array.<immudb.schema.IPrecondition>} preconditions
             * @memberof immudb.schema.ReferenceRequest
             * @instance
             */
            ReferenceRequest.prototype.preconditions = $util.emptyArray;

            /**
             * Creates a new ReferenceRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.ReferenceRequest
             * @static
             * @param {immudb.schema.IReferenceRequest=} [properties] Properties to set
             * @returns {immudb.schema.ReferenceRequest} ReferenceRequest instance
             */
            ReferenceRequest.create = function create(properties) {
                return new ReferenceRequest(properties);
            };

            /**
             * Encodes the specified ReferenceRequest message. Does not implicitly {@link immudb.schema.ReferenceRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.ReferenceRequest
             * @static
             * @param {immudb.schema.IReferenceRequest} message ReferenceRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReferenceRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
                if (message.referencedKey != null && Object.hasOwnProperty.call(message, "referencedKey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.referencedKey);
                if (message.atTx != null && Object.hasOwnProperty.call(message, "atTx"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.atTx);
                if (message.boundRef != null && Object.hasOwnProperty.call(message, "boundRef"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.boundRef);
                if (message.noWait != null && Object.hasOwnProperty.call(message, "noWait"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.noWait);
                if (message.preconditions != null && message.preconditions.length)
                    for (let i = 0; i < message.preconditions.length; ++i)
                        $root.immudb.schema.Precondition.encode(message.preconditions[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReferenceRequest message, length delimited. Does not implicitly {@link immudb.schema.ReferenceRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.ReferenceRequest
             * @static
             * @param {immudb.schema.IReferenceRequest} message ReferenceRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReferenceRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReferenceRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.ReferenceRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.ReferenceRequest} ReferenceRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReferenceRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.ReferenceRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.key = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.referencedKey = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.atTx = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.boundRef = reader.bool();
                            break;
                        }
                    case 5: {
                            message.noWait = reader.bool();
                            break;
                        }
                    case 6: {
                            if (!(message.preconditions && message.preconditions.length))
                                message.preconditions = [];
                            message.preconditions.push($root.immudb.schema.Precondition.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReferenceRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.ReferenceRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.ReferenceRequest} ReferenceRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReferenceRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReferenceRequest message.
             * @function verify
             * @memberof immudb.schema.ReferenceRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReferenceRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                        return "key: buffer expected";
                if (message.referencedKey != null && message.hasOwnProperty("referencedKey"))
                    if (!(message.referencedKey && typeof message.referencedKey.length === "number" || $util.isString(message.referencedKey)))
                        return "referencedKey: buffer expected";
                if (message.atTx != null && message.hasOwnProperty("atTx"))
                    if (!$util.isInteger(message.atTx) && !(message.atTx && $util.isInteger(message.atTx.low) && $util.isInteger(message.atTx.high)))
                        return "atTx: integer|Long expected";
                if (message.boundRef != null && message.hasOwnProperty("boundRef"))
                    if (typeof message.boundRef !== "boolean")
                        return "boundRef: boolean expected";
                if (message.noWait != null && message.hasOwnProperty("noWait"))
                    if (typeof message.noWait !== "boolean")
                        return "noWait: boolean expected";
                if (message.preconditions != null && message.hasOwnProperty("preconditions")) {
                    if (!Array.isArray(message.preconditions))
                        return "preconditions: array expected";
                    for (let i = 0; i < message.preconditions.length; ++i) {
                        let error = $root.immudb.schema.Precondition.verify(message.preconditions[i]);
                        if (error)
                            return "preconditions." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ReferenceRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.ReferenceRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.ReferenceRequest} ReferenceRequest
             */
            ReferenceRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.ReferenceRequest)
                    return object;
                let message = new $root.immudb.schema.ReferenceRequest();
                if (object.key != null)
                    if (typeof object.key === "string")
                        $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                    else if (object.key.length >= 0)
                        message.key = object.key;
                if (object.referencedKey != null)
                    if (typeof object.referencedKey === "string")
                        $util.base64.decode(object.referencedKey, message.referencedKey = $util.newBuffer($util.base64.length(object.referencedKey)), 0);
                    else if (object.referencedKey.length >= 0)
                        message.referencedKey = object.referencedKey;
                if (object.atTx != null)
                    if ($util.Long)
                        (message.atTx = $util.Long.fromValue(object.atTx)).unsigned = true;
                    else if (typeof object.atTx === "string")
                        message.atTx = parseInt(object.atTx, 10);
                    else if (typeof object.atTx === "number")
                        message.atTx = object.atTx;
                    else if (typeof object.atTx === "object")
                        message.atTx = new $util.LongBits(object.atTx.low >>> 0, object.atTx.high >>> 0).toNumber(true);
                if (object.boundRef != null)
                    message.boundRef = Boolean(object.boundRef);
                if (object.noWait != null)
                    message.noWait = Boolean(object.noWait);
                if (object.preconditions) {
                    if (!Array.isArray(object.preconditions))
                        throw TypeError(".immudb.schema.ReferenceRequest.preconditions: array expected");
                    message.preconditions = [];
                    for (let i = 0; i < object.preconditions.length; ++i) {
                        if (typeof object.preconditions[i] !== "object")
                            throw TypeError(".immudb.schema.ReferenceRequest.preconditions: object expected");
                        message.preconditions[i] = $root.immudb.schema.Precondition.fromObject(object.preconditions[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ReferenceRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.ReferenceRequest
             * @static
             * @param {immudb.schema.ReferenceRequest} message ReferenceRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReferenceRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.preconditions = [];
                if (options.defaults) {
                    if (options.bytes === String)
                        object.key = "";
                    else {
                        object.key = [];
                        if (options.bytes !== Array)
                            object.key = $util.newBuffer(object.key);
                    }
                    if (options.bytes === String)
                        object.referencedKey = "";
                    else {
                        object.referencedKey = [];
                        if (options.bytes !== Array)
                            object.referencedKey = $util.newBuffer(object.referencedKey);
                    }
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.atTx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.atTx = options.longs === String ? "0" : 0;
                    object.boundRef = false;
                    object.noWait = false;
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                if (message.referencedKey != null && message.hasOwnProperty("referencedKey"))
                    object.referencedKey = options.bytes === String ? $util.base64.encode(message.referencedKey, 0, message.referencedKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.referencedKey) : message.referencedKey;
                if (message.atTx != null && message.hasOwnProperty("atTx"))
                    if (typeof message.atTx === "number")
                        object.atTx = options.longs === String ? String(message.atTx) : message.atTx;
                    else
                        object.atTx = options.longs === String ? $util.Long.prototype.toString.call(message.atTx) : options.longs === Number ? new $util.LongBits(message.atTx.low >>> 0, message.atTx.high >>> 0).toNumber(true) : message.atTx;
                if (message.boundRef != null && message.hasOwnProperty("boundRef"))
                    object.boundRef = message.boundRef;
                if (message.noWait != null && message.hasOwnProperty("noWait"))
                    object.noWait = message.noWait;
                if (message.preconditions && message.preconditions.length) {
                    object.preconditions = [];
                    for (let j = 0; j < message.preconditions.length; ++j)
                        object.preconditions[j] = $root.immudb.schema.Precondition.toObject(message.preconditions[j], options);
                }
                return object;
            };

            /**
             * Converts this ReferenceRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.ReferenceRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReferenceRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ReferenceRequest
             * @function getTypeUrl
             * @memberof immudb.schema.ReferenceRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ReferenceRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.ReferenceRequest";
            };

            return ReferenceRequest;
        })();

        schema.VerifiableReferenceRequest = (function() {

            /**
             * Properties of a VerifiableReferenceRequest.
             * @memberof immudb.schema
             * @interface IVerifiableReferenceRequest
             * @property {immudb.schema.IReferenceRequest|null} [referenceRequest] VerifiableReferenceRequest referenceRequest
             * @property {Long|null} [proveSinceTx] VerifiableReferenceRequest proveSinceTx
             */

            /**
             * Constructs a new VerifiableReferenceRequest.
             * @memberof immudb.schema
             * @classdesc Represents a VerifiableReferenceRequest.
             * @implements IVerifiableReferenceRequest
             * @constructor
             * @param {immudb.schema.IVerifiableReferenceRequest=} [properties] Properties to set
             */
            function VerifiableReferenceRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VerifiableReferenceRequest referenceRequest.
             * @member {immudb.schema.IReferenceRequest|null|undefined} referenceRequest
             * @memberof immudb.schema.VerifiableReferenceRequest
             * @instance
             */
            VerifiableReferenceRequest.prototype.referenceRequest = null;

            /**
             * VerifiableReferenceRequest proveSinceTx.
             * @member {Long} proveSinceTx
             * @memberof immudb.schema.VerifiableReferenceRequest
             * @instance
             */
            VerifiableReferenceRequest.prototype.proveSinceTx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new VerifiableReferenceRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.VerifiableReferenceRequest
             * @static
             * @param {immudb.schema.IVerifiableReferenceRequest=} [properties] Properties to set
             * @returns {immudb.schema.VerifiableReferenceRequest} VerifiableReferenceRequest instance
             */
            VerifiableReferenceRequest.create = function create(properties) {
                return new VerifiableReferenceRequest(properties);
            };

            /**
             * Encodes the specified VerifiableReferenceRequest message. Does not implicitly {@link immudb.schema.VerifiableReferenceRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.VerifiableReferenceRequest
             * @static
             * @param {immudb.schema.IVerifiableReferenceRequest} message VerifiableReferenceRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VerifiableReferenceRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.referenceRequest != null && Object.hasOwnProperty.call(message, "referenceRequest"))
                    $root.immudb.schema.ReferenceRequest.encode(message.referenceRequest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.proveSinceTx != null && Object.hasOwnProperty.call(message, "proveSinceTx"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.proveSinceTx);
                return writer;
            };

            /**
             * Encodes the specified VerifiableReferenceRequest message, length delimited. Does not implicitly {@link immudb.schema.VerifiableReferenceRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.VerifiableReferenceRequest
             * @static
             * @param {immudb.schema.IVerifiableReferenceRequest} message VerifiableReferenceRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VerifiableReferenceRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VerifiableReferenceRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.VerifiableReferenceRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.VerifiableReferenceRequest} VerifiableReferenceRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VerifiableReferenceRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.VerifiableReferenceRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.referenceRequest = $root.immudb.schema.ReferenceRequest.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.proveSinceTx = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VerifiableReferenceRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.VerifiableReferenceRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.VerifiableReferenceRequest} VerifiableReferenceRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VerifiableReferenceRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VerifiableReferenceRequest message.
             * @function verify
             * @memberof immudb.schema.VerifiableReferenceRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VerifiableReferenceRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.referenceRequest != null && message.hasOwnProperty("referenceRequest")) {
                    let error = $root.immudb.schema.ReferenceRequest.verify(message.referenceRequest);
                    if (error)
                        return "referenceRequest." + error;
                }
                if (message.proveSinceTx != null && message.hasOwnProperty("proveSinceTx"))
                    if (!$util.isInteger(message.proveSinceTx) && !(message.proveSinceTx && $util.isInteger(message.proveSinceTx.low) && $util.isInteger(message.proveSinceTx.high)))
                        return "proveSinceTx: integer|Long expected";
                return null;
            };

            /**
             * Creates a VerifiableReferenceRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.VerifiableReferenceRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.VerifiableReferenceRequest} VerifiableReferenceRequest
             */
            VerifiableReferenceRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.VerifiableReferenceRequest)
                    return object;
                let message = new $root.immudb.schema.VerifiableReferenceRequest();
                if (object.referenceRequest != null) {
                    if (typeof object.referenceRequest !== "object")
                        throw TypeError(".immudb.schema.VerifiableReferenceRequest.referenceRequest: object expected");
                    message.referenceRequest = $root.immudb.schema.ReferenceRequest.fromObject(object.referenceRequest);
                }
                if (object.proveSinceTx != null)
                    if ($util.Long)
                        (message.proveSinceTx = $util.Long.fromValue(object.proveSinceTx)).unsigned = true;
                    else if (typeof object.proveSinceTx === "string")
                        message.proveSinceTx = parseInt(object.proveSinceTx, 10);
                    else if (typeof object.proveSinceTx === "number")
                        message.proveSinceTx = object.proveSinceTx;
                    else if (typeof object.proveSinceTx === "object")
                        message.proveSinceTx = new $util.LongBits(object.proveSinceTx.low >>> 0, object.proveSinceTx.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a VerifiableReferenceRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.VerifiableReferenceRequest
             * @static
             * @param {immudb.schema.VerifiableReferenceRequest} message VerifiableReferenceRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VerifiableReferenceRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.referenceRequest = null;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.proveSinceTx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.proveSinceTx = options.longs === String ? "0" : 0;
                }
                if (message.referenceRequest != null && message.hasOwnProperty("referenceRequest"))
                    object.referenceRequest = $root.immudb.schema.ReferenceRequest.toObject(message.referenceRequest, options);
                if (message.proveSinceTx != null && message.hasOwnProperty("proveSinceTx"))
                    if (typeof message.proveSinceTx === "number")
                        object.proveSinceTx = options.longs === String ? String(message.proveSinceTx) : message.proveSinceTx;
                    else
                        object.proveSinceTx = options.longs === String ? $util.Long.prototype.toString.call(message.proveSinceTx) : options.longs === Number ? new $util.LongBits(message.proveSinceTx.low >>> 0, message.proveSinceTx.high >>> 0).toNumber(true) : message.proveSinceTx;
                return object;
            };

            /**
             * Converts this VerifiableReferenceRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.VerifiableReferenceRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VerifiableReferenceRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for VerifiableReferenceRequest
             * @function getTypeUrl
             * @memberof immudb.schema.VerifiableReferenceRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            VerifiableReferenceRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.VerifiableReferenceRequest";
            };

            return VerifiableReferenceRequest;
        })();

        schema.ZAddRequest = (function() {

            /**
             * Properties of a ZAddRequest.
             * @memberof immudb.schema
             * @interface IZAddRequest
             * @property {Uint8Array|null} [set] ZAddRequest set
             * @property {number|null} [score] ZAddRequest score
             * @property {Uint8Array|null} [key] ZAddRequest key
             * @property {Long|null} [atTx] ZAddRequest atTx
             * @property {boolean|null} [boundRef] ZAddRequest boundRef
             * @property {boolean|null} [noWait] ZAddRequest noWait
             */

            /**
             * Constructs a new ZAddRequest.
             * @memberof immudb.schema
             * @classdesc Represents a ZAddRequest.
             * @implements IZAddRequest
             * @constructor
             * @param {immudb.schema.IZAddRequest=} [properties] Properties to set
             */
            function ZAddRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ZAddRequest set.
             * @member {Uint8Array} set
             * @memberof immudb.schema.ZAddRequest
             * @instance
             */
            ZAddRequest.prototype.set = $util.newBuffer([]);

            /**
             * ZAddRequest score.
             * @member {number} score
             * @memberof immudb.schema.ZAddRequest
             * @instance
             */
            ZAddRequest.prototype.score = 0;

            /**
             * ZAddRequest key.
             * @member {Uint8Array} key
             * @memberof immudb.schema.ZAddRequest
             * @instance
             */
            ZAddRequest.prototype.key = $util.newBuffer([]);

            /**
             * ZAddRequest atTx.
             * @member {Long} atTx
             * @memberof immudb.schema.ZAddRequest
             * @instance
             */
            ZAddRequest.prototype.atTx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ZAddRequest boundRef.
             * @member {boolean} boundRef
             * @memberof immudb.schema.ZAddRequest
             * @instance
             */
            ZAddRequest.prototype.boundRef = false;

            /**
             * ZAddRequest noWait.
             * @member {boolean} noWait
             * @memberof immudb.schema.ZAddRequest
             * @instance
             */
            ZAddRequest.prototype.noWait = false;

            /**
             * Creates a new ZAddRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.ZAddRequest
             * @static
             * @param {immudb.schema.IZAddRequest=} [properties] Properties to set
             * @returns {immudb.schema.ZAddRequest} ZAddRequest instance
             */
            ZAddRequest.create = function create(properties) {
                return new ZAddRequest(properties);
            };

            /**
             * Encodes the specified ZAddRequest message. Does not implicitly {@link immudb.schema.ZAddRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.ZAddRequest
             * @static
             * @param {immudb.schema.IZAddRequest} message ZAddRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ZAddRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.set != null && Object.hasOwnProperty.call(message, "set"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.set);
                if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.score);
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.key);
                if (message.atTx != null && Object.hasOwnProperty.call(message, "atTx"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.atTx);
                if (message.boundRef != null && Object.hasOwnProperty.call(message, "boundRef"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.boundRef);
                if (message.noWait != null && Object.hasOwnProperty.call(message, "noWait"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.noWait);
                return writer;
            };

            /**
             * Encodes the specified ZAddRequest message, length delimited. Does not implicitly {@link immudb.schema.ZAddRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.ZAddRequest
             * @static
             * @param {immudb.schema.IZAddRequest} message ZAddRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ZAddRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ZAddRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.ZAddRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.ZAddRequest} ZAddRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ZAddRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.ZAddRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.set = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.score = reader.double();
                            break;
                        }
                    case 3: {
                            message.key = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.atTx = reader.uint64();
                            break;
                        }
                    case 5: {
                            message.boundRef = reader.bool();
                            break;
                        }
                    case 6: {
                            message.noWait = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ZAddRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.ZAddRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.ZAddRequest} ZAddRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ZAddRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ZAddRequest message.
             * @function verify
             * @memberof immudb.schema.ZAddRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ZAddRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.set != null && message.hasOwnProperty("set"))
                    if (!(message.set && typeof message.set.length === "number" || $util.isString(message.set)))
                        return "set: buffer expected";
                if (message.score != null && message.hasOwnProperty("score"))
                    if (typeof message.score !== "number")
                        return "score: number expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                        return "key: buffer expected";
                if (message.atTx != null && message.hasOwnProperty("atTx"))
                    if (!$util.isInteger(message.atTx) && !(message.atTx && $util.isInteger(message.atTx.low) && $util.isInteger(message.atTx.high)))
                        return "atTx: integer|Long expected";
                if (message.boundRef != null && message.hasOwnProperty("boundRef"))
                    if (typeof message.boundRef !== "boolean")
                        return "boundRef: boolean expected";
                if (message.noWait != null && message.hasOwnProperty("noWait"))
                    if (typeof message.noWait !== "boolean")
                        return "noWait: boolean expected";
                return null;
            };

            /**
             * Creates a ZAddRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.ZAddRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.ZAddRequest} ZAddRequest
             */
            ZAddRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.ZAddRequest)
                    return object;
                let message = new $root.immudb.schema.ZAddRequest();
                if (object.set != null)
                    if (typeof object.set === "string")
                        $util.base64.decode(object.set, message.set = $util.newBuffer($util.base64.length(object.set)), 0);
                    else if (object.set.length >= 0)
                        message.set = object.set;
                if (object.score != null)
                    message.score = Number(object.score);
                if (object.key != null)
                    if (typeof object.key === "string")
                        $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                    else if (object.key.length >= 0)
                        message.key = object.key;
                if (object.atTx != null)
                    if ($util.Long)
                        (message.atTx = $util.Long.fromValue(object.atTx)).unsigned = true;
                    else if (typeof object.atTx === "string")
                        message.atTx = parseInt(object.atTx, 10);
                    else if (typeof object.atTx === "number")
                        message.atTx = object.atTx;
                    else if (typeof object.atTx === "object")
                        message.atTx = new $util.LongBits(object.atTx.low >>> 0, object.atTx.high >>> 0).toNumber(true);
                if (object.boundRef != null)
                    message.boundRef = Boolean(object.boundRef);
                if (object.noWait != null)
                    message.noWait = Boolean(object.noWait);
                return message;
            };

            /**
             * Creates a plain object from a ZAddRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.ZAddRequest
             * @static
             * @param {immudb.schema.ZAddRequest} message ZAddRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ZAddRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.set = "";
                    else {
                        object.set = [];
                        if (options.bytes !== Array)
                            object.set = $util.newBuffer(object.set);
                    }
                    object.score = 0;
                    if (options.bytes === String)
                        object.key = "";
                    else {
                        object.key = [];
                        if (options.bytes !== Array)
                            object.key = $util.newBuffer(object.key);
                    }
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.atTx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.atTx = options.longs === String ? "0" : 0;
                    object.boundRef = false;
                    object.noWait = false;
                }
                if (message.set != null && message.hasOwnProperty("set"))
                    object.set = options.bytes === String ? $util.base64.encode(message.set, 0, message.set.length) : options.bytes === Array ? Array.prototype.slice.call(message.set) : message.set;
                if (message.score != null && message.hasOwnProperty("score"))
                    object.score = options.json && !isFinite(message.score) ? String(message.score) : message.score;
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                if (message.atTx != null && message.hasOwnProperty("atTx"))
                    if (typeof message.atTx === "number")
                        object.atTx = options.longs === String ? String(message.atTx) : message.atTx;
                    else
                        object.atTx = options.longs === String ? $util.Long.prototype.toString.call(message.atTx) : options.longs === Number ? new $util.LongBits(message.atTx.low >>> 0, message.atTx.high >>> 0).toNumber(true) : message.atTx;
                if (message.boundRef != null && message.hasOwnProperty("boundRef"))
                    object.boundRef = message.boundRef;
                if (message.noWait != null && message.hasOwnProperty("noWait"))
                    object.noWait = message.noWait;
                return object;
            };

            /**
             * Converts this ZAddRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.ZAddRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ZAddRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ZAddRequest
             * @function getTypeUrl
             * @memberof immudb.schema.ZAddRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ZAddRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.ZAddRequest";
            };

            return ZAddRequest;
        })();

        schema.Score = (function() {

            /**
             * Properties of a Score.
             * @memberof immudb.schema
             * @interface IScore
             * @property {number|null} [score] Score score
             */

            /**
             * Constructs a new Score.
             * @memberof immudb.schema
             * @classdesc Represents a Score.
             * @implements IScore
             * @constructor
             * @param {immudb.schema.IScore=} [properties] Properties to set
             */
            function Score(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Score score.
             * @member {number} score
             * @memberof immudb.schema.Score
             * @instance
             */
            Score.prototype.score = 0;

            /**
             * Creates a new Score instance using the specified properties.
             * @function create
             * @memberof immudb.schema.Score
             * @static
             * @param {immudb.schema.IScore=} [properties] Properties to set
             * @returns {immudb.schema.Score} Score instance
             */
            Score.create = function create(properties) {
                return new Score(properties);
            };

            /**
             * Encodes the specified Score message. Does not implicitly {@link immudb.schema.Score.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.Score
             * @static
             * @param {immudb.schema.IScore} message Score message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Score.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.score);
                return writer;
            };

            /**
             * Encodes the specified Score message, length delimited. Does not implicitly {@link immudb.schema.Score.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.Score
             * @static
             * @param {immudb.schema.IScore} message Score message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Score.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Score message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.Score
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.Score} Score
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Score.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.Score();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.score = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Score message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.Score
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.Score} Score
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Score.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Score message.
             * @function verify
             * @memberof immudb.schema.Score
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Score.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.score != null && message.hasOwnProperty("score"))
                    if (typeof message.score !== "number")
                        return "score: number expected";
                return null;
            };

            /**
             * Creates a Score message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.Score
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.Score} Score
             */
            Score.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.Score)
                    return object;
                let message = new $root.immudb.schema.Score();
                if (object.score != null)
                    message.score = Number(object.score);
                return message;
            };

            /**
             * Creates a plain object from a Score message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.Score
             * @static
             * @param {immudb.schema.Score} message Score
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Score.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.score = 0;
                if (message.score != null && message.hasOwnProperty("score"))
                    object.score = options.json && !isFinite(message.score) ? String(message.score) : message.score;
                return object;
            };

            /**
             * Converts this Score to JSON.
             * @function toJSON
             * @memberof immudb.schema.Score
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Score.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Score
             * @function getTypeUrl
             * @memberof immudb.schema.Score
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Score.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.Score";
            };

            return Score;
        })();

        schema.ZScanRequest = (function() {

            /**
             * Properties of a ZScanRequest.
             * @memberof immudb.schema
             * @interface IZScanRequest
             * @property {Uint8Array|null} [set] ZScanRequest set
             * @property {Uint8Array|null} [seekKey] ZScanRequest seekKey
             * @property {number|null} [seekScore] ZScanRequest seekScore
             * @property {Long|null} [seekAtTx] ZScanRequest seekAtTx
             * @property {boolean|null} [inclusiveSeek] ZScanRequest inclusiveSeek
             * @property {Long|null} [limit] ZScanRequest limit
             * @property {boolean|null} [desc] ZScanRequest desc
             * @property {immudb.schema.IScore|null} [minScore] ZScanRequest minScore
             * @property {immudb.schema.IScore|null} [maxScore] ZScanRequest maxScore
             * @property {Long|null} [sinceTx] ZScanRequest sinceTx
             * @property {boolean|null} [noWait] ZScanRequest noWait
             */

            /**
             * Constructs a new ZScanRequest.
             * @memberof immudb.schema
             * @classdesc Represents a ZScanRequest.
             * @implements IZScanRequest
             * @constructor
             * @param {immudb.schema.IZScanRequest=} [properties] Properties to set
             */
            function ZScanRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ZScanRequest set.
             * @member {Uint8Array} set
             * @memberof immudb.schema.ZScanRequest
             * @instance
             */
            ZScanRequest.prototype.set = $util.newBuffer([]);

            /**
             * ZScanRequest seekKey.
             * @member {Uint8Array} seekKey
             * @memberof immudb.schema.ZScanRequest
             * @instance
             */
            ZScanRequest.prototype.seekKey = $util.newBuffer([]);

            /**
             * ZScanRequest seekScore.
             * @member {number} seekScore
             * @memberof immudb.schema.ZScanRequest
             * @instance
             */
            ZScanRequest.prototype.seekScore = 0;

            /**
             * ZScanRequest seekAtTx.
             * @member {Long} seekAtTx
             * @memberof immudb.schema.ZScanRequest
             * @instance
             */
            ZScanRequest.prototype.seekAtTx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ZScanRequest inclusiveSeek.
             * @member {boolean} inclusiveSeek
             * @memberof immudb.schema.ZScanRequest
             * @instance
             */
            ZScanRequest.prototype.inclusiveSeek = false;

            /**
             * ZScanRequest limit.
             * @member {Long} limit
             * @memberof immudb.schema.ZScanRequest
             * @instance
             */
            ZScanRequest.prototype.limit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ZScanRequest desc.
             * @member {boolean} desc
             * @memberof immudb.schema.ZScanRequest
             * @instance
             */
            ZScanRequest.prototype.desc = false;

            /**
             * ZScanRequest minScore.
             * @member {immudb.schema.IScore|null|undefined} minScore
             * @memberof immudb.schema.ZScanRequest
             * @instance
             */
            ZScanRequest.prototype.minScore = null;

            /**
             * ZScanRequest maxScore.
             * @member {immudb.schema.IScore|null|undefined} maxScore
             * @memberof immudb.schema.ZScanRequest
             * @instance
             */
            ZScanRequest.prototype.maxScore = null;

            /**
             * ZScanRequest sinceTx.
             * @member {Long} sinceTx
             * @memberof immudb.schema.ZScanRequest
             * @instance
             */
            ZScanRequest.prototype.sinceTx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ZScanRequest noWait.
             * @member {boolean} noWait
             * @memberof immudb.schema.ZScanRequest
             * @instance
             */
            ZScanRequest.prototype.noWait = false;

            /**
             * Creates a new ZScanRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.ZScanRequest
             * @static
             * @param {immudb.schema.IZScanRequest=} [properties] Properties to set
             * @returns {immudb.schema.ZScanRequest} ZScanRequest instance
             */
            ZScanRequest.create = function create(properties) {
                return new ZScanRequest(properties);
            };

            /**
             * Encodes the specified ZScanRequest message. Does not implicitly {@link immudb.schema.ZScanRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.ZScanRequest
             * @static
             * @param {immudb.schema.IZScanRequest} message ZScanRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ZScanRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.set != null && Object.hasOwnProperty.call(message, "set"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.set);
                if (message.seekKey != null && Object.hasOwnProperty.call(message, "seekKey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.seekKey);
                if (message.seekScore != null && Object.hasOwnProperty.call(message, "seekScore"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.seekScore);
                if (message.seekAtTx != null && Object.hasOwnProperty.call(message, "seekAtTx"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.seekAtTx);
                if (message.inclusiveSeek != null && Object.hasOwnProperty.call(message, "inclusiveSeek"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.inclusiveSeek);
                if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.limit);
                if (message.desc != null && Object.hasOwnProperty.call(message, "desc"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.desc);
                if (message.minScore != null && Object.hasOwnProperty.call(message, "minScore"))
                    $root.immudb.schema.Score.encode(message.minScore, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.maxScore != null && Object.hasOwnProperty.call(message, "maxScore"))
                    $root.immudb.schema.Score.encode(message.maxScore, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.sinceTx != null && Object.hasOwnProperty.call(message, "sinceTx"))
                    writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.sinceTx);
                if (message.noWait != null && Object.hasOwnProperty.call(message, "noWait"))
                    writer.uint32(/* id 11, wireType 0 =*/88).bool(message.noWait);
                return writer;
            };

            /**
             * Encodes the specified ZScanRequest message, length delimited. Does not implicitly {@link immudb.schema.ZScanRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.ZScanRequest
             * @static
             * @param {immudb.schema.IZScanRequest} message ZScanRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ZScanRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ZScanRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.ZScanRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.ZScanRequest} ZScanRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ZScanRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.ZScanRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.set = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.seekKey = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.seekScore = reader.double();
                            break;
                        }
                    case 4: {
                            message.seekAtTx = reader.uint64();
                            break;
                        }
                    case 5: {
                            message.inclusiveSeek = reader.bool();
                            break;
                        }
                    case 6: {
                            message.limit = reader.uint64();
                            break;
                        }
                    case 7: {
                            message.desc = reader.bool();
                            break;
                        }
                    case 8: {
                            message.minScore = $root.immudb.schema.Score.decode(reader, reader.uint32());
                            break;
                        }
                    case 9: {
                            message.maxScore = $root.immudb.schema.Score.decode(reader, reader.uint32());
                            break;
                        }
                    case 10: {
                            message.sinceTx = reader.uint64();
                            break;
                        }
                    case 11: {
                            message.noWait = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ZScanRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.ZScanRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.ZScanRequest} ZScanRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ZScanRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ZScanRequest message.
             * @function verify
             * @memberof immudb.schema.ZScanRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ZScanRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.set != null && message.hasOwnProperty("set"))
                    if (!(message.set && typeof message.set.length === "number" || $util.isString(message.set)))
                        return "set: buffer expected";
                if (message.seekKey != null && message.hasOwnProperty("seekKey"))
                    if (!(message.seekKey && typeof message.seekKey.length === "number" || $util.isString(message.seekKey)))
                        return "seekKey: buffer expected";
                if (message.seekScore != null && message.hasOwnProperty("seekScore"))
                    if (typeof message.seekScore !== "number")
                        return "seekScore: number expected";
                if (message.seekAtTx != null && message.hasOwnProperty("seekAtTx"))
                    if (!$util.isInteger(message.seekAtTx) && !(message.seekAtTx && $util.isInteger(message.seekAtTx.low) && $util.isInteger(message.seekAtTx.high)))
                        return "seekAtTx: integer|Long expected";
                if (message.inclusiveSeek != null && message.hasOwnProperty("inclusiveSeek"))
                    if (typeof message.inclusiveSeek !== "boolean")
                        return "inclusiveSeek: boolean expected";
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (!$util.isInteger(message.limit) && !(message.limit && $util.isInteger(message.limit.low) && $util.isInteger(message.limit.high)))
                        return "limit: integer|Long expected";
                if (message.desc != null && message.hasOwnProperty("desc"))
                    if (typeof message.desc !== "boolean")
                        return "desc: boolean expected";
                if (message.minScore != null && message.hasOwnProperty("minScore")) {
                    let error = $root.immudb.schema.Score.verify(message.minScore);
                    if (error)
                        return "minScore." + error;
                }
                if (message.maxScore != null && message.hasOwnProperty("maxScore")) {
                    let error = $root.immudb.schema.Score.verify(message.maxScore);
                    if (error)
                        return "maxScore." + error;
                }
                if (message.sinceTx != null && message.hasOwnProperty("sinceTx"))
                    if (!$util.isInteger(message.sinceTx) && !(message.sinceTx && $util.isInteger(message.sinceTx.low) && $util.isInteger(message.sinceTx.high)))
                        return "sinceTx: integer|Long expected";
                if (message.noWait != null && message.hasOwnProperty("noWait"))
                    if (typeof message.noWait !== "boolean")
                        return "noWait: boolean expected";
                return null;
            };

            /**
             * Creates a ZScanRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.ZScanRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.ZScanRequest} ZScanRequest
             */
            ZScanRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.ZScanRequest)
                    return object;
                let message = new $root.immudb.schema.ZScanRequest();
                if (object.set != null)
                    if (typeof object.set === "string")
                        $util.base64.decode(object.set, message.set = $util.newBuffer($util.base64.length(object.set)), 0);
                    else if (object.set.length >= 0)
                        message.set = object.set;
                if (object.seekKey != null)
                    if (typeof object.seekKey === "string")
                        $util.base64.decode(object.seekKey, message.seekKey = $util.newBuffer($util.base64.length(object.seekKey)), 0);
                    else if (object.seekKey.length >= 0)
                        message.seekKey = object.seekKey;
                if (object.seekScore != null)
                    message.seekScore = Number(object.seekScore);
                if (object.seekAtTx != null)
                    if ($util.Long)
                        (message.seekAtTx = $util.Long.fromValue(object.seekAtTx)).unsigned = true;
                    else if (typeof object.seekAtTx === "string")
                        message.seekAtTx = parseInt(object.seekAtTx, 10);
                    else if (typeof object.seekAtTx === "number")
                        message.seekAtTx = object.seekAtTx;
                    else if (typeof object.seekAtTx === "object")
                        message.seekAtTx = new $util.LongBits(object.seekAtTx.low >>> 0, object.seekAtTx.high >>> 0).toNumber(true);
                if (object.inclusiveSeek != null)
                    message.inclusiveSeek = Boolean(object.inclusiveSeek);
                if (object.limit != null)
                    if ($util.Long)
                        (message.limit = $util.Long.fromValue(object.limit)).unsigned = true;
                    else if (typeof object.limit === "string")
                        message.limit = parseInt(object.limit, 10);
                    else if (typeof object.limit === "number")
                        message.limit = object.limit;
                    else if (typeof object.limit === "object")
                        message.limit = new $util.LongBits(object.limit.low >>> 0, object.limit.high >>> 0).toNumber(true);
                if (object.desc != null)
                    message.desc = Boolean(object.desc);
                if (object.minScore != null) {
                    if (typeof object.minScore !== "object")
                        throw TypeError(".immudb.schema.ZScanRequest.minScore: object expected");
                    message.minScore = $root.immudb.schema.Score.fromObject(object.minScore);
                }
                if (object.maxScore != null) {
                    if (typeof object.maxScore !== "object")
                        throw TypeError(".immudb.schema.ZScanRequest.maxScore: object expected");
                    message.maxScore = $root.immudb.schema.Score.fromObject(object.maxScore);
                }
                if (object.sinceTx != null)
                    if ($util.Long)
                        (message.sinceTx = $util.Long.fromValue(object.sinceTx)).unsigned = true;
                    else if (typeof object.sinceTx === "string")
                        message.sinceTx = parseInt(object.sinceTx, 10);
                    else if (typeof object.sinceTx === "number")
                        message.sinceTx = object.sinceTx;
                    else if (typeof object.sinceTx === "object")
                        message.sinceTx = new $util.LongBits(object.sinceTx.low >>> 0, object.sinceTx.high >>> 0).toNumber(true);
                if (object.noWait != null)
                    message.noWait = Boolean(object.noWait);
                return message;
            };

            /**
             * Creates a plain object from a ZScanRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.ZScanRequest
             * @static
             * @param {immudb.schema.ZScanRequest} message ZScanRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ZScanRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.set = "";
                    else {
                        object.set = [];
                        if (options.bytes !== Array)
                            object.set = $util.newBuffer(object.set);
                    }
                    if (options.bytes === String)
                        object.seekKey = "";
                    else {
                        object.seekKey = [];
                        if (options.bytes !== Array)
                            object.seekKey = $util.newBuffer(object.seekKey);
                    }
                    object.seekScore = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.seekAtTx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.seekAtTx = options.longs === String ? "0" : 0;
                    object.inclusiveSeek = false;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.limit = options.longs === String ? "0" : 0;
                    object.desc = false;
                    object.minScore = null;
                    object.maxScore = null;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.sinceTx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sinceTx = options.longs === String ? "0" : 0;
                    object.noWait = false;
                }
                if (message.set != null && message.hasOwnProperty("set"))
                    object.set = options.bytes === String ? $util.base64.encode(message.set, 0, message.set.length) : options.bytes === Array ? Array.prototype.slice.call(message.set) : message.set;
                if (message.seekKey != null && message.hasOwnProperty("seekKey"))
                    object.seekKey = options.bytes === String ? $util.base64.encode(message.seekKey, 0, message.seekKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.seekKey) : message.seekKey;
                if (message.seekScore != null && message.hasOwnProperty("seekScore"))
                    object.seekScore = options.json && !isFinite(message.seekScore) ? String(message.seekScore) : message.seekScore;
                if (message.seekAtTx != null && message.hasOwnProperty("seekAtTx"))
                    if (typeof message.seekAtTx === "number")
                        object.seekAtTx = options.longs === String ? String(message.seekAtTx) : message.seekAtTx;
                    else
                        object.seekAtTx = options.longs === String ? $util.Long.prototype.toString.call(message.seekAtTx) : options.longs === Number ? new $util.LongBits(message.seekAtTx.low >>> 0, message.seekAtTx.high >>> 0).toNumber(true) : message.seekAtTx;
                if (message.inclusiveSeek != null && message.hasOwnProperty("inclusiveSeek"))
                    object.inclusiveSeek = message.inclusiveSeek;
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (typeof message.limit === "number")
                        object.limit = options.longs === String ? String(message.limit) : message.limit;
                    else
                        object.limit = options.longs === String ? $util.Long.prototype.toString.call(message.limit) : options.longs === Number ? new $util.LongBits(message.limit.low >>> 0, message.limit.high >>> 0).toNumber(true) : message.limit;
                if (message.desc != null && message.hasOwnProperty("desc"))
                    object.desc = message.desc;
                if (message.minScore != null && message.hasOwnProperty("minScore"))
                    object.minScore = $root.immudb.schema.Score.toObject(message.minScore, options);
                if (message.maxScore != null && message.hasOwnProperty("maxScore"))
                    object.maxScore = $root.immudb.schema.Score.toObject(message.maxScore, options);
                if (message.sinceTx != null && message.hasOwnProperty("sinceTx"))
                    if (typeof message.sinceTx === "number")
                        object.sinceTx = options.longs === String ? String(message.sinceTx) : message.sinceTx;
                    else
                        object.sinceTx = options.longs === String ? $util.Long.prototype.toString.call(message.sinceTx) : options.longs === Number ? new $util.LongBits(message.sinceTx.low >>> 0, message.sinceTx.high >>> 0).toNumber(true) : message.sinceTx;
                if (message.noWait != null && message.hasOwnProperty("noWait"))
                    object.noWait = message.noWait;
                return object;
            };

            /**
             * Converts this ZScanRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.ZScanRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ZScanRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ZScanRequest
             * @function getTypeUrl
             * @memberof immudb.schema.ZScanRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ZScanRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.ZScanRequest";
            };

            return ZScanRequest;
        })();

        schema.HistoryRequest = (function() {

            /**
             * Properties of a HistoryRequest.
             * @memberof immudb.schema
             * @interface IHistoryRequest
             * @property {Uint8Array|null} [key] HistoryRequest key
             * @property {Long|null} [offset] HistoryRequest offset
             * @property {number|null} [limit] HistoryRequest limit
             * @property {boolean|null} [desc] HistoryRequest desc
             * @property {Long|null} [sinceTx] HistoryRequest sinceTx
             */

            /**
             * Constructs a new HistoryRequest.
             * @memberof immudb.schema
             * @classdesc Represents a HistoryRequest.
             * @implements IHistoryRequest
             * @constructor
             * @param {immudb.schema.IHistoryRequest=} [properties] Properties to set
             */
            function HistoryRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HistoryRequest key.
             * @member {Uint8Array} key
             * @memberof immudb.schema.HistoryRequest
             * @instance
             */
            HistoryRequest.prototype.key = $util.newBuffer([]);

            /**
             * HistoryRequest offset.
             * @member {Long} offset
             * @memberof immudb.schema.HistoryRequest
             * @instance
             */
            HistoryRequest.prototype.offset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * HistoryRequest limit.
             * @member {number} limit
             * @memberof immudb.schema.HistoryRequest
             * @instance
             */
            HistoryRequest.prototype.limit = 0;

            /**
             * HistoryRequest desc.
             * @member {boolean} desc
             * @memberof immudb.schema.HistoryRequest
             * @instance
             */
            HistoryRequest.prototype.desc = false;

            /**
             * HistoryRequest sinceTx.
             * @member {Long} sinceTx
             * @memberof immudb.schema.HistoryRequest
             * @instance
             */
            HistoryRequest.prototype.sinceTx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new HistoryRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.HistoryRequest
             * @static
             * @param {immudb.schema.IHistoryRequest=} [properties] Properties to set
             * @returns {immudb.schema.HistoryRequest} HistoryRequest instance
             */
            HistoryRequest.create = function create(properties) {
                return new HistoryRequest(properties);
            };

            /**
             * Encodes the specified HistoryRequest message. Does not implicitly {@link immudb.schema.HistoryRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.HistoryRequest
             * @static
             * @param {immudb.schema.IHistoryRequest} message HistoryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HistoryRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
                if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.offset);
                if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.limit);
                if (message.desc != null && Object.hasOwnProperty.call(message, "desc"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.desc);
                if (message.sinceTx != null && Object.hasOwnProperty.call(message, "sinceTx"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.sinceTx);
                return writer;
            };

            /**
             * Encodes the specified HistoryRequest message, length delimited. Does not implicitly {@link immudb.schema.HistoryRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.HistoryRequest
             * @static
             * @param {immudb.schema.IHistoryRequest} message HistoryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HistoryRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HistoryRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.HistoryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.HistoryRequest} HistoryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HistoryRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.HistoryRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.key = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.offset = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.limit = reader.int32();
                            break;
                        }
                    case 4: {
                            message.desc = reader.bool();
                            break;
                        }
                    case 5: {
                            message.sinceTx = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HistoryRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.HistoryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.HistoryRequest} HistoryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HistoryRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HistoryRequest message.
             * @function verify
             * @memberof immudb.schema.HistoryRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HistoryRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                        return "key: buffer expected";
                if (message.offset != null && message.hasOwnProperty("offset"))
                    if (!$util.isInteger(message.offset) && !(message.offset && $util.isInteger(message.offset.low) && $util.isInteger(message.offset.high)))
                        return "offset: integer|Long expected";
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (!$util.isInteger(message.limit))
                        return "limit: integer expected";
                if (message.desc != null && message.hasOwnProperty("desc"))
                    if (typeof message.desc !== "boolean")
                        return "desc: boolean expected";
                if (message.sinceTx != null && message.hasOwnProperty("sinceTx"))
                    if (!$util.isInteger(message.sinceTx) && !(message.sinceTx && $util.isInteger(message.sinceTx.low) && $util.isInteger(message.sinceTx.high)))
                        return "sinceTx: integer|Long expected";
                return null;
            };

            /**
             * Creates a HistoryRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.HistoryRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.HistoryRequest} HistoryRequest
             */
            HistoryRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.HistoryRequest)
                    return object;
                let message = new $root.immudb.schema.HistoryRequest();
                if (object.key != null)
                    if (typeof object.key === "string")
                        $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                    else if (object.key.length >= 0)
                        message.key = object.key;
                if (object.offset != null)
                    if ($util.Long)
                        (message.offset = $util.Long.fromValue(object.offset)).unsigned = true;
                    else if (typeof object.offset === "string")
                        message.offset = parseInt(object.offset, 10);
                    else if (typeof object.offset === "number")
                        message.offset = object.offset;
                    else if (typeof object.offset === "object")
                        message.offset = new $util.LongBits(object.offset.low >>> 0, object.offset.high >>> 0).toNumber(true);
                if (object.limit != null)
                    message.limit = object.limit | 0;
                if (object.desc != null)
                    message.desc = Boolean(object.desc);
                if (object.sinceTx != null)
                    if ($util.Long)
                        (message.sinceTx = $util.Long.fromValue(object.sinceTx)).unsigned = true;
                    else if (typeof object.sinceTx === "string")
                        message.sinceTx = parseInt(object.sinceTx, 10);
                    else if (typeof object.sinceTx === "number")
                        message.sinceTx = object.sinceTx;
                    else if (typeof object.sinceTx === "object")
                        message.sinceTx = new $util.LongBits(object.sinceTx.low >>> 0, object.sinceTx.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a HistoryRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.HistoryRequest
             * @static
             * @param {immudb.schema.HistoryRequest} message HistoryRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HistoryRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.key = "";
                    else {
                        object.key = [];
                        if (options.bytes !== Array)
                            object.key = $util.newBuffer(object.key);
                    }
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.offset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.offset = options.longs === String ? "0" : 0;
                    object.limit = 0;
                    object.desc = false;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.sinceTx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sinceTx = options.longs === String ? "0" : 0;
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                if (message.offset != null && message.hasOwnProperty("offset"))
                    if (typeof message.offset === "number")
                        object.offset = options.longs === String ? String(message.offset) : message.offset;
                    else
                        object.offset = options.longs === String ? $util.Long.prototype.toString.call(message.offset) : options.longs === Number ? new $util.LongBits(message.offset.low >>> 0, message.offset.high >>> 0).toNumber(true) : message.offset;
                if (message.limit != null && message.hasOwnProperty("limit"))
                    object.limit = message.limit;
                if (message.desc != null && message.hasOwnProperty("desc"))
                    object.desc = message.desc;
                if (message.sinceTx != null && message.hasOwnProperty("sinceTx"))
                    if (typeof message.sinceTx === "number")
                        object.sinceTx = options.longs === String ? String(message.sinceTx) : message.sinceTx;
                    else
                        object.sinceTx = options.longs === String ? $util.Long.prototype.toString.call(message.sinceTx) : options.longs === Number ? new $util.LongBits(message.sinceTx.low >>> 0, message.sinceTx.high >>> 0).toNumber(true) : message.sinceTx;
                return object;
            };

            /**
             * Converts this HistoryRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.HistoryRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HistoryRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for HistoryRequest
             * @function getTypeUrl
             * @memberof immudb.schema.HistoryRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            HistoryRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.HistoryRequest";
            };

            return HistoryRequest;
        })();

        schema.VerifiableZAddRequest = (function() {

            /**
             * Properties of a VerifiableZAddRequest.
             * @memberof immudb.schema
             * @interface IVerifiableZAddRequest
             * @property {immudb.schema.IZAddRequest|null} [zAddRequest] VerifiableZAddRequest zAddRequest
             * @property {Long|null} [proveSinceTx] VerifiableZAddRequest proveSinceTx
             */

            /**
             * Constructs a new VerifiableZAddRequest.
             * @memberof immudb.schema
             * @classdesc Represents a VerifiableZAddRequest.
             * @implements IVerifiableZAddRequest
             * @constructor
             * @param {immudb.schema.IVerifiableZAddRequest=} [properties] Properties to set
             */
            function VerifiableZAddRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VerifiableZAddRequest zAddRequest.
             * @member {immudb.schema.IZAddRequest|null|undefined} zAddRequest
             * @memberof immudb.schema.VerifiableZAddRequest
             * @instance
             */
            VerifiableZAddRequest.prototype.zAddRequest = null;

            /**
             * VerifiableZAddRequest proveSinceTx.
             * @member {Long} proveSinceTx
             * @memberof immudb.schema.VerifiableZAddRequest
             * @instance
             */
            VerifiableZAddRequest.prototype.proveSinceTx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new VerifiableZAddRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.VerifiableZAddRequest
             * @static
             * @param {immudb.schema.IVerifiableZAddRequest=} [properties] Properties to set
             * @returns {immudb.schema.VerifiableZAddRequest} VerifiableZAddRequest instance
             */
            VerifiableZAddRequest.create = function create(properties) {
                return new VerifiableZAddRequest(properties);
            };

            /**
             * Encodes the specified VerifiableZAddRequest message. Does not implicitly {@link immudb.schema.VerifiableZAddRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.VerifiableZAddRequest
             * @static
             * @param {immudb.schema.IVerifiableZAddRequest} message VerifiableZAddRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VerifiableZAddRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.zAddRequest != null && Object.hasOwnProperty.call(message, "zAddRequest"))
                    $root.immudb.schema.ZAddRequest.encode(message.zAddRequest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.proveSinceTx != null && Object.hasOwnProperty.call(message, "proveSinceTx"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.proveSinceTx);
                return writer;
            };

            /**
             * Encodes the specified VerifiableZAddRequest message, length delimited. Does not implicitly {@link immudb.schema.VerifiableZAddRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.VerifiableZAddRequest
             * @static
             * @param {immudb.schema.IVerifiableZAddRequest} message VerifiableZAddRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VerifiableZAddRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VerifiableZAddRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.VerifiableZAddRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.VerifiableZAddRequest} VerifiableZAddRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VerifiableZAddRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.VerifiableZAddRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.zAddRequest = $root.immudb.schema.ZAddRequest.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.proveSinceTx = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VerifiableZAddRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.VerifiableZAddRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.VerifiableZAddRequest} VerifiableZAddRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VerifiableZAddRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VerifiableZAddRequest message.
             * @function verify
             * @memberof immudb.schema.VerifiableZAddRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VerifiableZAddRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.zAddRequest != null && message.hasOwnProperty("zAddRequest")) {
                    let error = $root.immudb.schema.ZAddRequest.verify(message.zAddRequest);
                    if (error)
                        return "zAddRequest." + error;
                }
                if (message.proveSinceTx != null && message.hasOwnProperty("proveSinceTx"))
                    if (!$util.isInteger(message.proveSinceTx) && !(message.proveSinceTx && $util.isInteger(message.proveSinceTx.low) && $util.isInteger(message.proveSinceTx.high)))
                        return "proveSinceTx: integer|Long expected";
                return null;
            };

            /**
             * Creates a VerifiableZAddRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.VerifiableZAddRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.VerifiableZAddRequest} VerifiableZAddRequest
             */
            VerifiableZAddRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.VerifiableZAddRequest)
                    return object;
                let message = new $root.immudb.schema.VerifiableZAddRequest();
                if (object.zAddRequest != null) {
                    if (typeof object.zAddRequest !== "object")
                        throw TypeError(".immudb.schema.VerifiableZAddRequest.zAddRequest: object expected");
                    message.zAddRequest = $root.immudb.schema.ZAddRequest.fromObject(object.zAddRequest);
                }
                if (object.proveSinceTx != null)
                    if ($util.Long)
                        (message.proveSinceTx = $util.Long.fromValue(object.proveSinceTx)).unsigned = true;
                    else if (typeof object.proveSinceTx === "string")
                        message.proveSinceTx = parseInt(object.proveSinceTx, 10);
                    else if (typeof object.proveSinceTx === "number")
                        message.proveSinceTx = object.proveSinceTx;
                    else if (typeof object.proveSinceTx === "object")
                        message.proveSinceTx = new $util.LongBits(object.proveSinceTx.low >>> 0, object.proveSinceTx.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a VerifiableZAddRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.VerifiableZAddRequest
             * @static
             * @param {immudb.schema.VerifiableZAddRequest} message VerifiableZAddRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VerifiableZAddRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.zAddRequest = null;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.proveSinceTx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.proveSinceTx = options.longs === String ? "0" : 0;
                }
                if (message.zAddRequest != null && message.hasOwnProperty("zAddRequest"))
                    object.zAddRequest = $root.immudb.schema.ZAddRequest.toObject(message.zAddRequest, options);
                if (message.proveSinceTx != null && message.hasOwnProperty("proveSinceTx"))
                    if (typeof message.proveSinceTx === "number")
                        object.proveSinceTx = options.longs === String ? String(message.proveSinceTx) : message.proveSinceTx;
                    else
                        object.proveSinceTx = options.longs === String ? $util.Long.prototype.toString.call(message.proveSinceTx) : options.longs === Number ? new $util.LongBits(message.proveSinceTx.low >>> 0, message.proveSinceTx.high >>> 0).toNumber(true) : message.proveSinceTx;
                return object;
            };

            /**
             * Converts this VerifiableZAddRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.VerifiableZAddRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VerifiableZAddRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for VerifiableZAddRequest
             * @function getTypeUrl
             * @memberof immudb.schema.VerifiableZAddRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            VerifiableZAddRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.VerifiableZAddRequest";
            };

            return VerifiableZAddRequest;
        })();

        schema.TxRequest = (function() {

            /**
             * Properties of a TxRequest.
             * @memberof immudb.schema
             * @interface ITxRequest
             * @property {Long|null} [tx] TxRequest tx
             * @property {immudb.schema.IEntriesSpec|null} [entriesSpec] TxRequest entriesSpec
             * @property {Long|null} [sinceTx] TxRequest sinceTx
             * @property {boolean|null} [noWait] TxRequest noWait
             * @property {boolean|null} [keepReferencesUnresolved] TxRequest keepReferencesUnresolved
             */

            /**
             * Constructs a new TxRequest.
             * @memberof immudb.schema
             * @classdesc Represents a TxRequest.
             * @implements ITxRequest
             * @constructor
             * @param {immudb.schema.ITxRequest=} [properties] Properties to set
             */
            function TxRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TxRequest tx.
             * @member {Long} tx
             * @memberof immudb.schema.TxRequest
             * @instance
             */
            TxRequest.prototype.tx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * TxRequest entriesSpec.
             * @member {immudb.schema.IEntriesSpec|null|undefined} entriesSpec
             * @memberof immudb.schema.TxRequest
             * @instance
             */
            TxRequest.prototype.entriesSpec = null;

            /**
             * TxRequest sinceTx.
             * @member {Long} sinceTx
             * @memberof immudb.schema.TxRequest
             * @instance
             */
            TxRequest.prototype.sinceTx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * TxRequest noWait.
             * @member {boolean} noWait
             * @memberof immudb.schema.TxRequest
             * @instance
             */
            TxRequest.prototype.noWait = false;

            /**
             * TxRequest keepReferencesUnresolved.
             * @member {boolean} keepReferencesUnresolved
             * @memberof immudb.schema.TxRequest
             * @instance
             */
            TxRequest.prototype.keepReferencesUnresolved = false;

            /**
             * Creates a new TxRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.TxRequest
             * @static
             * @param {immudb.schema.ITxRequest=} [properties] Properties to set
             * @returns {immudb.schema.TxRequest} TxRequest instance
             */
            TxRequest.create = function create(properties) {
                return new TxRequest(properties);
            };

            /**
             * Encodes the specified TxRequest message. Does not implicitly {@link immudb.schema.TxRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.TxRequest
             * @static
             * @param {immudb.schema.ITxRequest} message TxRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tx != null && Object.hasOwnProperty.call(message, "tx"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.tx);
                if (message.entriesSpec != null && Object.hasOwnProperty.call(message, "entriesSpec"))
                    $root.immudb.schema.EntriesSpec.encode(message.entriesSpec, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.sinceTx != null && Object.hasOwnProperty.call(message, "sinceTx"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.sinceTx);
                if (message.noWait != null && Object.hasOwnProperty.call(message, "noWait"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.noWait);
                if (message.keepReferencesUnresolved != null && Object.hasOwnProperty.call(message, "keepReferencesUnresolved"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.keepReferencesUnresolved);
                return writer;
            };

            /**
             * Encodes the specified TxRequest message, length delimited. Does not implicitly {@link immudb.schema.TxRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.TxRequest
             * @static
             * @param {immudb.schema.ITxRequest} message TxRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TxRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.TxRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.TxRequest} TxRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.TxRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.tx = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.entriesSpec = $root.immudb.schema.EntriesSpec.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.sinceTx = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.noWait = reader.bool();
                            break;
                        }
                    case 5: {
                            message.keepReferencesUnresolved = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TxRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.TxRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.TxRequest} TxRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TxRequest message.
             * @function verify
             * @memberof immudb.schema.TxRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TxRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tx != null && message.hasOwnProperty("tx"))
                    if (!$util.isInteger(message.tx) && !(message.tx && $util.isInteger(message.tx.low) && $util.isInteger(message.tx.high)))
                        return "tx: integer|Long expected";
                if (message.entriesSpec != null && message.hasOwnProperty("entriesSpec")) {
                    let error = $root.immudb.schema.EntriesSpec.verify(message.entriesSpec);
                    if (error)
                        return "entriesSpec." + error;
                }
                if (message.sinceTx != null && message.hasOwnProperty("sinceTx"))
                    if (!$util.isInteger(message.sinceTx) && !(message.sinceTx && $util.isInteger(message.sinceTx.low) && $util.isInteger(message.sinceTx.high)))
                        return "sinceTx: integer|Long expected";
                if (message.noWait != null && message.hasOwnProperty("noWait"))
                    if (typeof message.noWait !== "boolean")
                        return "noWait: boolean expected";
                if (message.keepReferencesUnresolved != null && message.hasOwnProperty("keepReferencesUnresolved"))
                    if (typeof message.keepReferencesUnresolved !== "boolean")
                        return "keepReferencesUnresolved: boolean expected";
                return null;
            };

            /**
             * Creates a TxRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.TxRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.TxRequest} TxRequest
             */
            TxRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.TxRequest)
                    return object;
                let message = new $root.immudb.schema.TxRequest();
                if (object.tx != null)
                    if ($util.Long)
                        (message.tx = $util.Long.fromValue(object.tx)).unsigned = true;
                    else if (typeof object.tx === "string")
                        message.tx = parseInt(object.tx, 10);
                    else if (typeof object.tx === "number")
                        message.tx = object.tx;
                    else if (typeof object.tx === "object")
                        message.tx = new $util.LongBits(object.tx.low >>> 0, object.tx.high >>> 0).toNumber(true);
                if (object.entriesSpec != null) {
                    if (typeof object.entriesSpec !== "object")
                        throw TypeError(".immudb.schema.TxRequest.entriesSpec: object expected");
                    message.entriesSpec = $root.immudb.schema.EntriesSpec.fromObject(object.entriesSpec);
                }
                if (object.sinceTx != null)
                    if ($util.Long)
                        (message.sinceTx = $util.Long.fromValue(object.sinceTx)).unsigned = true;
                    else if (typeof object.sinceTx === "string")
                        message.sinceTx = parseInt(object.sinceTx, 10);
                    else if (typeof object.sinceTx === "number")
                        message.sinceTx = object.sinceTx;
                    else if (typeof object.sinceTx === "object")
                        message.sinceTx = new $util.LongBits(object.sinceTx.low >>> 0, object.sinceTx.high >>> 0).toNumber(true);
                if (object.noWait != null)
                    message.noWait = Boolean(object.noWait);
                if (object.keepReferencesUnresolved != null)
                    message.keepReferencesUnresolved = Boolean(object.keepReferencesUnresolved);
                return message;
            };

            /**
             * Creates a plain object from a TxRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.TxRequest
             * @static
             * @param {immudb.schema.TxRequest} message TxRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TxRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.tx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.tx = options.longs === String ? "0" : 0;
                    object.entriesSpec = null;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.sinceTx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sinceTx = options.longs === String ? "0" : 0;
                    object.noWait = false;
                    object.keepReferencesUnresolved = false;
                }
                if (message.tx != null && message.hasOwnProperty("tx"))
                    if (typeof message.tx === "number")
                        object.tx = options.longs === String ? String(message.tx) : message.tx;
                    else
                        object.tx = options.longs === String ? $util.Long.prototype.toString.call(message.tx) : options.longs === Number ? new $util.LongBits(message.tx.low >>> 0, message.tx.high >>> 0).toNumber(true) : message.tx;
                if (message.entriesSpec != null && message.hasOwnProperty("entriesSpec"))
                    object.entriesSpec = $root.immudb.schema.EntriesSpec.toObject(message.entriesSpec, options);
                if (message.sinceTx != null && message.hasOwnProperty("sinceTx"))
                    if (typeof message.sinceTx === "number")
                        object.sinceTx = options.longs === String ? String(message.sinceTx) : message.sinceTx;
                    else
                        object.sinceTx = options.longs === String ? $util.Long.prototype.toString.call(message.sinceTx) : options.longs === Number ? new $util.LongBits(message.sinceTx.low >>> 0, message.sinceTx.high >>> 0).toNumber(true) : message.sinceTx;
                if (message.noWait != null && message.hasOwnProperty("noWait"))
                    object.noWait = message.noWait;
                if (message.keepReferencesUnresolved != null && message.hasOwnProperty("keepReferencesUnresolved"))
                    object.keepReferencesUnresolved = message.keepReferencesUnresolved;
                return object;
            };

            /**
             * Converts this TxRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.TxRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TxRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TxRequest
             * @function getTypeUrl
             * @memberof immudb.schema.TxRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TxRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.TxRequest";
            };

            return TxRequest;
        })();

        schema.EntriesSpec = (function() {

            /**
             * Properties of an EntriesSpec.
             * @memberof immudb.schema
             * @interface IEntriesSpec
             * @property {immudb.schema.IEntryTypeSpec|null} [kvEntriesSpec] EntriesSpec kvEntriesSpec
             * @property {immudb.schema.IEntryTypeSpec|null} [zEntriesSpec] EntriesSpec zEntriesSpec
             * @property {immudb.schema.IEntryTypeSpec|null} [sqlEntriesSpec] EntriesSpec sqlEntriesSpec
             */

            /**
             * Constructs a new EntriesSpec.
             * @memberof immudb.schema
             * @classdesc Represents an EntriesSpec.
             * @implements IEntriesSpec
             * @constructor
             * @param {immudb.schema.IEntriesSpec=} [properties] Properties to set
             */
            function EntriesSpec(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EntriesSpec kvEntriesSpec.
             * @member {immudb.schema.IEntryTypeSpec|null|undefined} kvEntriesSpec
             * @memberof immudb.schema.EntriesSpec
             * @instance
             */
            EntriesSpec.prototype.kvEntriesSpec = null;

            /**
             * EntriesSpec zEntriesSpec.
             * @member {immudb.schema.IEntryTypeSpec|null|undefined} zEntriesSpec
             * @memberof immudb.schema.EntriesSpec
             * @instance
             */
            EntriesSpec.prototype.zEntriesSpec = null;

            /**
             * EntriesSpec sqlEntriesSpec.
             * @member {immudb.schema.IEntryTypeSpec|null|undefined} sqlEntriesSpec
             * @memberof immudb.schema.EntriesSpec
             * @instance
             */
            EntriesSpec.prototype.sqlEntriesSpec = null;

            /**
             * Creates a new EntriesSpec instance using the specified properties.
             * @function create
             * @memberof immudb.schema.EntriesSpec
             * @static
             * @param {immudb.schema.IEntriesSpec=} [properties] Properties to set
             * @returns {immudb.schema.EntriesSpec} EntriesSpec instance
             */
            EntriesSpec.create = function create(properties) {
                return new EntriesSpec(properties);
            };

            /**
             * Encodes the specified EntriesSpec message. Does not implicitly {@link immudb.schema.EntriesSpec.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.EntriesSpec
             * @static
             * @param {immudb.schema.IEntriesSpec} message EntriesSpec message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EntriesSpec.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.kvEntriesSpec != null && Object.hasOwnProperty.call(message, "kvEntriesSpec"))
                    $root.immudb.schema.EntryTypeSpec.encode(message.kvEntriesSpec, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.zEntriesSpec != null && Object.hasOwnProperty.call(message, "zEntriesSpec"))
                    $root.immudb.schema.EntryTypeSpec.encode(message.zEntriesSpec, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.sqlEntriesSpec != null && Object.hasOwnProperty.call(message, "sqlEntriesSpec"))
                    $root.immudb.schema.EntryTypeSpec.encode(message.sqlEntriesSpec, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EntriesSpec message, length delimited. Does not implicitly {@link immudb.schema.EntriesSpec.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.EntriesSpec
             * @static
             * @param {immudb.schema.IEntriesSpec} message EntriesSpec message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EntriesSpec.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EntriesSpec message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.EntriesSpec
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.EntriesSpec} EntriesSpec
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EntriesSpec.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.EntriesSpec();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.kvEntriesSpec = $root.immudb.schema.EntryTypeSpec.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.zEntriesSpec = $root.immudb.schema.EntryTypeSpec.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.sqlEntriesSpec = $root.immudb.schema.EntryTypeSpec.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EntriesSpec message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.EntriesSpec
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.EntriesSpec} EntriesSpec
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EntriesSpec.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EntriesSpec message.
             * @function verify
             * @memberof immudb.schema.EntriesSpec
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EntriesSpec.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.kvEntriesSpec != null && message.hasOwnProperty("kvEntriesSpec")) {
                    let error = $root.immudb.schema.EntryTypeSpec.verify(message.kvEntriesSpec);
                    if (error)
                        return "kvEntriesSpec." + error;
                }
                if (message.zEntriesSpec != null && message.hasOwnProperty("zEntriesSpec")) {
                    let error = $root.immudb.schema.EntryTypeSpec.verify(message.zEntriesSpec);
                    if (error)
                        return "zEntriesSpec." + error;
                }
                if (message.sqlEntriesSpec != null && message.hasOwnProperty("sqlEntriesSpec")) {
                    let error = $root.immudb.schema.EntryTypeSpec.verify(message.sqlEntriesSpec);
                    if (error)
                        return "sqlEntriesSpec." + error;
                }
                return null;
            };

            /**
             * Creates an EntriesSpec message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.EntriesSpec
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.EntriesSpec} EntriesSpec
             */
            EntriesSpec.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.EntriesSpec)
                    return object;
                let message = new $root.immudb.schema.EntriesSpec();
                if (object.kvEntriesSpec != null) {
                    if (typeof object.kvEntriesSpec !== "object")
                        throw TypeError(".immudb.schema.EntriesSpec.kvEntriesSpec: object expected");
                    message.kvEntriesSpec = $root.immudb.schema.EntryTypeSpec.fromObject(object.kvEntriesSpec);
                }
                if (object.zEntriesSpec != null) {
                    if (typeof object.zEntriesSpec !== "object")
                        throw TypeError(".immudb.schema.EntriesSpec.zEntriesSpec: object expected");
                    message.zEntriesSpec = $root.immudb.schema.EntryTypeSpec.fromObject(object.zEntriesSpec);
                }
                if (object.sqlEntriesSpec != null) {
                    if (typeof object.sqlEntriesSpec !== "object")
                        throw TypeError(".immudb.schema.EntriesSpec.sqlEntriesSpec: object expected");
                    message.sqlEntriesSpec = $root.immudb.schema.EntryTypeSpec.fromObject(object.sqlEntriesSpec);
                }
                return message;
            };

            /**
             * Creates a plain object from an EntriesSpec message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.EntriesSpec
             * @static
             * @param {immudb.schema.EntriesSpec} message EntriesSpec
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EntriesSpec.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.kvEntriesSpec = null;
                    object.zEntriesSpec = null;
                    object.sqlEntriesSpec = null;
                }
                if (message.kvEntriesSpec != null && message.hasOwnProperty("kvEntriesSpec"))
                    object.kvEntriesSpec = $root.immudb.schema.EntryTypeSpec.toObject(message.kvEntriesSpec, options);
                if (message.zEntriesSpec != null && message.hasOwnProperty("zEntriesSpec"))
                    object.zEntriesSpec = $root.immudb.schema.EntryTypeSpec.toObject(message.zEntriesSpec, options);
                if (message.sqlEntriesSpec != null && message.hasOwnProperty("sqlEntriesSpec"))
                    object.sqlEntriesSpec = $root.immudb.schema.EntryTypeSpec.toObject(message.sqlEntriesSpec, options);
                return object;
            };

            /**
             * Converts this EntriesSpec to JSON.
             * @function toJSON
             * @memberof immudb.schema.EntriesSpec
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EntriesSpec.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for EntriesSpec
             * @function getTypeUrl
             * @memberof immudb.schema.EntriesSpec
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            EntriesSpec.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.EntriesSpec";
            };

            return EntriesSpec;
        })();

        schema.EntryTypeSpec = (function() {

            /**
             * Properties of an EntryTypeSpec.
             * @memberof immudb.schema
             * @interface IEntryTypeSpec
             * @property {immudb.schema.EntryTypeAction|null} [action] EntryTypeSpec action
             */

            /**
             * Constructs a new EntryTypeSpec.
             * @memberof immudb.schema
             * @classdesc Represents an EntryTypeSpec.
             * @implements IEntryTypeSpec
             * @constructor
             * @param {immudb.schema.IEntryTypeSpec=} [properties] Properties to set
             */
            function EntryTypeSpec(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EntryTypeSpec action.
             * @member {immudb.schema.EntryTypeAction} action
             * @memberof immudb.schema.EntryTypeSpec
             * @instance
             */
            EntryTypeSpec.prototype.action = 0;

            /**
             * Creates a new EntryTypeSpec instance using the specified properties.
             * @function create
             * @memberof immudb.schema.EntryTypeSpec
             * @static
             * @param {immudb.schema.IEntryTypeSpec=} [properties] Properties to set
             * @returns {immudb.schema.EntryTypeSpec} EntryTypeSpec instance
             */
            EntryTypeSpec.create = function create(properties) {
                return new EntryTypeSpec(properties);
            };

            /**
             * Encodes the specified EntryTypeSpec message. Does not implicitly {@link immudb.schema.EntryTypeSpec.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.EntryTypeSpec
             * @static
             * @param {immudb.schema.IEntryTypeSpec} message EntryTypeSpec message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EntryTypeSpec.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.action);
                return writer;
            };

            /**
             * Encodes the specified EntryTypeSpec message, length delimited. Does not implicitly {@link immudb.schema.EntryTypeSpec.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.EntryTypeSpec
             * @static
             * @param {immudb.schema.IEntryTypeSpec} message EntryTypeSpec message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EntryTypeSpec.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EntryTypeSpec message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.EntryTypeSpec
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.EntryTypeSpec} EntryTypeSpec
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EntryTypeSpec.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.EntryTypeSpec();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.action = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EntryTypeSpec message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.EntryTypeSpec
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.EntryTypeSpec} EntryTypeSpec
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EntryTypeSpec.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EntryTypeSpec message.
             * @function verify
             * @memberof immudb.schema.EntryTypeSpec
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EntryTypeSpec.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.action != null && message.hasOwnProperty("action"))
                    switch (message.action) {
                    default:
                        return "action: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                return null;
            };

            /**
             * Creates an EntryTypeSpec message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.EntryTypeSpec
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.EntryTypeSpec} EntryTypeSpec
             */
            EntryTypeSpec.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.EntryTypeSpec)
                    return object;
                let message = new $root.immudb.schema.EntryTypeSpec();
                switch (object.action) {
                default:
                    if (typeof object.action === "number") {
                        message.action = object.action;
                        break;
                    }
                    break;
                case "EXCLUDE":
                case 0:
                    message.action = 0;
                    break;
                case "ONLY_DIGEST":
                case 1:
                    message.action = 1;
                    break;
                case "RAW_VALUE":
                case 2:
                    message.action = 2;
                    break;
                case "RESOLVE":
                case 3:
                    message.action = 3;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from an EntryTypeSpec message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.EntryTypeSpec
             * @static
             * @param {immudb.schema.EntryTypeSpec} message EntryTypeSpec
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EntryTypeSpec.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.action = options.enums === String ? "EXCLUDE" : 0;
                if (message.action != null && message.hasOwnProperty("action"))
                    object.action = options.enums === String ? $root.immudb.schema.EntryTypeAction[message.action] === undefined ? message.action : $root.immudb.schema.EntryTypeAction[message.action] : message.action;
                return object;
            };

            /**
             * Converts this EntryTypeSpec to JSON.
             * @function toJSON
             * @memberof immudb.schema.EntryTypeSpec
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EntryTypeSpec.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for EntryTypeSpec
             * @function getTypeUrl
             * @memberof immudb.schema.EntryTypeSpec
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            EntryTypeSpec.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.EntryTypeSpec";
            };

            return EntryTypeSpec;
        })();

        /**
         * EntryTypeAction enum.
         * @name immudb.schema.EntryTypeAction
         * @enum {number}
         * @property {number} EXCLUDE=0 EXCLUDE value
         * @property {number} ONLY_DIGEST=1 ONLY_DIGEST value
         * @property {number} RAW_VALUE=2 RAW_VALUE value
         * @property {number} RESOLVE=3 RESOLVE value
         */
        schema.EntryTypeAction = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "EXCLUDE"] = 0;
            values[valuesById[1] = "ONLY_DIGEST"] = 1;
            values[valuesById[2] = "RAW_VALUE"] = 2;
            values[valuesById[3] = "RESOLVE"] = 3;
            return values;
        })();

        schema.VerifiableTxRequest = (function() {

            /**
             * Properties of a VerifiableTxRequest.
             * @memberof immudb.schema
             * @interface IVerifiableTxRequest
             * @property {Long|null} [tx] VerifiableTxRequest tx
             * @property {Long|null} [proveSinceTx] VerifiableTxRequest proveSinceTx
             * @property {immudb.schema.IEntriesSpec|null} [entriesSpec] VerifiableTxRequest entriesSpec
             * @property {Long|null} [sinceTx] VerifiableTxRequest sinceTx
             * @property {boolean|null} [noWait] VerifiableTxRequest noWait
             * @property {boolean|null} [keepReferencesUnresolved] VerifiableTxRequest keepReferencesUnresolved
             */

            /**
             * Constructs a new VerifiableTxRequest.
             * @memberof immudb.schema
             * @classdesc Represents a VerifiableTxRequest.
             * @implements IVerifiableTxRequest
             * @constructor
             * @param {immudb.schema.IVerifiableTxRequest=} [properties] Properties to set
             */
            function VerifiableTxRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VerifiableTxRequest tx.
             * @member {Long} tx
             * @memberof immudb.schema.VerifiableTxRequest
             * @instance
             */
            VerifiableTxRequest.prototype.tx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * VerifiableTxRequest proveSinceTx.
             * @member {Long} proveSinceTx
             * @memberof immudb.schema.VerifiableTxRequest
             * @instance
             */
            VerifiableTxRequest.prototype.proveSinceTx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * VerifiableTxRequest entriesSpec.
             * @member {immudb.schema.IEntriesSpec|null|undefined} entriesSpec
             * @memberof immudb.schema.VerifiableTxRequest
             * @instance
             */
            VerifiableTxRequest.prototype.entriesSpec = null;

            /**
             * VerifiableTxRequest sinceTx.
             * @member {Long} sinceTx
             * @memberof immudb.schema.VerifiableTxRequest
             * @instance
             */
            VerifiableTxRequest.prototype.sinceTx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * VerifiableTxRequest noWait.
             * @member {boolean} noWait
             * @memberof immudb.schema.VerifiableTxRequest
             * @instance
             */
            VerifiableTxRequest.prototype.noWait = false;

            /**
             * VerifiableTxRequest keepReferencesUnresolved.
             * @member {boolean} keepReferencesUnresolved
             * @memberof immudb.schema.VerifiableTxRequest
             * @instance
             */
            VerifiableTxRequest.prototype.keepReferencesUnresolved = false;

            /**
             * Creates a new VerifiableTxRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.VerifiableTxRequest
             * @static
             * @param {immudb.schema.IVerifiableTxRequest=} [properties] Properties to set
             * @returns {immudb.schema.VerifiableTxRequest} VerifiableTxRequest instance
             */
            VerifiableTxRequest.create = function create(properties) {
                return new VerifiableTxRequest(properties);
            };

            /**
             * Encodes the specified VerifiableTxRequest message. Does not implicitly {@link immudb.schema.VerifiableTxRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.VerifiableTxRequest
             * @static
             * @param {immudb.schema.IVerifiableTxRequest} message VerifiableTxRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VerifiableTxRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tx != null && Object.hasOwnProperty.call(message, "tx"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.tx);
                if (message.proveSinceTx != null && Object.hasOwnProperty.call(message, "proveSinceTx"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.proveSinceTx);
                if (message.entriesSpec != null && Object.hasOwnProperty.call(message, "entriesSpec"))
                    $root.immudb.schema.EntriesSpec.encode(message.entriesSpec, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.sinceTx != null && Object.hasOwnProperty.call(message, "sinceTx"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.sinceTx);
                if (message.noWait != null && Object.hasOwnProperty.call(message, "noWait"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.noWait);
                if (message.keepReferencesUnresolved != null && Object.hasOwnProperty.call(message, "keepReferencesUnresolved"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.keepReferencesUnresolved);
                return writer;
            };

            /**
             * Encodes the specified VerifiableTxRequest message, length delimited. Does not implicitly {@link immudb.schema.VerifiableTxRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.VerifiableTxRequest
             * @static
             * @param {immudb.schema.IVerifiableTxRequest} message VerifiableTxRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VerifiableTxRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VerifiableTxRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.VerifiableTxRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.VerifiableTxRequest} VerifiableTxRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VerifiableTxRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.VerifiableTxRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.tx = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.proveSinceTx = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.entriesSpec = $root.immudb.schema.EntriesSpec.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.sinceTx = reader.uint64();
                            break;
                        }
                    case 5: {
                            message.noWait = reader.bool();
                            break;
                        }
                    case 6: {
                            message.keepReferencesUnresolved = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VerifiableTxRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.VerifiableTxRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.VerifiableTxRequest} VerifiableTxRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VerifiableTxRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VerifiableTxRequest message.
             * @function verify
             * @memberof immudb.schema.VerifiableTxRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VerifiableTxRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tx != null && message.hasOwnProperty("tx"))
                    if (!$util.isInteger(message.tx) && !(message.tx && $util.isInteger(message.tx.low) && $util.isInteger(message.tx.high)))
                        return "tx: integer|Long expected";
                if (message.proveSinceTx != null && message.hasOwnProperty("proveSinceTx"))
                    if (!$util.isInteger(message.proveSinceTx) && !(message.proveSinceTx && $util.isInteger(message.proveSinceTx.low) && $util.isInteger(message.proveSinceTx.high)))
                        return "proveSinceTx: integer|Long expected";
                if (message.entriesSpec != null && message.hasOwnProperty("entriesSpec")) {
                    let error = $root.immudb.schema.EntriesSpec.verify(message.entriesSpec);
                    if (error)
                        return "entriesSpec." + error;
                }
                if (message.sinceTx != null && message.hasOwnProperty("sinceTx"))
                    if (!$util.isInteger(message.sinceTx) && !(message.sinceTx && $util.isInteger(message.sinceTx.low) && $util.isInteger(message.sinceTx.high)))
                        return "sinceTx: integer|Long expected";
                if (message.noWait != null && message.hasOwnProperty("noWait"))
                    if (typeof message.noWait !== "boolean")
                        return "noWait: boolean expected";
                if (message.keepReferencesUnresolved != null && message.hasOwnProperty("keepReferencesUnresolved"))
                    if (typeof message.keepReferencesUnresolved !== "boolean")
                        return "keepReferencesUnresolved: boolean expected";
                return null;
            };

            /**
             * Creates a VerifiableTxRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.VerifiableTxRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.VerifiableTxRequest} VerifiableTxRequest
             */
            VerifiableTxRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.VerifiableTxRequest)
                    return object;
                let message = new $root.immudb.schema.VerifiableTxRequest();
                if (object.tx != null)
                    if ($util.Long)
                        (message.tx = $util.Long.fromValue(object.tx)).unsigned = true;
                    else if (typeof object.tx === "string")
                        message.tx = parseInt(object.tx, 10);
                    else if (typeof object.tx === "number")
                        message.tx = object.tx;
                    else if (typeof object.tx === "object")
                        message.tx = new $util.LongBits(object.tx.low >>> 0, object.tx.high >>> 0).toNumber(true);
                if (object.proveSinceTx != null)
                    if ($util.Long)
                        (message.proveSinceTx = $util.Long.fromValue(object.proveSinceTx)).unsigned = true;
                    else if (typeof object.proveSinceTx === "string")
                        message.proveSinceTx = parseInt(object.proveSinceTx, 10);
                    else if (typeof object.proveSinceTx === "number")
                        message.proveSinceTx = object.proveSinceTx;
                    else if (typeof object.proveSinceTx === "object")
                        message.proveSinceTx = new $util.LongBits(object.proveSinceTx.low >>> 0, object.proveSinceTx.high >>> 0).toNumber(true);
                if (object.entriesSpec != null) {
                    if (typeof object.entriesSpec !== "object")
                        throw TypeError(".immudb.schema.VerifiableTxRequest.entriesSpec: object expected");
                    message.entriesSpec = $root.immudb.schema.EntriesSpec.fromObject(object.entriesSpec);
                }
                if (object.sinceTx != null)
                    if ($util.Long)
                        (message.sinceTx = $util.Long.fromValue(object.sinceTx)).unsigned = true;
                    else if (typeof object.sinceTx === "string")
                        message.sinceTx = parseInt(object.sinceTx, 10);
                    else if (typeof object.sinceTx === "number")
                        message.sinceTx = object.sinceTx;
                    else if (typeof object.sinceTx === "object")
                        message.sinceTx = new $util.LongBits(object.sinceTx.low >>> 0, object.sinceTx.high >>> 0).toNumber(true);
                if (object.noWait != null)
                    message.noWait = Boolean(object.noWait);
                if (object.keepReferencesUnresolved != null)
                    message.keepReferencesUnresolved = Boolean(object.keepReferencesUnresolved);
                return message;
            };

            /**
             * Creates a plain object from a VerifiableTxRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.VerifiableTxRequest
             * @static
             * @param {immudb.schema.VerifiableTxRequest} message VerifiableTxRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VerifiableTxRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.tx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.tx = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.proveSinceTx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.proveSinceTx = options.longs === String ? "0" : 0;
                    object.entriesSpec = null;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.sinceTx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sinceTx = options.longs === String ? "0" : 0;
                    object.noWait = false;
                    object.keepReferencesUnresolved = false;
                }
                if (message.tx != null && message.hasOwnProperty("tx"))
                    if (typeof message.tx === "number")
                        object.tx = options.longs === String ? String(message.tx) : message.tx;
                    else
                        object.tx = options.longs === String ? $util.Long.prototype.toString.call(message.tx) : options.longs === Number ? new $util.LongBits(message.tx.low >>> 0, message.tx.high >>> 0).toNumber(true) : message.tx;
                if (message.proveSinceTx != null && message.hasOwnProperty("proveSinceTx"))
                    if (typeof message.proveSinceTx === "number")
                        object.proveSinceTx = options.longs === String ? String(message.proveSinceTx) : message.proveSinceTx;
                    else
                        object.proveSinceTx = options.longs === String ? $util.Long.prototype.toString.call(message.proveSinceTx) : options.longs === Number ? new $util.LongBits(message.proveSinceTx.low >>> 0, message.proveSinceTx.high >>> 0).toNumber(true) : message.proveSinceTx;
                if (message.entriesSpec != null && message.hasOwnProperty("entriesSpec"))
                    object.entriesSpec = $root.immudb.schema.EntriesSpec.toObject(message.entriesSpec, options);
                if (message.sinceTx != null && message.hasOwnProperty("sinceTx"))
                    if (typeof message.sinceTx === "number")
                        object.sinceTx = options.longs === String ? String(message.sinceTx) : message.sinceTx;
                    else
                        object.sinceTx = options.longs === String ? $util.Long.prototype.toString.call(message.sinceTx) : options.longs === Number ? new $util.LongBits(message.sinceTx.low >>> 0, message.sinceTx.high >>> 0).toNumber(true) : message.sinceTx;
                if (message.noWait != null && message.hasOwnProperty("noWait"))
                    object.noWait = message.noWait;
                if (message.keepReferencesUnresolved != null && message.hasOwnProperty("keepReferencesUnresolved"))
                    object.keepReferencesUnresolved = message.keepReferencesUnresolved;
                return object;
            };

            /**
             * Converts this VerifiableTxRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.VerifiableTxRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VerifiableTxRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for VerifiableTxRequest
             * @function getTypeUrl
             * @memberof immudb.schema.VerifiableTxRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            VerifiableTxRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.VerifiableTxRequest";
            };

            return VerifiableTxRequest;
        })();

        schema.TxScanRequest = (function() {

            /**
             * Properties of a TxScanRequest.
             * @memberof immudb.schema
             * @interface ITxScanRequest
             * @property {Long|null} [initialTx] TxScanRequest initialTx
             * @property {number|null} [limit] TxScanRequest limit
             * @property {boolean|null} [desc] TxScanRequest desc
             * @property {immudb.schema.IEntriesSpec|null} [entriesSpec] TxScanRequest entriesSpec
             * @property {Long|null} [sinceTx] TxScanRequest sinceTx
             * @property {boolean|null} [noWait] TxScanRequest noWait
             */

            /**
             * Constructs a new TxScanRequest.
             * @memberof immudb.schema
             * @classdesc Represents a TxScanRequest.
             * @implements ITxScanRequest
             * @constructor
             * @param {immudb.schema.ITxScanRequest=} [properties] Properties to set
             */
            function TxScanRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TxScanRequest initialTx.
             * @member {Long} initialTx
             * @memberof immudb.schema.TxScanRequest
             * @instance
             */
            TxScanRequest.prototype.initialTx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * TxScanRequest limit.
             * @member {number} limit
             * @memberof immudb.schema.TxScanRequest
             * @instance
             */
            TxScanRequest.prototype.limit = 0;

            /**
             * TxScanRequest desc.
             * @member {boolean} desc
             * @memberof immudb.schema.TxScanRequest
             * @instance
             */
            TxScanRequest.prototype.desc = false;

            /**
             * TxScanRequest entriesSpec.
             * @member {immudb.schema.IEntriesSpec|null|undefined} entriesSpec
             * @memberof immudb.schema.TxScanRequest
             * @instance
             */
            TxScanRequest.prototype.entriesSpec = null;

            /**
             * TxScanRequest sinceTx.
             * @member {Long} sinceTx
             * @memberof immudb.schema.TxScanRequest
             * @instance
             */
            TxScanRequest.prototype.sinceTx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * TxScanRequest noWait.
             * @member {boolean} noWait
             * @memberof immudb.schema.TxScanRequest
             * @instance
             */
            TxScanRequest.prototype.noWait = false;

            /**
             * Creates a new TxScanRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.TxScanRequest
             * @static
             * @param {immudb.schema.ITxScanRequest=} [properties] Properties to set
             * @returns {immudb.schema.TxScanRequest} TxScanRequest instance
             */
            TxScanRequest.create = function create(properties) {
                return new TxScanRequest(properties);
            };

            /**
             * Encodes the specified TxScanRequest message. Does not implicitly {@link immudb.schema.TxScanRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.TxScanRequest
             * @static
             * @param {immudb.schema.ITxScanRequest} message TxScanRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxScanRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.initialTx != null && Object.hasOwnProperty.call(message, "initialTx"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.initialTx);
                if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.limit);
                if (message.desc != null && Object.hasOwnProperty.call(message, "desc"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.desc);
                if (message.entriesSpec != null && Object.hasOwnProperty.call(message, "entriesSpec"))
                    $root.immudb.schema.EntriesSpec.encode(message.entriesSpec, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.sinceTx != null && Object.hasOwnProperty.call(message, "sinceTx"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.sinceTx);
                if (message.noWait != null && Object.hasOwnProperty.call(message, "noWait"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.noWait);
                return writer;
            };

            /**
             * Encodes the specified TxScanRequest message, length delimited. Does not implicitly {@link immudb.schema.TxScanRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.TxScanRequest
             * @static
             * @param {immudb.schema.ITxScanRequest} message TxScanRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxScanRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TxScanRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.TxScanRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.TxScanRequest} TxScanRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxScanRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.TxScanRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.initialTx = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.limit = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.desc = reader.bool();
                            break;
                        }
                    case 4: {
                            message.entriesSpec = $root.immudb.schema.EntriesSpec.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.sinceTx = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.noWait = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TxScanRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.TxScanRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.TxScanRequest} TxScanRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxScanRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TxScanRequest message.
             * @function verify
             * @memberof immudb.schema.TxScanRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TxScanRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.initialTx != null && message.hasOwnProperty("initialTx"))
                    if (!$util.isInteger(message.initialTx) && !(message.initialTx && $util.isInteger(message.initialTx.low) && $util.isInteger(message.initialTx.high)))
                        return "initialTx: integer|Long expected";
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (!$util.isInteger(message.limit))
                        return "limit: integer expected";
                if (message.desc != null && message.hasOwnProperty("desc"))
                    if (typeof message.desc !== "boolean")
                        return "desc: boolean expected";
                if (message.entriesSpec != null && message.hasOwnProperty("entriesSpec")) {
                    let error = $root.immudb.schema.EntriesSpec.verify(message.entriesSpec);
                    if (error)
                        return "entriesSpec." + error;
                }
                if (message.sinceTx != null && message.hasOwnProperty("sinceTx"))
                    if (!$util.isInteger(message.sinceTx) && !(message.sinceTx && $util.isInteger(message.sinceTx.low) && $util.isInteger(message.sinceTx.high)))
                        return "sinceTx: integer|Long expected";
                if (message.noWait != null && message.hasOwnProperty("noWait"))
                    if (typeof message.noWait !== "boolean")
                        return "noWait: boolean expected";
                return null;
            };

            /**
             * Creates a TxScanRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.TxScanRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.TxScanRequest} TxScanRequest
             */
            TxScanRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.TxScanRequest)
                    return object;
                let message = new $root.immudb.schema.TxScanRequest();
                if (object.initialTx != null)
                    if ($util.Long)
                        (message.initialTx = $util.Long.fromValue(object.initialTx)).unsigned = true;
                    else if (typeof object.initialTx === "string")
                        message.initialTx = parseInt(object.initialTx, 10);
                    else if (typeof object.initialTx === "number")
                        message.initialTx = object.initialTx;
                    else if (typeof object.initialTx === "object")
                        message.initialTx = new $util.LongBits(object.initialTx.low >>> 0, object.initialTx.high >>> 0).toNumber(true);
                if (object.limit != null)
                    message.limit = object.limit >>> 0;
                if (object.desc != null)
                    message.desc = Boolean(object.desc);
                if (object.entriesSpec != null) {
                    if (typeof object.entriesSpec !== "object")
                        throw TypeError(".immudb.schema.TxScanRequest.entriesSpec: object expected");
                    message.entriesSpec = $root.immudb.schema.EntriesSpec.fromObject(object.entriesSpec);
                }
                if (object.sinceTx != null)
                    if ($util.Long)
                        (message.sinceTx = $util.Long.fromValue(object.sinceTx)).unsigned = true;
                    else if (typeof object.sinceTx === "string")
                        message.sinceTx = parseInt(object.sinceTx, 10);
                    else if (typeof object.sinceTx === "number")
                        message.sinceTx = object.sinceTx;
                    else if (typeof object.sinceTx === "object")
                        message.sinceTx = new $util.LongBits(object.sinceTx.low >>> 0, object.sinceTx.high >>> 0).toNumber(true);
                if (object.noWait != null)
                    message.noWait = Boolean(object.noWait);
                return message;
            };

            /**
             * Creates a plain object from a TxScanRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.TxScanRequest
             * @static
             * @param {immudb.schema.TxScanRequest} message TxScanRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TxScanRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.initialTx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.initialTx = options.longs === String ? "0" : 0;
                    object.limit = 0;
                    object.desc = false;
                    object.entriesSpec = null;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.sinceTx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sinceTx = options.longs === String ? "0" : 0;
                    object.noWait = false;
                }
                if (message.initialTx != null && message.hasOwnProperty("initialTx"))
                    if (typeof message.initialTx === "number")
                        object.initialTx = options.longs === String ? String(message.initialTx) : message.initialTx;
                    else
                        object.initialTx = options.longs === String ? $util.Long.prototype.toString.call(message.initialTx) : options.longs === Number ? new $util.LongBits(message.initialTx.low >>> 0, message.initialTx.high >>> 0).toNumber(true) : message.initialTx;
                if (message.limit != null && message.hasOwnProperty("limit"))
                    object.limit = message.limit;
                if (message.desc != null && message.hasOwnProperty("desc"))
                    object.desc = message.desc;
                if (message.entriesSpec != null && message.hasOwnProperty("entriesSpec"))
                    object.entriesSpec = $root.immudb.schema.EntriesSpec.toObject(message.entriesSpec, options);
                if (message.sinceTx != null && message.hasOwnProperty("sinceTx"))
                    if (typeof message.sinceTx === "number")
                        object.sinceTx = options.longs === String ? String(message.sinceTx) : message.sinceTx;
                    else
                        object.sinceTx = options.longs === String ? $util.Long.prototype.toString.call(message.sinceTx) : options.longs === Number ? new $util.LongBits(message.sinceTx.low >>> 0, message.sinceTx.high >>> 0).toNumber(true) : message.sinceTx;
                if (message.noWait != null && message.hasOwnProperty("noWait"))
                    object.noWait = message.noWait;
                return object;
            };

            /**
             * Converts this TxScanRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.TxScanRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TxScanRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TxScanRequest
             * @function getTypeUrl
             * @memberof immudb.schema.TxScanRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TxScanRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.TxScanRequest";
            };

            return TxScanRequest;
        })();

        schema.TxList = (function() {

            /**
             * Properties of a TxList.
             * @memberof immudb.schema
             * @interface ITxList
             * @property {Array.<immudb.schema.ITx>|null} [txs] TxList txs
             */

            /**
             * Constructs a new TxList.
             * @memberof immudb.schema
             * @classdesc Represents a TxList.
             * @implements ITxList
             * @constructor
             * @param {immudb.schema.ITxList=} [properties] Properties to set
             */
            function TxList(properties) {
                this.txs = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TxList txs.
             * @member {Array.<immudb.schema.ITx>} txs
             * @memberof immudb.schema.TxList
             * @instance
             */
            TxList.prototype.txs = $util.emptyArray;

            /**
             * Creates a new TxList instance using the specified properties.
             * @function create
             * @memberof immudb.schema.TxList
             * @static
             * @param {immudb.schema.ITxList=} [properties] Properties to set
             * @returns {immudb.schema.TxList} TxList instance
             */
            TxList.create = function create(properties) {
                return new TxList(properties);
            };

            /**
             * Encodes the specified TxList message. Does not implicitly {@link immudb.schema.TxList.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.TxList
             * @static
             * @param {immudb.schema.ITxList} message TxList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxList.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.txs != null && message.txs.length)
                    for (let i = 0; i < message.txs.length; ++i)
                        $root.immudb.schema.Tx.encode(message.txs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TxList message, length delimited. Does not implicitly {@link immudb.schema.TxList.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.TxList
             * @static
             * @param {immudb.schema.ITxList} message TxList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxList.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TxList message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.TxList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.TxList} TxList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxList.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.TxList();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.txs && message.txs.length))
                                message.txs = [];
                            message.txs.push($root.immudb.schema.Tx.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TxList message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.TxList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.TxList} TxList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxList.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TxList message.
             * @function verify
             * @memberof immudb.schema.TxList
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TxList.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.txs != null && message.hasOwnProperty("txs")) {
                    if (!Array.isArray(message.txs))
                        return "txs: array expected";
                    for (let i = 0; i < message.txs.length; ++i) {
                        let error = $root.immudb.schema.Tx.verify(message.txs[i]);
                        if (error)
                            return "txs." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a TxList message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.TxList
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.TxList} TxList
             */
            TxList.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.TxList)
                    return object;
                let message = new $root.immudb.schema.TxList();
                if (object.txs) {
                    if (!Array.isArray(object.txs))
                        throw TypeError(".immudb.schema.TxList.txs: array expected");
                    message.txs = [];
                    for (let i = 0; i < object.txs.length; ++i) {
                        if (typeof object.txs[i] !== "object")
                            throw TypeError(".immudb.schema.TxList.txs: object expected");
                        message.txs[i] = $root.immudb.schema.Tx.fromObject(object.txs[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a TxList message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.TxList
             * @static
             * @param {immudb.schema.TxList} message TxList
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TxList.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.txs = [];
                if (message.txs && message.txs.length) {
                    object.txs = [];
                    for (let j = 0; j < message.txs.length; ++j)
                        object.txs[j] = $root.immudb.schema.Tx.toObject(message.txs[j], options);
                }
                return object;
            };

            /**
             * Converts this TxList to JSON.
             * @function toJSON
             * @memberof immudb.schema.TxList
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TxList.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TxList
             * @function getTypeUrl
             * @memberof immudb.schema.TxList
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TxList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.TxList";
            };

            return TxList;
        })();

        schema.ExportTxRequest = (function() {

            /**
             * Properties of an ExportTxRequest.
             * @memberof immudb.schema
             * @interface IExportTxRequest
             * @property {Long|null} [tx] ExportTxRequest tx
             */

            /**
             * Constructs a new ExportTxRequest.
             * @memberof immudb.schema
             * @classdesc Represents an ExportTxRequest.
             * @implements IExportTxRequest
             * @constructor
             * @param {immudb.schema.IExportTxRequest=} [properties] Properties to set
             */
            function ExportTxRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExportTxRequest tx.
             * @member {Long} tx
             * @memberof immudb.schema.ExportTxRequest
             * @instance
             */
            ExportTxRequest.prototype.tx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new ExportTxRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.ExportTxRequest
             * @static
             * @param {immudb.schema.IExportTxRequest=} [properties] Properties to set
             * @returns {immudb.schema.ExportTxRequest} ExportTxRequest instance
             */
            ExportTxRequest.create = function create(properties) {
                return new ExportTxRequest(properties);
            };

            /**
             * Encodes the specified ExportTxRequest message. Does not implicitly {@link immudb.schema.ExportTxRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.ExportTxRequest
             * @static
             * @param {immudb.schema.IExportTxRequest} message ExportTxRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExportTxRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tx != null && Object.hasOwnProperty.call(message, "tx"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.tx);
                return writer;
            };

            /**
             * Encodes the specified ExportTxRequest message, length delimited. Does not implicitly {@link immudb.schema.ExportTxRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.ExportTxRequest
             * @static
             * @param {immudb.schema.IExportTxRequest} message ExportTxRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExportTxRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExportTxRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.ExportTxRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.ExportTxRequest} ExportTxRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExportTxRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.ExportTxRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.tx = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExportTxRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.ExportTxRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.ExportTxRequest} ExportTxRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExportTxRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExportTxRequest message.
             * @function verify
             * @memberof immudb.schema.ExportTxRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExportTxRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tx != null && message.hasOwnProperty("tx"))
                    if (!$util.isInteger(message.tx) && !(message.tx && $util.isInteger(message.tx.low) && $util.isInteger(message.tx.high)))
                        return "tx: integer|Long expected";
                return null;
            };

            /**
             * Creates an ExportTxRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.ExportTxRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.ExportTxRequest} ExportTxRequest
             */
            ExportTxRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.ExportTxRequest)
                    return object;
                let message = new $root.immudb.schema.ExportTxRequest();
                if (object.tx != null)
                    if ($util.Long)
                        (message.tx = $util.Long.fromValue(object.tx)).unsigned = true;
                    else if (typeof object.tx === "string")
                        message.tx = parseInt(object.tx, 10);
                    else if (typeof object.tx === "number")
                        message.tx = object.tx;
                    else if (typeof object.tx === "object")
                        message.tx = new $util.LongBits(object.tx.low >>> 0, object.tx.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from an ExportTxRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.ExportTxRequest
             * @static
             * @param {immudb.schema.ExportTxRequest} message ExportTxRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExportTxRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.tx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.tx = options.longs === String ? "0" : 0;
                if (message.tx != null && message.hasOwnProperty("tx"))
                    if (typeof message.tx === "number")
                        object.tx = options.longs === String ? String(message.tx) : message.tx;
                    else
                        object.tx = options.longs === String ? $util.Long.prototype.toString.call(message.tx) : options.longs === Number ? new $util.LongBits(message.tx.low >>> 0, message.tx.high >>> 0).toNumber(true) : message.tx;
                return object;
            };

            /**
             * Converts this ExportTxRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.ExportTxRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExportTxRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ExportTxRequest
             * @function getTypeUrl
             * @memberof immudb.schema.ExportTxRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ExportTxRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.ExportTxRequest";
            };

            return ExportTxRequest;
        })();

        schema.Database = (function() {

            /**
             * Properties of a Database.
             * @memberof immudb.schema
             * @interface IDatabase
             * @property {string|null} [databaseName] Database databaseName
             */

            /**
             * Constructs a new Database.
             * @memberof immudb.schema
             * @classdesc Represents a Database.
             * @implements IDatabase
             * @constructor
             * @param {immudb.schema.IDatabase=} [properties] Properties to set
             */
            function Database(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Database databaseName.
             * @member {string} databaseName
             * @memberof immudb.schema.Database
             * @instance
             */
            Database.prototype.databaseName = "";

            /**
             * Creates a new Database instance using the specified properties.
             * @function create
             * @memberof immudb.schema.Database
             * @static
             * @param {immudb.schema.IDatabase=} [properties] Properties to set
             * @returns {immudb.schema.Database} Database instance
             */
            Database.create = function create(properties) {
                return new Database(properties);
            };

            /**
             * Encodes the specified Database message. Does not implicitly {@link immudb.schema.Database.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.Database
             * @static
             * @param {immudb.schema.IDatabase} message Database message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Database.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.databaseName != null && Object.hasOwnProperty.call(message, "databaseName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.databaseName);
                return writer;
            };

            /**
             * Encodes the specified Database message, length delimited. Does not implicitly {@link immudb.schema.Database.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.Database
             * @static
             * @param {immudb.schema.IDatabase} message Database message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Database.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Database message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.Database
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.Database} Database
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Database.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.Database();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.databaseName = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Database message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.Database
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.Database} Database
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Database.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Database message.
             * @function verify
             * @memberof immudb.schema.Database
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Database.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.databaseName != null && message.hasOwnProperty("databaseName"))
                    if (!$util.isString(message.databaseName))
                        return "databaseName: string expected";
                return null;
            };

            /**
             * Creates a Database message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.Database
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.Database} Database
             */
            Database.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.Database)
                    return object;
                let message = new $root.immudb.schema.Database();
                if (object.databaseName != null)
                    message.databaseName = String(object.databaseName);
                return message;
            };

            /**
             * Creates a plain object from a Database message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.Database
             * @static
             * @param {immudb.schema.Database} message Database
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Database.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.databaseName = "";
                if (message.databaseName != null && message.hasOwnProperty("databaseName"))
                    object.databaseName = message.databaseName;
                return object;
            };

            /**
             * Converts this Database to JSON.
             * @function toJSON
             * @memberof immudb.schema.Database
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Database.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Database
             * @function getTypeUrl
             * @memberof immudb.schema.Database
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Database.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.Database";
            };

            return Database;
        })();

        schema.DatabaseSettings = (function() {

            /**
             * Properties of a DatabaseSettings.
             * @memberof immudb.schema
             * @interface IDatabaseSettings
             * @property {string|null} [databaseName] DatabaseSettings databaseName
             * @property {boolean|null} [replica] DatabaseSettings replica
             * @property {string|null} [masterDatabase] DatabaseSettings masterDatabase
             * @property {string|null} [masterAddress] DatabaseSettings masterAddress
             * @property {number|null} [masterPort] DatabaseSettings masterPort
             * @property {string|null} [followerUsername] DatabaseSettings followerUsername
             * @property {string|null} [followerPassword] DatabaseSettings followerPassword
             * @property {number|null} [fileSize] DatabaseSettings fileSize
             * @property {number|null} [maxKeyLen] DatabaseSettings maxKeyLen
             * @property {number|null} [maxValueLen] DatabaseSettings maxValueLen
             * @property {number|null} [maxTxEntries] DatabaseSettings maxTxEntries
             * @property {boolean|null} [excludeCommitTime] DatabaseSettings excludeCommitTime
             */

            /**
             * Constructs a new DatabaseSettings.
             * @memberof immudb.schema
             * @classdesc Represents a DatabaseSettings.
             * @implements IDatabaseSettings
             * @constructor
             * @param {immudb.schema.IDatabaseSettings=} [properties] Properties to set
             */
            function DatabaseSettings(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DatabaseSettings databaseName.
             * @member {string} databaseName
             * @memberof immudb.schema.DatabaseSettings
             * @instance
             */
            DatabaseSettings.prototype.databaseName = "";

            /**
             * DatabaseSettings replica.
             * @member {boolean} replica
             * @memberof immudb.schema.DatabaseSettings
             * @instance
             */
            DatabaseSettings.prototype.replica = false;

            /**
             * DatabaseSettings masterDatabase.
             * @member {string} masterDatabase
             * @memberof immudb.schema.DatabaseSettings
             * @instance
             */
            DatabaseSettings.prototype.masterDatabase = "";

            /**
             * DatabaseSettings masterAddress.
             * @member {string} masterAddress
             * @memberof immudb.schema.DatabaseSettings
             * @instance
             */
            DatabaseSettings.prototype.masterAddress = "";

            /**
             * DatabaseSettings masterPort.
             * @member {number} masterPort
             * @memberof immudb.schema.DatabaseSettings
             * @instance
             */
            DatabaseSettings.prototype.masterPort = 0;

            /**
             * DatabaseSettings followerUsername.
             * @member {string} followerUsername
             * @memberof immudb.schema.DatabaseSettings
             * @instance
             */
            DatabaseSettings.prototype.followerUsername = "";

            /**
             * DatabaseSettings followerPassword.
             * @member {string} followerPassword
             * @memberof immudb.schema.DatabaseSettings
             * @instance
             */
            DatabaseSettings.prototype.followerPassword = "";

            /**
             * DatabaseSettings fileSize.
             * @member {number} fileSize
             * @memberof immudb.schema.DatabaseSettings
             * @instance
             */
            DatabaseSettings.prototype.fileSize = 0;

            /**
             * DatabaseSettings maxKeyLen.
             * @member {number} maxKeyLen
             * @memberof immudb.schema.DatabaseSettings
             * @instance
             */
            DatabaseSettings.prototype.maxKeyLen = 0;

            /**
             * DatabaseSettings maxValueLen.
             * @member {number} maxValueLen
             * @memberof immudb.schema.DatabaseSettings
             * @instance
             */
            DatabaseSettings.prototype.maxValueLen = 0;

            /**
             * DatabaseSettings maxTxEntries.
             * @member {number} maxTxEntries
             * @memberof immudb.schema.DatabaseSettings
             * @instance
             */
            DatabaseSettings.prototype.maxTxEntries = 0;

            /**
             * DatabaseSettings excludeCommitTime.
             * @member {boolean} excludeCommitTime
             * @memberof immudb.schema.DatabaseSettings
             * @instance
             */
            DatabaseSettings.prototype.excludeCommitTime = false;

            /**
             * Creates a new DatabaseSettings instance using the specified properties.
             * @function create
             * @memberof immudb.schema.DatabaseSettings
             * @static
             * @param {immudb.schema.IDatabaseSettings=} [properties] Properties to set
             * @returns {immudb.schema.DatabaseSettings} DatabaseSettings instance
             */
            DatabaseSettings.create = function create(properties) {
                return new DatabaseSettings(properties);
            };

            /**
             * Encodes the specified DatabaseSettings message. Does not implicitly {@link immudb.schema.DatabaseSettings.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.DatabaseSettings
             * @static
             * @param {immudb.schema.IDatabaseSettings} message DatabaseSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DatabaseSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.databaseName != null && Object.hasOwnProperty.call(message, "databaseName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.databaseName);
                if (message.replica != null && Object.hasOwnProperty.call(message, "replica"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.replica);
                if (message.masterDatabase != null && Object.hasOwnProperty.call(message, "masterDatabase"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.masterDatabase);
                if (message.masterAddress != null && Object.hasOwnProperty.call(message, "masterAddress"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.masterAddress);
                if (message.masterPort != null && Object.hasOwnProperty.call(message, "masterPort"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.masterPort);
                if (message.followerUsername != null && Object.hasOwnProperty.call(message, "followerUsername"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.followerUsername);
                if (message.followerPassword != null && Object.hasOwnProperty.call(message, "followerPassword"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.followerPassword);
                if (message.fileSize != null && Object.hasOwnProperty.call(message, "fileSize"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.fileSize);
                if (message.maxKeyLen != null && Object.hasOwnProperty.call(message, "maxKeyLen"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.maxKeyLen);
                if (message.maxValueLen != null && Object.hasOwnProperty.call(message, "maxValueLen"))
                    writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.maxValueLen);
                if (message.maxTxEntries != null && Object.hasOwnProperty.call(message, "maxTxEntries"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.maxTxEntries);
                if (message.excludeCommitTime != null && Object.hasOwnProperty.call(message, "excludeCommitTime"))
                    writer.uint32(/* id 12, wireType 0 =*/96).bool(message.excludeCommitTime);
                return writer;
            };

            /**
             * Encodes the specified DatabaseSettings message, length delimited. Does not implicitly {@link immudb.schema.DatabaseSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.DatabaseSettings
             * @static
             * @param {immudb.schema.IDatabaseSettings} message DatabaseSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DatabaseSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DatabaseSettings message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.DatabaseSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.DatabaseSettings} DatabaseSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DatabaseSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.DatabaseSettings();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.databaseName = reader.string();
                            break;
                        }
                    case 2: {
                            message.replica = reader.bool();
                            break;
                        }
                    case 3: {
                            message.masterDatabase = reader.string();
                            break;
                        }
                    case 4: {
                            message.masterAddress = reader.string();
                            break;
                        }
                    case 5: {
                            message.masterPort = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.followerUsername = reader.string();
                            break;
                        }
                    case 7: {
                            message.followerPassword = reader.string();
                            break;
                        }
                    case 8: {
                            message.fileSize = reader.uint32();
                            break;
                        }
                    case 9: {
                            message.maxKeyLen = reader.uint32();
                            break;
                        }
                    case 10: {
                            message.maxValueLen = reader.uint32();
                            break;
                        }
                    case 11: {
                            message.maxTxEntries = reader.uint32();
                            break;
                        }
                    case 12: {
                            message.excludeCommitTime = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DatabaseSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.DatabaseSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.DatabaseSettings} DatabaseSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DatabaseSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DatabaseSettings message.
             * @function verify
             * @memberof immudb.schema.DatabaseSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DatabaseSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.databaseName != null && message.hasOwnProperty("databaseName"))
                    if (!$util.isString(message.databaseName))
                        return "databaseName: string expected";
                if (message.replica != null && message.hasOwnProperty("replica"))
                    if (typeof message.replica !== "boolean")
                        return "replica: boolean expected";
                if (message.masterDatabase != null && message.hasOwnProperty("masterDatabase"))
                    if (!$util.isString(message.masterDatabase))
                        return "masterDatabase: string expected";
                if (message.masterAddress != null && message.hasOwnProperty("masterAddress"))
                    if (!$util.isString(message.masterAddress))
                        return "masterAddress: string expected";
                if (message.masterPort != null && message.hasOwnProperty("masterPort"))
                    if (!$util.isInteger(message.masterPort))
                        return "masterPort: integer expected";
                if (message.followerUsername != null && message.hasOwnProperty("followerUsername"))
                    if (!$util.isString(message.followerUsername))
                        return "followerUsername: string expected";
                if (message.followerPassword != null && message.hasOwnProperty("followerPassword"))
                    if (!$util.isString(message.followerPassword))
                        return "followerPassword: string expected";
                if (message.fileSize != null && message.hasOwnProperty("fileSize"))
                    if (!$util.isInteger(message.fileSize))
                        return "fileSize: integer expected";
                if (message.maxKeyLen != null && message.hasOwnProperty("maxKeyLen"))
                    if (!$util.isInteger(message.maxKeyLen))
                        return "maxKeyLen: integer expected";
                if (message.maxValueLen != null && message.hasOwnProperty("maxValueLen"))
                    if (!$util.isInteger(message.maxValueLen))
                        return "maxValueLen: integer expected";
                if (message.maxTxEntries != null && message.hasOwnProperty("maxTxEntries"))
                    if (!$util.isInteger(message.maxTxEntries))
                        return "maxTxEntries: integer expected";
                if (message.excludeCommitTime != null && message.hasOwnProperty("excludeCommitTime"))
                    if (typeof message.excludeCommitTime !== "boolean")
                        return "excludeCommitTime: boolean expected";
                return null;
            };

            /**
             * Creates a DatabaseSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.DatabaseSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.DatabaseSettings} DatabaseSettings
             */
            DatabaseSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.DatabaseSettings)
                    return object;
                let message = new $root.immudb.schema.DatabaseSettings();
                if (object.databaseName != null)
                    message.databaseName = String(object.databaseName);
                if (object.replica != null)
                    message.replica = Boolean(object.replica);
                if (object.masterDatabase != null)
                    message.masterDatabase = String(object.masterDatabase);
                if (object.masterAddress != null)
                    message.masterAddress = String(object.masterAddress);
                if (object.masterPort != null)
                    message.masterPort = object.masterPort >>> 0;
                if (object.followerUsername != null)
                    message.followerUsername = String(object.followerUsername);
                if (object.followerPassword != null)
                    message.followerPassword = String(object.followerPassword);
                if (object.fileSize != null)
                    message.fileSize = object.fileSize >>> 0;
                if (object.maxKeyLen != null)
                    message.maxKeyLen = object.maxKeyLen >>> 0;
                if (object.maxValueLen != null)
                    message.maxValueLen = object.maxValueLen >>> 0;
                if (object.maxTxEntries != null)
                    message.maxTxEntries = object.maxTxEntries >>> 0;
                if (object.excludeCommitTime != null)
                    message.excludeCommitTime = Boolean(object.excludeCommitTime);
                return message;
            };

            /**
             * Creates a plain object from a DatabaseSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.DatabaseSettings
             * @static
             * @param {immudb.schema.DatabaseSettings} message DatabaseSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DatabaseSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.databaseName = "";
                    object.replica = false;
                    object.masterDatabase = "";
                    object.masterAddress = "";
                    object.masterPort = 0;
                    object.followerUsername = "";
                    object.followerPassword = "";
                    object.fileSize = 0;
                    object.maxKeyLen = 0;
                    object.maxValueLen = 0;
                    object.maxTxEntries = 0;
                    object.excludeCommitTime = false;
                }
                if (message.databaseName != null && message.hasOwnProperty("databaseName"))
                    object.databaseName = message.databaseName;
                if (message.replica != null && message.hasOwnProperty("replica"))
                    object.replica = message.replica;
                if (message.masterDatabase != null && message.hasOwnProperty("masterDatabase"))
                    object.masterDatabase = message.masterDatabase;
                if (message.masterAddress != null && message.hasOwnProperty("masterAddress"))
                    object.masterAddress = message.masterAddress;
                if (message.masterPort != null && message.hasOwnProperty("masterPort"))
                    object.masterPort = message.masterPort;
                if (message.followerUsername != null && message.hasOwnProperty("followerUsername"))
                    object.followerUsername = message.followerUsername;
                if (message.followerPassword != null && message.hasOwnProperty("followerPassword"))
                    object.followerPassword = message.followerPassword;
                if (message.fileSize != null && message.hasOwnProperty("fileSize"))
                    object.fileSize = message.fileSize;
                if (message.maxKeyLen != null && message.hasOwnProperty("maxKeyLen"))
                    object.maxKeyLen = message.maxKeyLen;
                if (message.maxValueLen != null && message.hasOwnProperty("maxValueLen"))
                    object.maxValueLen = message.maxValueLen;
                if (message.maxTxEntries != null && message.hasOwnProperty("maxTxEntries"))
                    object.maxTxEntries = message.maxTxEntries;
                if (message.excludeCommitTime != null && message.hasOwnProperty("excludeCommitTime"))
                    object.excludeCommitTime = message.excludeCommitTime;
                return object;
            };

            /**
             * Converts this DatabaseSettings to JSON.
             * @function toJSON
             * @memberof immudb.schema.DatabaseSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DatabaseSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DatabaseSettings
             * @function getTypeUrl
             * @memberof immudb.schema.DatabaseSettings
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DatabaseSettings.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.DatabaseSettings";
            };

            return DatabaseSettings;
        })();

        schema.CreateDatabaseRequest = (function() {

            /**
             * Properties of a CreateDatabaseRequest.
             * @memberof immudb.schema
             * @interface ICreateDatabaseRequest
             * @property {string|null} [name] CreateDatabaseRequest name
             * @property {immudb.schema.IDatabaseNullableSettings|null} [settings] CreateDatabaseRequest settings
             * @property {boolean|null} [ifNotExists] CreateDatabaseRequest ifNotExists
             */

            /**
             * Constructs a new CreateDatabaseRequest.
             * @memberof immudb.schema
             * @classdesc Represents a CreateDatabaseRequest.
             * @implements ICreateDatabaseRequest
             * @constructor
             * @param {immudb.schema.ICreateDatabaseRequest=} [properties] Properties to set
             */
            function CreateDatabaseRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateDatabaseRequest name.
             * @member {string} name
             * @memberof immudb.schema.CreateDatabaseRequest
             * @instance
             */
            CreateDatabaseRequest.prototype.name = "";

            /**
             * CreateDatabaseRequest settings.
             * @member {immudb.schema.IDatabaseNullableSettings|null|undefined} settings
             * @memberof immudb.schema.CreateDatabaseRequest
             * @instance
             */
            CreateDatabaseRequest.prototype.settings = null;

            /**
             * CreateDatabaseRequest ifNotExists.
             * @member {boolean} ifNotExists
             * @memberof immudb.schema.CreateDatabaseRequest
             * @instance
             */
            CreateDatabaseRequest.prototype.ifNotExists = false;

            /**
             * Creates a new CreateDatabaseRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.CreateDatabaseRequest
             * @static
             * @param {immudb.schema.ICreateDatabaseRequest=} [properties] Properties to set
             * @returns {immudb.schema.CreateDatabaseRequest} CreateDatabaseRequest instance
             */
            CreateDatabaseRequest.create = function create(properties) {
                return new CreateDatabaseRequest(properties);
            };

            /**
             * Encodes the specified CreateDatabaseRequest message. Does not implicitly {@link immudb.schema.CreateDatabaseRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.CreateDatabaseRequest
             * @static
             * @param {immudb.schema.ICreateDatabaseRequest} message CreateDatabaseRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateDatabaseRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.settings != null && Object.hasOwnProperty.call(message, "settings"))
                    $root.immudb.schema.DatabaseNullableSettings.encode(message.settings, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.ifNotExists != null && Object.hasOwnProperty.call(message, "ifNotExists"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.ifNotExists);
                return writer;
            };

            /**
             * Encodes the specified CreateDatabaseRequest message, length delimited. Does not implicitly {@link immudb.schema.CreateDatabaseRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.CreateDatabaseRequest
             * @static
             * @param {immudb.schema.ICreateDatabaseRequest} message CreateDatabaseRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateDatabaseRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateDatabaseRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.CreateDatabaseRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.CreateDatabaseRequest} CreateDatabaseRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateDatabaseRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.CreateDatabaseRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.settings = $root.immudb.schema.DatabaseNullableSettings.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.ifNotExists = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateDatabaseRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.CreateDatabaseRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.CreateDatabaseRequest} CreateDatabaseRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateDatabaseRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateDatabaseRequest message.
             * @function verify
             * @memberof immudb.schema.CreateDatabaseRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateDatabaseRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.settings != null && message.hasOwnProperty("settings")) {
                    let error = $root.immudb.schema.DatabaseNullableSettings.verify(message.settings);
                    if (error)
                        return "settings." + error;
                }
                if (message.ifNotExists != null && message.hasOwnProperty("ifNotExists"))
                    if (typeof message.ifNotExists !== "boolean")
                        return "ifNotExists: boolean expected";
                return null;
            };

            /**
             * Creates a CreateDatabaseRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.CreateDatabaseRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.CreateDatabaseRequest} CreateDatabaseRequest
             */
            CreateDatabaseRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.CreateDatabaseRequest)
                    return object;
                let message = new $root.immudb.schema.CreateDatabaseRequest();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.settings != null) {
                    if (typeof object.settings !== "object")
                        throw TypeError(".immudb.schema.CreateDatabaseRequest.settings: object expected");
                    message.settings = $root.immudb.schema.DatabaseNullableSettings.fromObject(object.settings);
                }
                if (object.ifNotExists != null)
                    message.ifNotExists = Boolean(object.ifNotExists);
                return message;
            };

            /**
             * Creates a plain object from a CreateDatabaseRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.CreateDatabaseRequest
             * @static
             * @param {immudb.schema.CreateDatabaseRequest} message CreateDatabaseRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateDatabaseRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.settings = null;
                    object.ifNotExists = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.settings != null && message.hasOwnProperty("settings"))
                    object.settings = $root.immudb.schema.DatabaseNullableSettings.toObject(message.settings, options);
                if (message.ifNotExists != null && message.hasOwnProperty("ifNotExists"))
                    object.ifNotExists = message.ifNotExists;
                return object;
            };

            /**
             * Converts this CreateDatabaseRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.CreateDatabaseRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateDatabaseRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CreateDatabaseRequest
             * @function getTypeUrl
             * @memberof immudb.schema.CreateDatabaseRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CreateDatabaseRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.CreateDatabaseRequest";
            };

            return CreateDatabaseRequest;
        })();

        schema.CreateDatabaseResponse = (function() {

            /**
             * Properties of a CreateDatabaseResponse.
             * @memberof immudb.schema
             * @interface ICreateDatabaseResponse
             * @property {string|null} [name] CreateDatabaseResponse name
             * @property {immudb.schema.IDatabaseNullableSettings|null} [settings] CreateDatabaseResponse settings
             * @property {boolean|null} [alreadyExisted] CreateDatabaseResponse alreadyExisted
             */

            /**
             * Constructs a new CreateDatabaseResponse.
             * @memberof immudb.schema
             * @classdesc Represents a CreateDatabaseResponse.
             * @implements ICreateDatabaseResponse
             * @constructor
             * @param {immudb.schema.ICreateDatabaseResponse=} [properties] Properties to set
             */
            function CreateDatabaseResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateDatabaseResponse name.
             * @member {string} name
             * @memberof immudb.schema.CreateDatabaseResponse
             * @instance
             */
            CreateDatabaseResponse.prototype.name = "";

            /**
             * CreateDatabaseResponse settings.
             * @member {immudb.schema.IDatabaseNullableSettings|null|undefined} settings
             * @memberof immudb.schema.CreateDatabaseResponse
             * @instance
             */
            CreateDatabaseResponse.prototype.settings = null;

            /**
             * CreateDatabaseResponse alreadyExisted.
             * @member {boolean} alreadyExisted
             * @memberof immudb.schema.CreateDatabaseResponse
             * @instance
             */
            CreateDatabaseResponse.prototype.alreadyExisted = false;

            /**
             * Creates a new CreateDatabaseResponse instance using the specified properties.
             * @function create
             * @memberof immudb.schema.CreateDatabaseResponse
             * @static
             * @param {immudb.schema.ICreateDatabaseResponse=} [properties] Properties to set
             * @returns {immudb.schema.CreateDatabaseResponse} CreateDatabaseResponse instance
             */
            CreateDatabaseResponse.create = function create(properties) {
                return new CreateDatabaseResponse(properties);
            };

            /**
             * Encodes the specified CreateDatabaseResponse message. Does not implicitly {@link immudb.schema.CreateDatabaseResponse.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.CreateDatabaseResponse
             * @static
             * @param {immudb.schema.ICreateDatabaseResponse} message CreateDatabaseResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateDatabaseResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.settings != null && Object.hasOwnProperty.call(message, "settings"))
                    $root.immudb.schema.DatabaseNullableSettings.encode(message.settings, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.alreadyExisted != null && Object.hasOwnProperty.call(message, "alreadyExisted"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.alreadyExisted);
                return writer;
            };

            /**
             * Encodes the specified CreateDatabaseResponse message, length delimited. Does not implicitly {@link immudb.schema.CreateDatabaseResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.CreateDatabaseResponse
             * @static
             * @param {immudb.schema.ICreateDatabaseResponse} message CreateDatabaseResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateDatabaseResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateDatabaseResponse message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.CreateDatabaseResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.CreateDatabaseResponse} CreateDatabaseResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateDatabaseResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.CreateDatabaseResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.settings = $root.immudb.schema.DatabaseNullableSettings.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.alreadyExisted = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateDatabaseResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.CreateDatabaseResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.CreateDatabaseResponse} CreateDatabaseResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateDatabaseResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateDatabaseResponse message.
             * @function verify
             * @memberof immudb.schema.CreateDatabaseResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateDatabaseResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.settings != null && message.hasOwnProperty("settings")) {
                    let error = $root.immudb.schema.DatabaseNullableSettings.verify(message.settings);
                    if (error)
                        return "settings." + error;
                }
                if (message.alreadyExisted != null && message.hasOwnProperty("alreadyExisted"))
                    if (typeof message.alreadyExisted !== "boolean")
                        return "alreadyExisted: boolean expected";
                return null;
            };

            /**
             * Creates a CreateDatabaseResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.CreateDatabaseResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.CreateDatabaseResponse} CreateDatabaseResponse
             */
            CreateDatabaseResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.CreateDatabaseResponse)
                    return object;
                let message = new $root.immudb.schema.CreateDatabaseResponse();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.settings != null) {
                    if (typeof object.settings !== "object")
                        throw TypeError(".immudb.schema.CreateDatabaseResponse.settings: object expected");
                    message.settings = $root.immudb.schema.DatabaseNullableSettings.fromObject(object.settings);
                }
                if (object.alreadyExisted != null)
                    message.alreadyExisted = Boolean(object.alreadyExisted);
                return message;
            };

            /**
             * Creates a plain object from a CreateDatabaseResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.CreateDatabaseResponse
             * @static
             * @param {immudb.schema.CreateDatabaseResponse} message CreateDatabaseResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateDatabaseResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.settings = null;
                    object.alreadyExisted = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.settings != null && message.hasOwnProperty("settings"))
                    object.settings = $root.immudb.schema.DatabaseNullableSettings.toObject(message.settings, options);
                if (message.alreadyExisted != null && message.hasOwnProperty("alreadyExisted"))
                    object.alreadyExisted = message.alreadyExisted;
                return object;
            };

            /**
             * Converts this CreateDatabaseResponse to JSON.
             * @function toJSON
             * @memberof immudb.schema.CreateDatabaseResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateDatabaseResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CreateDatabaseResponse
             * @function getTypeUrl
             * @memberof immudb.schema.CreateDatabaseResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CreateDatabaseResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.CreateDatabaseResponse";
            };

            return CreateDatabaseResponse;
        })();

        schema.UpdateDatabaseRequest = (function() {

            /**
             * Properties of an UpdateDatabaseRequest.
             * @memberof immudb.schema
             * @interface IUpdateDatabaseRequest
             * @property {string|null} [database] UpdateDatabaseRequest database
             * @property {immudb.schema.IDatabaseNullableSettings|null} [settings] UpdateDatabaseRequest settings
             */

            /**
             * Constructs a new UpdateDatabaseRequest.
             * @memberof immudb.schema
             * @classdesc Represents an UpdateDatabaseRequest.
             * @implements IUpdateDatabaseRequest
             * @constructor
             * @param {immudb.schema.IUpdateDatabaseRequest=} [properties] Properties to set
             */
            function UpdateDatabaseRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UpdateDatabaseRequest database.
             * @member {string} database
             * @memberof immudb.schema.UpdateDatabaseRequest
             * @instance
             */
            UpdateDatabaseRequest.prototype.database = "";

            /**
             * UpdateDatabaseRequest settings.
             * @member {immudb.schema.IDatabaseNullableSettings|null|undefined} settings
             * @memberof immudb.schema.UpdateDatabaseRequest
             * @instance
             */
            UpdateDatabaseRequest.prototype.settings = null;

            /**
             * Creates a new UpdateDatabaseRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.UpdateDatabaseRequest
             * @static
             * @param {immudb.schema.IUpdateDatabaseRequest=} [properties] Properties to set
             * @returns {immudb.schema.UpdateDatabaseRequest} UpdateDatabaseRequest instance
             */
            UpdateDatabaseRequest.create = function create(properties) {
                return new UpdateDatabaseRequest(properties);
            };

            /**
             * Encodes the specified UpdateDatabaseRequest message. Does not implicitly {@link immudb.schema.UpdateDatabaseRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.UpdateDatabaseRequest
             * @static
             * @param {immudb.schema.IUpdateDatabaseRequest} message UpdateDatabaseRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateDatabaseRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.database);
                if (message.settings != null && Object.hasOwnProperty.call(message, "settings"))
                    $root.immudb.schema.DatabaseNullableSettings.encode(message.settings, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified UpdateDatabaseRequest message, length delimited. Does not implicitly {@link immudb.schema.UpdateDatabaseRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.UpdateDatabaseRequest
             * @static
             * @param {immudb.schema.IUpdateDatabaseRequest} message UpdateDatabaseRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateDatabaseRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UpdateDatabaseRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.UpdateDatabaseRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.UpdateDatabaseRequest} UpdateDatabaseRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateDatabaseRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.UpdateDatabaseRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.database = reader.string();
                            break;
                        }
                    case 2: {
                            message.settings = $root.immudb.schema.DatabaseNullableSettings.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UpdateDatabaseRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.UpdateDatabaseRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.UpdateDatabaseRequest} UpdateDatabaseRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateDatabaseRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UpdateDatabaseRequest message.
             * @function verify
             * @memberof immudb.schema.UpdateDatabaseRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateDatabaseRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isString(message.database))
                        return "database: string expected";
                if (message.settings != null && message.hasOwnProperty("settings")) {
                    let error = $root.immudb.schema.DatabaseNullableSettings.verify(message.settings);
                    if (error)
                        return "settings." + error;
                }
                return null;
            };

            /**
             * Creates an UpdateDatabaseRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.UpdateDatabaseRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.UpdateDatabaseRequest} UpdateDatabaseRequest
             */
            UpdateDatabaseRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.UpdateDatabaseRequest)
                    return object;
                let message = new $root.immudb.schema.UpdateDatabaseRequest();
                if (object.database != null)
                    message.database = String(object.database);
                if (object.settings != null) {
                    if (typeof object.settings !== "object")
                        throw TypeError(".immudb.schema.UpdateDatabaseRequest.settings: object expected");
                    message.settings = $root.immudb.schema.DatabaseNullableSettings.fromObject(object.settings);
                }
                return message;
            };

            /**
             * Creates a plain object from an UpdateDatabaseRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.UpdateDatabaseRequest
             * @static
             * @param {immudb.schema.UpdateDatabaseRequest} message UpdateDatabaseRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateDatabaseRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.database = "";
                    object.settings = null;
                }
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                if (message.settings != null && message.hasOwnProperty("settings"))
                    object.settings = $root.immudb.schema.DatabaseNullableSettings.toObject(message.settings, options);
                return object;
            };

            /**
             * Converts this UpdateDatabaseRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.UpdateDatabaseRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateDatabaseRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UpdateDatabaseRequest
             * @function getTypeUrl
             * @memberof immudb.schema.UpdateDatabaseRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UpdateDatabaseRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.UpdateDatabaseRequest";
            };

            return UpdateDatabaseRequest;
        })();

        schema.UpdateDatabaseResponse = (function() {

            /**
             * Properties of an UpdateDatabaseResponse.
             * @memberof immudb.schema
             * @interface IUpdateDatabaseResponse
             * @property {string|null} [database] UpdateDatabaseResponse database
             * @property {immudb.schema.IDatabaseNullableSettings|null} [settings] UpdateDatabaseResponse settings
             */

            /**
             * Constructs a new UpdateDatabaseResponse.
             * @memberof immudb.schema
             * @classdesc Represents an UpdateDatabaseResponse.
             * @implements IUpdateDatabaseResponse
             * @constructor
             * @param {immudb.schema.IUpdateDatabaseResponse=} [properties] Properties to set
             */
            function UpdateDatabaseResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UpdateDatabaseResponse database.
             * @member {string} database
             * @memberof immudb.schema.UpdateDatabaseResponse
             * @instance
             */
            UpdateDatabaseResponse.prototype.database = "";

            /**
             * UpdateDatabaseResponse settings.
             * @member {immudb.schema.IDatabaseNullableSettings|null|undefined} settings
             * @memberof immudb.schema.UpdateDatabaseResponse
             * @instance
             */
            UpdateDatabaseResponse.prototype.settings = null;

            /**
             * Creates a new UpdateDatabaseResponse instance using the specified properties.
             * @function create
             * @memberof immudb.schema.UpdateDatabaseResponse
             * @static
             * @param {immudb.schema.IUpdateDatabaseResponse=} [properties] Properties to set
             * @returns {immudb.schema.UpdateDatabaseResponse} UpdateDatabaseResponse instance
             */
            UpdateDatabaseResponse.create = function create(properties) {
                return new UpdateDatabaseResponse(properties);
            };

            /**
             * Encodes the specified UpdateDatabaseResponse message. Does not implicitly {@link immudb.schema.UpdateDatabaseResponse.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.UpdateDatabaseResponse
             * @static
             * @param {immudb.schema.IUpdateDatabaseResponse} message UpdateDatabaseResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateDatabaseResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.database);
                if (message.settings != null && Object.hasOwnProperty.call(message, "settings"))
                    $root.immudb.schema.DatabaseNullableSettings.encode(message.settings, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified UpdateDatabaseResponse message, length delimited. Does not implicitly {@link immudb.schema.UpdateDatabaseResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.UpdateDatabaseResponse
             * @static
             * @param {immudb.schema.IUpdateDatabaseResponse} message UpdateDatabaseResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateDatabaseResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UpdateDatabaseResponse message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.UpdateDatabaseResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.UpdateDatabaseResponse} UpdateDatabaseResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateDatabaseResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.UpdateDatabaseResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.database = reader.string();
                            break;
                        }
                    case 2: {
                            message.settings = $root.immudb.schema.DatabaseNullableSettings.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UpdateDatabaseResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.UpdateDatabaseResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.UpdateDatabaseResponse} UpdateDatabaseResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateDatabaseResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UpdateDatabaseResponse message.
             * @function verify
             * @memberof immudb.schema.UpdateDatabaseResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateDatabaseResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isString(message.database))
                        return "database: string expected";
                if (message.settings != null && message.hasOwnProperty("settings")) {
                    let error = $root.immudb.schema.DatabaseNullableSettings.verify(message.settings);
                    if (error)
                        return "settings." + error;
                }
                return null;
            };

            /**
             * Creates an UpdateDatabaseResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.UpdateDatabaseResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.UpdateDatabaseResponse} UpdateDatabaseResponse
             */
            UpdateDatabaseResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.UpdateDatabaseResponse)
                    return object;
                let message = new $root.immudb.schema.UpdateDatabaseResponse();
                if (object.database != null)
                    message.database = String(object.database);
                if (object.settings != null) {
                    if (typeof object.settings !== "object")
                        throw TypeError(".immudb.schema.UpdateDatabaseResponse.settings: object expected");
                    message.settings = $root.immudb.schema.DatabaseNullableSettings.fromObject(object.settings);
                }
                return message;
            };

            /**
             * Creates a plain object from an UpdateDatabaseResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.UpdateDatabaseResponse
             * @static
             * @param {immudb.schema.UpdateDatabaseResponse} message UpdateDatabaseResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateDatabaseResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.database = "";
                    object.settings = null;
                }
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                if (message.settings != null && message.hasOwnProperty("settings"))
                    object.settings = $root.immudb.schema.DatabaseNullableSettings.toObject(message.settings, options);
                return object;
            };

            /**
             * Converts this UpdateDatabaseResponse to JSON.
             * @function toJSON
             * @memberof immudb.schema.UpdateDatabaseResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateDatabaseResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UpdateDatabaseResponse
             * @function getTypeUrl
             * @memberof immudb.schema.UpdateDatabaseResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UpdateDatabaseResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.UpdateDatabaseResponse";
            };

            return UpdateDatabaseResponse;
        })();

        schema.DatabaseSettingsRequest = (function() {

            /**
             * Properties of a DatabaseSettingsRequest.
             * @memberof immudb.schema
             * @interface IDatabaseSettingsRequest
             */

            /**
             * Constructs a new DatabaseSettingsRequest.
             * @memberof immudb.schema
             * @classdesc Represents a DatabaseSettingsRequest.
             * @implements IDatabaseSettingsRequest
             * @constructor
             * @param {immudb.schema.IDatabaseSettingsRequest=} [properties] Properties to set
             */
            function DatabaseSettingsRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new DatabaseSettingsRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.DatabaseSettingsRequest
             * @static
             * @param {immudb.schema.IDatabaseSettingsRequest=} [properties] Properties to set
             * @returns {immudb.schema.DatabaseSettingsRequest} DatabaseSettingsRequest instance
             */
            DatabaseSettingsRequest.create = function create(properties) {
                return new DatabaseSettingsRequest(properties);
            };

            /**
             * Encodes the specified DatabaseSettingsRequest message. Does not implicitly {@link immudb.schema.DatabaseSettingsRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.DatabaseSettingsRequest
             * @static
             * @param {immudb.schema.IDatabaseSettingsRequest} message DatabaseSettingsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DatabaseSettingsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified DatabaseSettingsRequest message, length delimited. Does not implicitly {@link immudb.schema.DatabaseSettingsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.DatabaseSettingsRequest
             * @static
             * @param {immudb.schema.IDatabaseSettingsRequest} message DatabaseSettingsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DatabaseSettingsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DatabaseSettingsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.DatabaseSettingsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.DatabaseSettingsRequest} DatabaseSettingsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DatabaseSettingsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.DatabaseSettingsRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DatabaseSettingsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.DatabaseSettingsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.DatabaseSettingsRequest} DatabaseSettingsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DatabaseSettingsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DatabaseSettingsRequest message.
             * @function verify
             * @memberof immudb.schema.DatabaseSettingsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DatabaseSettingsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a DatabaseSettingsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.DatabaseSettingsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.DatabaseSettingsRequest} DatabaseSettingsRequest
             */
            DatabaseSettingsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.DatabaseSettingsRequest)
                    return object;
                return new $root.immudb.schema.DatabaseSettingsRequest();
            };

            /**
             * Creates a plain object from a DatabaseSettingsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.DatabaseSettingsRequest
             * @static
             * @param {immudb.schema.DatabaseSettingsRequest} message DatabaseSettingsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DatabaseSettingsRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this DatabaseSettingsRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.DatabaseSettingsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DatabaseSettingsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DatabaseSettingsRequest
             * @function getTypeUrl
             * @memberof immudb.schema.DatabaseSettingsRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DatabaseSettingsRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.DatabaseSettingsRequest";
            };

            return DatabaseSettingsRequest;
        })();

        schema.DatabaseSettingsResponse = (function() {

            /**
             * Properties of a DatabaseSettingsResponse.
             * @memberof immudb.schema
             * @interface IDatabaseSettingsResponse
             * @property {string|null} [database] DatabaseSettingsResponse database
             * @property {immudb.schema.IDatabaseNullableSettings|null} [settings] DatabaseSettingsResponse settings
             */

            /**
             * Constructs a new DatabaseSettingsResponse.
             * @memberof immudb.schema
             * @classdesc Represents a DatabaseSettingsResponse.
             * @implements IDatabaseSettingsResponse
             * @constructor
             * @param {immudb.schema.IDatabaseSettingsResponse=} [properties] Properties to set
             */
            function DatabaseSettingsResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DatabaseSettingsResponse database.
             * @member {string} database
             * @memberof immudb.schema.DatabaseSettingsResponse
             * @instance
             */
            DatabaseSettingsResponse.prototype.database = "";

            /**
             * DatabaseSettingsResponse settings.
             * @member {immudb.schema.IDatabaseNullableSettings|null|undefined} settings
             * @memberof immudb.schema.DatabaseSettingsResponse
             * @instance
             */
            DatabaseSettingsResponse.prototype.settings = null;

            /**
             * Creates a new DatabaseSettingsResponse instance using the specified properties.
             * @function create
             * @memberof immudb.schema.DatabaseSettingsResponse
             * @static
             * @param {immudb.schema.IDatabaseSettingsResponse=} [properties] Properties to set
             * @returns {immudb.schema.DatabaseSettingsResponse} DatabaseSettingsResponse instance
             */
            DatabaseSettingsResponse.create = function create(properties) {
                return new DatabaseSettingsResponse(properties);
            };

            /**
             * Encodes the specified DatabaseSettingsResponse message. Does not implicitly {@link immudb.schema.DatabaseSettingsResponse.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.DatabaseSettingsResponse
             * @static
             * @param {immudb.schema.IDatabaseSettingsResponse} message DatabaseSettingsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DatabaseSettingsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.database);
                if (message.settings != null && Object.hasOwnProperty.call(message, "settings"))
                    $root.immudb.schema.DatabaseNullableSettings.encode(message.settings, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DatabaseSettingsResponse message, length delimited. Does not implicitly {@link immudb.schema.DatabaseSettingsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.DatabaseSettingsResponse
             * @static
             * @param {immudb.schema.IDatabaseSettingsResponse} message DatabaseSettingsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DatabaseSettingsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DatabaseSettingsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.DatabaseSettingsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.DatabaseSettingsResponse} DatabaseSettingsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DatabaseSettingsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.DatabaseSettingsResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.database = reader.string();
                            break;
                        }
                    case 2: {
                            message.settings = $root.immudb.schema.DatabaseNullableSettings.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DatabaseSettingsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.DatabaseSettingsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.DatabaseSettingsResponse} DatabaseSettingsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DatabaseSettingsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DatabaseSettingsResponse message.
             * @function verify
             * @memberof immudb.schema.DatabaseSettingsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DatabaseSettingsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isString(message.database))
                        return "database: string expected";
                if (message.settings != null && message.hasOwnProperty("settings")) {
                    let error = $root.immudb.schema.DatabaseNullableSettings.verify(message.settings);
                    if (error)
                        return "settings." + error;
                }
                return null;
            };

            /**
             * Creates a DatabaseSettingsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.DatabaseSettingsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.DatabaseSettingsResponse} DatabaseSettingsResponse
             */
            DatabaseSettingsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.DatabaseSettingsResponse)
                    return object;
                let message = new $root.immudb.schema.DatabaseSettingsResponse();
                if (object.database != null)
                    message.database = String(object.database);
                if (object.settings != null) {
                    if (typeof object.settings !== "object")
                        throw TypeError(".immudb.schema.DatabaseSettingsResponse.settings: object expected");
                    message.settings = $root.immudb.schema.DatabaseNullableSettings.fromObject(object.settings);
                }
                return message;
            };

            /**
             * Creates a plain object from a DatabaseSettingsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.DatabaseSettingsResponse
             * @static
             * @param {immudb.schema.DatabaseSettingsResponse} message DatabaseSettingsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DatabaseSettingsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.database = "";
                    object.settings = null;
                }
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                if (message.settings != null && message.hasOwnProperty("settings"))
                    object.settings = $root.immudb.schema.DatabaseNullableSettings.toObject(message.settings, options);
                return object;
            };

            /**
             * Converts this DatabaseSettingsResponse to JSON.
             * @function toJSON
             * @memberof immudb.schema.DatabaseSettingsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DatabaseSettingsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DatabaseSettingsResponse
             * @function getTypeUrl
             * @memberof immudb.schema.DatabaseSettingsResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DatabaseSettingsResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.DatabaseSettingsResponse";
            };

            return DatabaseSettingsResponse;
        })();

        schema.NullableUint32 = (function() {

            /**
             * Properties of a NullableUint32.
             * @memberof immudb.schema
             * @interface INullableUint32
             * @property {number|null} [value] NullableUint32 value
             */

            /**
             * Constructs a new NullableUint32.
             * @memberof immudb.schema
             * @classdesc Represents a NullableUint32.
             * @implements INullableUint32
             * @constructor
             * @param {immudb.schema.INullableUint32=} [properties] Properties to set
             */
            function NullableUint32(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NullableUint32 value.
             * @member {number} value
             * @memberof immudb.schema.NullableUint32
             * @instance
             */
            NullableUint32.prototype.value = 0;

            /**
             * Creates a new NullableUint32 instance using the specified properties.
             * @function create
             * @memberof immudb.schema.NullableUint32
             * @static
             * @param {immudb.schema.INullableUint32=} [properties] Properties to set
             * @returns {immudb.schema.NullableUint32} NullableUint32 instance
             */
            NullableUint32.create = function create(properties) {
                return new NullableUint32(properties);
            };

            /**
             * Encodes the specified NullableUint32 message. Does not implicitly {@link immudb.schema.NullableUint32.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.NullableUint32
             * @static
             * @param {immudb.schema.INullableUint32} message NullableUint32 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NullableUint32.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.value);
                return writer;
            };

            /**
             * Encodes the specified NullableUint32 message, length delimited. Does not implicitly {@link immudb.schema.NullableUint32.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.NullableUint32
             * @static
             * @param {immudb.schema.INullableUint32} message NullableUint32 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NullableUint32.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NullableUint32 message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.NullableUint32
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.NullableUint32} NullableUint32
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NullableUint32.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.NullableUint32();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.value = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NullableUint32 message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.NullableUint32
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.NullableUint32} NullableUint32
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NullableUint32.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NullableUint32 message.
             * @function verify
             * @memberof immudb.schema.NullableUint32
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NullableUint32.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value))
                        return "value: integer expected";
                return null;
            };

            /**
             * Creates a NullableUint32 message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.NullableUint32
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.NullableUint32} NullableUint32
             */
            NullableUint32.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.NullableUint32)
                    return object;
                let message = new $root.immudb.schema.NullableUint32();
                if (object.value != null)
                    message.value = object.value >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a NullableUint32 message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.NullableUint32
             * @static
             * @param {immudb.schema.NullableUint32} message NullableUint32
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NullableUint32.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.value = 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this NullableUint32 to JSON.
             * @function toJSON
             * @memberof immudb.schema.NullableUint32
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NullableUint32.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for NullableUint32
             * @function getTypeUrl
             * @memberof immudb.schema.NullableUint32
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            NullableUint32.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.NullableUint32";
            };

            return NullableUint32;
        })();

        schema.NullableUint64 = (function() {

            /**
             * Properties of a NullableUint64.
             * @memberof immudb.schema
             * @interface INullableUint64
             * @property {Long|null} [value] NullableUint64 value
             */

            /**
             * Constructs a new NullableUint64.
             * @memberof immudb.schema
             * @classdesc Represents a NullableUint64.
             * @implements INullableUint64
             * @constructor
             * @param {immudb.schema.INullableUint64=} [properties] Properties to set
             */
            function NullableUint64(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NullableUint64 value.
             * @member {Long} value
             * @memberof immudb.schema.NullableUint64
             * @instance
             */
            NullableUint64.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new NullableUint64 instance using the specified properties.
             * @function create
             * @memberof immudb.schema.NullableUint64
             * @static
             * @param {immudb.schema.INullableUint64=} [properties] Properties to set
             * @returns {immudb.schema.NullableUint64} NullableUint64 instance
             */
            NullableUint64.create = function create(properties) {
                return new NullableUint64(properties);
            };

            /**
             * Encodes the specified NullableUint64 message. Does not implicitly {@link immudb.schema.NullableUint64.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.NullableUint64
             * @static
             * @param {immudb.schema.INullableUint64} message NullableUint64 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NullableUint64.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.value);
                return writer;
            };

            /**
             * Encodes the specified NullableUint64 message, length delimited. Does not implicitly {@link immudb.schema.NullableUint64.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.NullableUint64
             * @static
             * @param {immudb.schema.INullableUint64} message NullableUint64 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NullableUint64.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NullableUint64 message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.NullableUint64
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.NullableUint64} NullableUint64
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NullableUint64.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.NullableUint64();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.value = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NullableUint64 message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.NullableUint64
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.NullableUint64} NullableUint64
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NullableUint64.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NullableUint64 message.
             * @function verify
             * @memberof immudb.schema.NullableUint64
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NullableUint64.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                        return "value: integer|Long expected";
                return null;
            };

            /**
             * Creates a NullableUint64 message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.NullableUint64
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.NullableUint64} NullableUint64
             */
            NullableUint64.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.NullableUint64)
                    return object;
                let message = new $root.immudb.schema.NullableUint64();
                if (object.value != null)
                    if ($util.Long)
                        (message.value = $util.Long.fromValue(object.value)).unsigned = true;
                    else if (typeof object.value === "string")
                        message.value = parseInt(object.value, 10);
                    else if (typeof object.value === "number")
                        message.value = object.value;
                    else if (typeof object.value === "object")
                        message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a NullableUint64 message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.NullableUint64
             * @static
             * @param {immudb.schema.NullableUint64} message NullableUint64
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NullableUint64.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.value = options.longs === String ? "0" : 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value === "number")
                        object.value = options.longs === String ? String(message.value) : message.value;
                    else
                        object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
                return object;
            };

            /**
             * Converts this NullableUint64 to JSON.
             * @function toJSON
             * @memberof immudb.schema.NullableUint64
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NullableUint64.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for NullableUint64
             * @function getTypeUrl
             * @memberof immudb.schema.NullableUint64
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            NullableUint64.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.NullableUint64";
            };

            return NullableUint64;
        })();

        schema.NullableFloat = (function() {

            /**
             * Properties of a NullableFloat.
             * @memberof immudb.schema
             * @interface INullableFloat
             * @property {number|null} [value] NullableFloat value
             */

            /**
             * Constructs a new NullableFloat.
             * @memberof immudb.schema
             * @classdesc Represents a NullableFloat.
             * @implements INullableFloat
             * @constructor
             * @param {immudb.schema.INullableFloat=} [properties] Properties to set
             */
            function NullableFloat(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NullableFloat value.
             * @member {number} value
             * @memberof immudb.schema.NullableFloat
             * @instance
             */
            NullableFloat.prototype.value = 0;

            /**
             * Creates a new NullableFloat instance using the specified properties.
             * @function create
             * @memberof immudb.schema.NullableFloat
             * @static
             * @param {immudb.schema.INullableFloat=} [properties] Properties to set
             * @returns {immudb.schema.NullableFloat} NullableFloat instance
             */
            NullableFloat.create = function create(properties) {
                return new NullableFloat(properties);
            };

            /**
             * Encodes the specified NullableFloat message. Does not implicitly {@link immudb.schema.NullableFloat.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.NullableFloat
             * @static
             * @param {immudb.schema.INullableFloat} message NullableFloat message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NullableFloat.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.value);
                return writer;
            };

            /**
             * Encodes the specified NullableFloat message, length delimited. Does not implicitly {@link immudb.schema.NullableFloat.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.NullableFloat
             * @static
             * @param {immudb.schema.INullableFloat} message NullableFloat message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NullableFloat.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NullableFloat message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.NullableFloat
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.NullableFloat} NullableFloat
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NullableFloat.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.NullableFloat();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.value = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NullableFloat message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.NullableFloat
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.NullableFloat} NullableFloat
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NullableFloat.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NullableFloat message.
             * @function verify
             * @memberof immudb.schema.NullableFloat
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NullableFloat.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "number")
                        return "value: number expected";
                return null;
            };

            /**
             * Creates a NullableFloat message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.NullableFloat
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.NullableFloat} NullableFloat
             */
            NullableFloat.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.NullableFloat)
                    return object;
                let message = new $root.immudb.schema.NullableFloat();
                if (object.value != null)
                    message.value = Number(object.value);
                return message;
            };

            /**
             * Creates a plain object from a NullableFloat message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.NullableFloat
             * @static
             * @param {immudb.schema.NullableFloat} message NullableFloat
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NullableFloat.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.value = 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                return object;
            };

            /**
             * Converts this NullableFloat to JSON.
             * @function toJSON
             * @memberof immudb.schema.NullableFloat
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NullableFloat.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for NullableFloat
             * @function getTypeUrl
             * @memberof immudb.schema.NullableFloat
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            NullableFloat.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.NullableFloat";
            };

            return NullableFloat;
        })();

        schema.NullableBool = (function() {

            /**
             * Properties of a NullableBool.
             * @memberof immudb.schema
             * @interface INullableBool
             * @property {boolean|null} [value] NullableBool value
             */

            /**
             * Constructs a new NullableBool.
             * @memberof immudb.schema
             * @classdesc Represents a NullableBool.
             * @implements INullableBool
             * @constructor
             * @param {immudb.schema.INullableBool=} [properties] Properties to set
             */
            function NullableBool(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NullableBool value.
             * @member {boolean} value
             * @memberof immudb.schema.NullableBool
             * @instance
             */
            NullableBool.prototype.value = false;

            /**
             * Creates a new NullableBool instance using the specified properties.
             * @function create
             * @memberof immudb.schema.NullableBool
             * @static
             * @param {immudb.schema.INullableBool=} [properties] Properties to set
             * @returns {immudb.schema.NullableBool} NullableBool instance
             */
            NullableBool.create = function create(properties) {
                return new NullableBool(properties);
            };

            /**
             * Encodes the specified NullableBool message. Does not implicitly {@link immudb.schema.NullableBool.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.NullableBool
             * @static
             * @param {immudb.schema.INullableBool} message NullableBool message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NullableBool.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.value);
                return writer;
            };

            /**
             * Encodes the specified NullableBool message, length delimited. Does not implicitly {@link immudb.schema.NullableBool.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.NullableBool
             * @static
             * @param {immudb.schema.INullableBool} message NullableBool message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NullableBool.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NullableBool message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.NullableBool
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.NullableBool} NullableBool
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NullableBool.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.NullableBool();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.value = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NullableBool message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.NullableBool
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.NullableBool} NullableBool
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NullableBool.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NullableBool message.
             * @function verify
             * @memberof immudb.schema.NullableBool
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NullableBool.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "boolean")
                        return "value: boolean expected";
                return null;
            };

            /**
             * Creates a NullableBool message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.NullableBool
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.NullableBool} NullableBool
             */
            NullableBool.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.NullableBool)
                    return object;
                let message = new $root.immudb.schema.NullableBool();
                if (object.value != null)
                    message.value = Boolean(object.value);
                return message;
            };

            /**
             * Creates a plain object from a NullableBool message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.NullableBool
             * @static
             * @param {immudb.schema.NullableBool} message NullableBool
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NullableBool.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.value = false;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this NullableBool to JSON.
             * @function toJSON
             * @memberof immudb.schema.NullableBool
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NullableBool.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for NullableBool
             * @function getTypeUrl
             * @memberof immudb.schema.NullableBool
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            NullableBool.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.NullableBool";
            };

            return NullableBool;
        })();

        schema.NullableString = (function() {

            /**
             * Properties of a NullableString.
             * @memberof immudb.schema
             * @interface INullableString
             * @property {string|null} [value] NullableString value
             */

            /**
             * Constructs a new NullableString.
             * @memberof immudb.schema
             * @classdesc Represents a NullableString.
             * @implements INullableString
             * @constructor
             * @param {immudb.schema.INullableString=} [properties] Properties to set
             */
            function NullableString(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NullableString value.
             * @member {string} value
             * @memberof immudb.schema.NullableString
             * @instance
             */
            NullableString.prototype.value = "";

            /**
             * Creates a new NullableString instance using the specified properties.
             * @function create
             * @memberof immudb.schema.NullableString
             * @static
             * @param {immudb.schema.INullableString=} [properties] Properties to set
             * @returns {immudb.schema.NullableString} NullableString instance
             */
            NullableString.create = function create(properties) {
                return new NullableString(properties);
            };

            /**
             * Encodes the specified NullableString message. Does not implicitly {@link immudb.schema.NullableString.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.NullableString
             * @static
             * @param {immudb.schema.INullableString} message NullableString message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NullableString.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
                return writer;
            };

            /**
             * Encodes the specified NullableString message, length delimited. Does not implicitly {@link immudb.schema.NullableString.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.NullableString
             * @static
             * @param {immudb.schema.INullableString} message NullableString message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NullableString.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NullableString message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.NullableString
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.NullableString} NullableString
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NullableString.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.NullableString();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.value = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NullableString message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.NullableString
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.NullableString} NullableString
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NullableString.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NullableString message.
             * @function verify
             * @memberof immudb.schema.NullableString
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NullableString.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                return null;
            };

            /**
             * Creates a NullableString message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.NullableString
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.NullableString} NullableString
             */
            NullableString.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.NullableString)
                    return object;
                let message = new $root.immudb.schema.NullableString();
                if (object.value != null)
                    message.value = String(object.value);
                return message;
            };

            /**
             * Creates a plain object from a NullableString message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.NullableString
             * @static
             * @param {immudb.schema.NullableString} message NullableString
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NullableString.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.value = "";
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this NullableString to JSON.
             * @function toJSON
             * @memberof immudb.schema.NullableString
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NullableString.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for NullableString
             * @function getTypeUrl
             * @memberof immudb.schema.NullableString
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            NullableString.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.NullableString";
            };

            return NullableString;
        })();

        schema.DatabaseNullableSettings = (function() {

            /**
             * Properties of a DatabaseNullableSettings.
             * @memberof immudb.schema
             * @interface IDatabaseNullableSettings
             * @property {immudb.schema.IReplicationNullableSettings|null} [replicationSettings] DatabaseNullableSettings replicationSettings
             * @property {immudb.schema.INullableUint32|null} [fileSize] DatabaseNullableSettings fileSize
             * @property {immudb.schema.INullableUint32|null} [maxKeyLen] DatabaseNullableSettings maxKeyLen
             * @property {immudb.schema.INullableUint32|null} [maxValueLen] DatabaseNullableSettings maxValueLen
             * @property {immudb.schema.INullableUint32|null} [maxTxEntries] DatabaseNullableSettings maxTxEntries
             * @property {immudb.schema.INullableBool|null} [excludeCommitTime] DatabaseNullableSettings excludeCommitTime
             * @property {immudb.schema.INullableUint32|null} [maxConcurrency] DatabaseNullableSettings maxConcurrency
             * @property {immudb.schema.INullableUint32|null} [maxIOConcurrency] DatabaseNullableSettings maxIOConcurrency
             * @property {immudb.schema.INullableUint32|null} [txLogCacheSize] DatabaseNullableSettings txLogCacheSize
             * @property {immudb.schema.INullableUint32|null} [vLogMaxOpenedFiles] DatabaseNullableSettings vLogMaxOpenedFiles
             * @property {immudb.schema.INullableUint32|null} [txLogMaxOpenedFiles] DatabaseNullableSettings txLogMaxOpenedFiles
             * @property {immudb.schema.INullableUint32|null} [commitLogMaxOpenedFiles] DatabaseNullableSettings commitLogMaxOpenedFiles
             * @property {immudb.schema.IIndexNullableSettings|null} [indexSettings] DatabaseNullableSettings indexSettings
             * @property {immudb.schema.INullableUint32|null} [writeTxHeaderVersion] DatabaseNullableSettings writeTxHeaderVersion
             * @property {immudb.schema.INullableBool|null} [autoload] DatabaseNullableSettings autoload
             */

            /**
             * Constructs a new DatabaseNullableSettings.
             * @memberof immudb.schema
             * @classdesc Represents a DatabaseNullableSettings.
             * @implements IDatabaseNullableSettings
             * @constructor
             * @param {immudb.schema.IDatabaseNullableSettings=} [properties] Properties to set
             */
            function DatabaseNullableSettings(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DatabaseNullableSettings replicationSettings.
             * @member {immudb.schema.IReplicationNullableSettings|null|undefined} replicationSettings
             * @memberof immudb.schema.DatabaseNullableSettings
             * @instance
             */
            DatabaseNullableSettings.prototype.replicationSettings = null;

            /**
             * DatabaseNullableSettings fileSize.
             * @member {immudb.schema.INullableUint32|null|undefined} fileSize
             * @memberof immudb.schema.DatabaseNullableSettings
             * @instance
             */
            DatabaseNullableSettings.prototype.fileSize = null;

            /**
             * DatabaseNullableSettings maxKeyLen.
             * @member {immudb.schema.INullableUint32|null|undefined} maxKeyLen
             * @memberof immudb.schema.DatabaseNullableSettings
             * @instance
             */
            DatabaseNullableSettings.prototype.maxKeyLen = null;

            /**
             * DatabaseNullableSettings maxValueLen.
             * @member {immudb.schema.INullableUint32|null|undefined} maxValueLen
             * @memberof immudb.schema.DatabaseNullableSettings
             * @instance
             */
            DatabaseNullableSettings.prototype.maxValueLen = null;

            /**
             * DatabaseNullableSettings maxTxEntries.
             * @member {immudb.schema.INullableUint32|null|undefined} maxTxEntries
             * @memberof immudb.schema.DatabaseNullableSettings
             * @instance
             */
            DatabaseNullableSettings.prototype.maxTxEntries = null;

            /**
             * DatabaseNullableSettings excludeCommitTime.
             * @member {immudb.schema.INullableBool|null|undefined} excludeCommitTime
             * @memberof immudb.schema.DatabaseNullableSettings
             * @instance
             */
            DatabaseNullableSettings.prototype.excludeCommitTime = null;

            /**
             * DatabaseNullableSettings maxConcurrency.
             * @member {immudb.schema.INullableUint32|null|undefined} maxConcurrency
             * @memberof immudb.schema.DatabaseNullableSettings
             * @instance
             */
            DatabaseNullableSettings.prototype.maxConcurrency = null;

            /**
             * DatabaseNullableSettings maxIOConcurrency.
             * @member {immudb.schema.INullableUint32|null|undefined} maxIOConcurrency
             * @memberof immudb.schema.DatabaseNullableSettings
             * @instance
             */
            DatabaseNullableSettings.prototype.maxIOConcurrency = null;

            /**
             * DatabaseNullableSettings txLogCacheSize.
             * @member {immudb.schema.INullableUint32|null|undefined} txLogCacheSize
             * @memberof immudb.schema.DatabaseNullableSettings
             * @instance
             */
            DatabaseNullableSettings.prototype.txLogCacheSize = null;

            /**
             * DatabaseNullableSettings vLogMaxOpenedFiles.
             * @member {immudb.schema.INullableUint32|null|undefined} vLogMaxOpenedFiles
             * @memberof immudb.schema.DatabaseNullableSettings
             * @instance
             */
            DatabaseNullableSettings.prototype.vLogMaxOpenedFiles = null;

            /**
             * DatabaseNullableSettings txLogMaxOpenedFiles.
             * @member {immudb.schema.INullableUint32|null|undefined} txLogMaxOpenedFiles
             * @memberof immudb.schema.DatabaseNullableSettings
             * @instance
             */
            DatabaseNullableSettings.prototype.txLogMaxOpenedFiles = null;

            /**
             * DatabaseNullableSettings commitLogMaxOpenedFiles.
             * @member {immudb.schema.INullableUint32|null|undefined} commitLogMaxOpenedFiles
             * @memberof immudb.schema.DatabaseNullableSettings
             * @instance
             */
            DatabaseNullableSettings.prototype.commitLogMaxOpenedFiles = null;

            /**
             * DatabaseNullableSettings indexSettings.
             * @member {immudb.schema.IIndexNullableSettings|null|undefined} indexSettings
             * @memberof immudb.schema.DatabaseNullableSettings
             * @instance
             */
            DatabaseNullableSettings.prototype.indexSettings = null;

            /**
             * DatabaseNullableSettings writeTxHeaderVersion.
             * @member {immudb.schema.INullableUint32|null|undefined} writeTxHeaderVersion
             * @memberof immudb.schema.DatabaseNullableSettings
             * @instance
             */
            DatabaseNullableSettings.prototype.writeTxHeaderVersion = null;

            /**
             * DatabaseNullableSettings autoload.
             * @member {immudb.schema.INullableBool|null|undefined} autoload
             * @memberof immudb.schema.DatabaseNullableSettings
             * @instance
             */
            DatabaseNullableSettings.prototype.autoload = null;

            /**
             * Creates a new DatabaseNullableSettings instance using the specified properties.
             * @function create
             * @memberof immudb.schema.DatabaseNullableSettings
             * @static
             * @param {immudb.schema.IDatabaseNullableSettings=} [properties] Properties to set
             * @returns {immudb.schema.DatabaseNullableSettings} DatabaseNullableSettings instance
             */
            DatabaseNullableSettings.create = function create(properties) {
                return new DatabaseNullableSettings(properties);
            };

            /**
             * Encodes the specified DatabaseNullableSettings message. Does not implicitly {@link immudb.schema.DatabaseNullableSettings.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.DatabaseNullableSettings
             * @static
             * @param {immudb.schema.IDatabaseNullableSettings} message DatabaseNullableSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DatabaseNullableSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.replicationSettings != null && Object.hasOwnProperty.call(message, "replicationSettings"))
                    $root.immudb.schema.ReplicationNullableSettings.encode(message.replicationSettings, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.fileSize != null && Object.hasOwnProperty.call(message, "fileSize"))
                    $root.immudb.schema.NullableUint32.encode(message.fileSize, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.maxKeyLen != null && Object.hasOwnProperty.call(message, "maxKeyLen"))
                    $root.immudb.schema.NullableUint32.encode(message.maxKeyLen, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.maxValueLen != null && Object.hasOwnProperty.call(message, "maxValueLen"))
                    $root.immudb.schema.NullableUint32.encode(message.maxValueLen, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.maxTxEntries != null && Object.hasOwnProperty.call(message, "maxTxEntries"))
                    $root.immudb.schema.NullableUint32.encode(message.maxTxEntries, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.excludeCommitTime != null && Object.hasOwnProperty.call(message, "excludeCommitTime"))
                    $root.immudb.schema.NullableBool.encode(message.excludeCommitTime, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.maxConcurrency != null && Object.hasOwnProperty.call(message, "maxConcurrency"))
                    $root.immudb.schema.NullableUint32.encode(message.maxConcurrency, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.maxIOConcurrency != null && Object.hasOwnProperty.call(message, "maxIOConcurrency"))
                    $root.immudb.schema.NullableUint32.encode(message.maxIOConcurrency, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.txLogCacheSize != null && Object.hasOwnProperty.call(message, "txLogCacheSize"))
                    $root.immudb.schema.NullableUint32.encode(message.txLogCacheSize, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                if (message.vLogMaxOpenedFiles != null && Object.hasOwnProperty.call(message, "vLogMaxOpenedFiles"))
                    $root.immudb.schema.NullableUint32.encode(message.vLogMaxOpenedFiles, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                if (message.txLogMaxOpenedFiles != null && Object.hasOwnProperty.call(message, "txLogMaxOpenedFiles"))
                    $root.immudb.schema.NullableUint32.encode(message.txLogMaxOpenedFiles, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.commitLogMaxOpenedFiles != null && Object.hasOwnProperty.call(message, "commitLogMaxOpenedFiles"))
                    $root.immudb.schema.NullableUint32.encode(message.commitLogMaxOpenedFiles, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                if (message.indexSettings != null && Object.hasOwnProperty.call(message, "indexSettings"))
                    $root.immudb.schema.IndexNullableSettings.encode(message.indexSettings, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                if (message.writeTxHeaderVersion != null && Object.hasOwnProperty.call(message, "writeTxHeaderVersion"))
                    $root.immudb.schema.NullableUint32.encode(message.writeTxHeaderVersion, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                if (message.autoload != null && Object.hasOwnProperty.call(message, "autoload"))
                    $root.immudb.schema.NullableBool.encode(message.autoload, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DatabaseNullableSettings message, length delimited. Does not implicitly {@link immudb.schema.DatabaseNullableSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.DatabaseNullableSettings
             * @static
             * @param {immudb.schema.IDatabaseNullableSettings} message DatabaseNullableSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DatabaseNullableSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DatabaseNullableSettings message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.DatabaseNullableSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.DatabaseNullableSettings} DatabaseNullableSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DatabaseNullableSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.DatabaseNullableSettings();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2: {
                            message.replicationSettings = $root.immudb.schema.ReplicationNullableSettings.decode(reader, reader.uint32());
                            break;
                        }
                    case 8: {
                            message.fileSize = $root.immudb.schema.NullableUint32.decode(reader, reader.uint32());
                            break;
                        }
                    case 9: {
                            message.maxKeyLen = $root.immudb.schema.NullableUint32.decode(reader, reader.uint32());
                            break;
                        }
                    case 10: {
                            message.maxValueLen = $root.immudb.schema.NullableUint32.decode(reader, reader.uint32());
                            break;
                        }
                    case 11: {
                            message.maxTxEntries = $root.immudb.schema.NullableUint32.decode(reader, reader.uint32());
                            break;
                        }
                    case 12: {
                            message.excludeCommitTime = $root.immudb.schema.NullableBool.decode(reader, reader.uint32());
                            break;
                        }
                    case 13: {
                            message.maxConcurrency = $root.immudb.schema.NullableUint32.decode(reader, reader.uint32());
                            break;
                        }
                    case 14: {
                            message.maxIOConcurrency = $root.immudb.schema.NullableUint32.decode(reader, reader.uint32());
                            break;
                        }
                    case 15: {
                            message.txLogCacheSize = $root.immudb.schema.NullableUint32.decode(reader, reader.uint32());
                            break;
                        }
                    case 16: {
                            message.vLogMaxOpenedFiles = $root.immudb.schema.NullableUint32.decode(reader, reader.uint32());
                            break;
                        }
                    case 17: {
                            message.txLogMaxOpenedFiles = $root.immudb.schema.NullableUint32.decode(reader, reader.uint32());
                            break;
                        }
                    case 18: {
                            message.commitLogMaxOpenedFiles = $root.immudb.schema.NullableUint32.decode(reader, reader.uint32());
                            break;
                        }
                    case 19: {
                            message.indexSettings = $root.immudb.schema.IndexNullableSettings.decode(reader, reader.uint32());
                            break;
                        }
                    case 20: {
                            message.writeTxHeaderVersion = $root.immudb.schema.NullableUint32.decode(reader, reader.uint32());
                            break;
                        }
                    case 21: {
                            message.autoload = $root.immudb.schema.NullableBool.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DatabaseNullableSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.DatabaseNullableSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.DatabaseNullableSettings} DatabaseNullableSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DatabaseNullableSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DatabaseNullableSettings message.
             * @function verify
             * @memberof immudb.schema.DatabaseNullableSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DatabaseNullableSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.replicationSettings != null && message.hasOwnProperty("replicationSettings")) {
                    let error = $root.immudb.schema.ReplicationNullableSettings.verify(message.replicationSettings);
                    if (error)
                        return "replicationSettings." + error;
                }
                if (message.fileSize != null && message.hasOwnProperty("fileSize")) {
                    let error = $root.immudb.schema.NullableUint32.verify(message.fileSize);
                    if (error)
                        return "fileSize." + error;
                }
                if (message.maxKeyLen != null && message.hasOwnProperty("maxKeyLen")) {
                    let error = $root.immudb.schema.NullableUint32.verify(message.maxKeyLen);
                    if (error)
                        return "maxKeyLen." + error;
                }
                if (message.maxValueLen != null && message.hasOwnProperty("maxValueLen")) {
                    let error = $root.immudb.schema.NullableUint32.verify(message.maxValueLen);
                    if (error)
                        return "maxValueLen." + error;
                }
                if (message.maxTxEntries != null && message.hasOwnProperty("maxTxEntries")) {
                    let error = $root.immudb.schema.NullableUint32.verify(message.maxTxEntries);
                    if (error)
                        return "maxTxEntries." + error;
                }
                if (message.excludeCommitTime != null && message.hasOwnProperty("excludeCommitTime")) {
                    let error = $root.immudb.schema.NullableBool.verify(message.excludeCommitTime);
                    if (error)
                        return "excludeCommitTime." + error;
                }
                if (message.maxConcurrency != null && message.hasOwnProperty("maxConcurrency")) {
                    let error = $root.immudb.schema.NullableUint32.verify(message.maxConcurrency);
                    if (error)
                        return "maxConcurrency." + error;
                }
                if (message.maxIOConcurrency != null && message.hasOwnProperty("maxIOConcurrency")) {
                    let error = $root.immudb.schema.NullableUint32.verify(message.maxIOConcurrency);
                    if (error)
                        return "maxIOConcurrency." + error;
                }
                if (message.txLogCacheSize != null && message.hasOwnProperty("txLogCacheSize")) {
                    let error = $root.immudb.schema.NullableUint32.verify(message.txLogCacheSize);
                    if (error)
                        return "txLogCacheSize." + error;
                }
                if (message.vLogMaxOpenedFiles != null && message.hasOwnProperty("vLogMaxOpenedFiles")) {
                    let error = $root.immudb.schema.NullableUint32.verify(message.vLogMaxOpenedFiles);
                    if (error)
                        return "vLogMaxOpenedFiles." + error;
                }
                if (message.txLogMaxOpenedFiles != null && message.hasOwnProperty("txLogMaxOpenedFiles")) {
                    let error = $root.immudb.schema.NullableUint32.verify(message.txLogMaxOpenedFiles);
                    if (error)
                        return "txLogMaxOpenedFiles." + error;
                }
                if (message.commitLogMaxOpenedFiles != null && message.hasOwnProperty("commitLogMaxOpenedFiles")) {
                    let error = $root.immudb.schema.NullableUint32.verify(message.commitLogMaxOpenedFiles);
                    if (error)
                        return "commitLogMaxOpenedFiles." + error;
                }
                if (message.indexSettings != null && message.hasOwnProperty("indexSettings")) {
                    let error = $root.immudb.schema.IndexNullableSettings.verify(message.indexSettings);
                    if (error)
                        return "indexSettings." + error;
                }
                if (message.writeTxHeaderVersion != null && message.hasOwnProperty("writeTxHeaderVersion")) {
                    let error = $root.immudb.schema.NullableUint32.verify(message.writeTxHeaderVersion);
                    if (error)
                        return "writeTxHeaderVersion." + error;
                }
                if (message.autoload != null && message.hasOwnProperty("autoload")) {
                    let error = $root.immudb.schema.NullableBool.verify(message.autoload);
                    if (error)
                        return "autoload." + error;
                }
                return null;
            };

            /**
             * Creates a DatabaseNullableSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.DatabaseNullableSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.DatabaseNullableSettings} DatabaseNullableSettings
             */
            DatabaseNullableSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.DatabaseNullableSettings)
                    return object;
                let message = new $root.immudb.schema.DatabaseNullableSettings();
                if (object.replicationSettings != null) {
                    if (typeof object.replicationSettings !== "object")
                        throw TypeError(".immudb.schema.DatabaseNullableSettings.replicationSettings: object expected");
                    message.replicationSettings = $root.immudb.schema.ReplicationNullableSettings.fromObject(object.replicationSettings);
                }
                if (object.fileSize != null) {
                    if (typeof object.fileSize !== "object")
                        throw TypeError(".immudb.schema.DatabaseNullableSettings.fileSize: object expected");
                    message.fileSize = $root.immudb.schema.NullableUint32.fromObject(object.fileSize);
                }
                if (object.maxKeyLen != null) {
                    if (typeof object.maxKeyLen !== "object")
                        throw TypeError(".immudb.schema.DatabaseNullableSettings.maxKeyLen: object expected");
                    message.maxKeyLen = $root.immudb.schema.NullableUint32.fromObject(object.maxKeyLen);
                }
                if (object.maxValueLen != null) {
                    if (typeof object.maxValueLen !== "object")
                        throw TypeError(".immudb.schema.DatabaseNullableSettings.maxValueLen: object expected");
                    message.maxValueLen = $root.immudb.schema.NullableUint32.fromObject(object.maxValueLen);
                }
                if (object.maxTxEntries != null) {
                    if (typeof object.maxTxEntries !== "object")
                        throw TypeError(".immudb.schema.DatabaseNullableSettings.maxTxEntries: object expected");
                    message.maxTxEntries = $root.immudb.schema.NullableUint32.fromObject(object.maxTxEntries);
                }
                if (object.excludeCommitTime != null) {
                    if (typeof object.excludeCommitTime !== "object")
                        throw TypeError(".immudb.schema.DatabaseNullableSettings.excludeCommitTime: object expected");
                    message.excludeCommitTime = $root.immudb.schema.NullableBool.fromObject(object.excludeCommitTime);
                }
                if (object.maxConcurrency != null) {
                    if (typeof object.maxConcurrency !== "object")
                        throw TypeError(".immudb.schema.DatabaseNullableSettings.maxConcurrency: object expected");
                    message.maxConcurrency = $root.immudb.schema.NullableUint32.fromObject(object.maxConcurrency);
                }
                if (object.maxIOConcurrency != null) {
                    if (typeof object.maxIOConcurrency !== "object")
                        throw TypeError(".immudb.schema.DatabaseNullableSettings.maxIOConcurrency: object expected");
                    message.maxIOConcurrency = $root.immudb.schema.NullableUint32.fromObject(object.maxIOConcurrency);
                }
                if (object.txLogCacheSize != null) {
                    if (typeof object.txLogCacheSize !== "object")
                        throw TypeError(".immudb.schema.DatabaseNullableSettings.txLogCacheSize: object expected");
                    message.txLogCacheSize = $root.immudb.schema.NullableUint32.fromObject(object.txLogCacheSize);
                }
                if (object.vLogMaxOpenedFiles != null) {
                    if (typeof object.vLogMaxOpenedFiles !== "object")
                        throw TypeError(".immudb.schema.DatabaseNullableSettings.vLogMaxOpenedFiles: object expected");
                    message.vLogMaxOpenedFiles = $root.immudb.schema.NullableUint32.fromObject(object.vLogMaxOpenedFiles);
                }
                if (object.txLogMaxOpenedFiles != null) {
                    if (typeof object.txLogMaxOpenedFiles !== "object")
                        throw TypeError(".immudb.schema.DatabaseNullableSettings.txLogMaxOpenedFiles: object expected");
                    message.txLogMaxOpenedFiles = $root.immudb.schema.NullableUint32.fromObject(object.txLogMaxOpenedFiles);
                }
                if (object.commitLogMaxOpenedFiles != null) {
                    if (typeof object.commitLogMaxOpenedFiles !== "object")
                        throw TypeError(".immudb.schema.DatabaseNullableSettings.commitLogMaxOpenedFiles: object expected");
                    message.commitLogMaxOpenedFiles = $root.immudb.schema.NullableUint32.fromObject(object.commitLogMaxOpenedFiles);
                }
                if (object.indexSettings != null) {
                    if (typeof object.indexSettings !== "object")
                        throw TypeError(".immudb.schema.DatabaseNullableSettings.indexSettings: object expected");
                    message.indexSettings = $root.immudb.schema.IndexNullableSettings.fromObject(object.indexSettings);
                }
                if (object.writeTxHeaderVersion != null) {
                    if (typeof object.writeTxHeaderVersion !== "object")
                        throw TypeError(".immudb.schema.DatabaseNullableSettings.writeTxHeaderVersion: object expected");
                    message.writeTxHeaderVersion = $root.immudb.schema.NullableUint32.fromObject(object.writeTxHeaderVersion);
                }
                if (object.autoload != null) {
                    if (typeof object.autoload !== "object")
                        throw TypeError(".immudb.schema.DatabaseNullableSettings.autoload: object expected");
                    message.autoload = $root.immudb.schema.NullableBool.fromObject(object.autoload);
                }
                return message;
            };

            /**
             * Creates a plain object from a DatabaseNullableSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.DatabaseNullableSettings
             * @static
             * @param {immudb.schema.DatabaseNullableSettings} message DatabaseNullableSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DatabaseNullableSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.replicationSettings = null;
                    object.fileSize = null;
                    object.maxKeyLen = null;
                    object.maxValueLen = null;
                    object.maxTxEntries = null;
                    object.excludeCommitTime = null;
                    object.maxConcurrency = null;
                    object.maxIOConcurrency = null;
                    object.txLogCacheSize = null;
                    object.vLogMaxOpenedFiles = null;
                    object.txLogMaxOpenedFiles = null;
                    object.commitLogMaxOpenedFiles = null;
                    object.indexSettings = null;
                    object.writeTxHeaderVersion = null;
                    object.autoload = null;
                }
                if (message.replicationSettings != null && message.hasOwnProperty("replicationSettings"))
                    object.replicationSettings = $root.immudb.schema.ReplicationNullableSettings.toObject(message.replicationSettings, options);
                if (message.fileSize != null && message.hasOwnProperty("fileSize"))
                    object.fileSize = $root.immudb.schema.NullableUint32.toObject(message.fileSize, options);
                if (message.maxKeyLen != null && message.hasOwnProperty("maxKeyLen"))
                    object.maxKeyLen = $root.immudb.schema.NullableUint32.toObject(message.maxKeyLen, options);
                if (message.maxValueLen != null && message.hasOwnProperty("maxValueLen"))
                    object.maxValueLen = $root.immudb.schema.NullableUint32.toObject(message.maxValueLen, options);
                if (message.maxTxEntries != null && message.hasOwnProperty("maxTxEntries"))
                    object.maxTxEntries = $root.immudb.schema.NullableUint32.toObject(message.maxTxEntries, options);
                if (message.excludeCommitTime != null && message.hasOwnProperty("excludeCommitTime"))
                    object.excludeCommitTime = $root.immudb.schema.NullableBool.toObject(message.excludeCommitTime, options);
                if (message.maxConcurrency != null && message.hasOwnProperty("maxConcurrency"))
                    object.maxConcurrency = $root.immudb.schema.NullableUint32.toObject(message.maxConcurrency, options);
                if (message.maxIOConcurrency != null && message.hasOwnProperty("maxIOConcurrency"))
                    object.maxIOConcurrency = $root.immudb.schema.NullableUint32.toObject(message.maxIOConcurrency, options);
                if (message.txLogCacheSize != null && message.hasOwnProperty("txLogCacheSize"))
                    object.txLogCacheSize = $root.immudb.schema.NullableUint32.toObject(message.txLogCacheSize, options);
                if (message.vLogMaxOpenedFiles != null && message.hasOwnProperty("vLogMaxOpenedFiles"))
                    object.vLogMaxOpenedFiles = $root.immudb.schema.NullableUint32.toObject(message.vLogMaxOpenedFiles, options);
                if (message.txLogMaxOpenedFiles != null && message.hasOwnProperty("txLogMaxOpenedFiles"))
                    object.txLogMaxOpenedFiles = $root.immudb.schema.NullableUint32.toObject(message.txLogMaxOpenedFiles, options);
                if (message.commitLogMaxOpenedFiles != null && message.hasOwnProperty("commitLogMaxOpenedFiles"))
                    object.commitLogMaxOpenedFiles = $root.immudb.schema.NullableUint32.toObject(message.commitLogMaxOpenedFiles, options);
                if (message.indexSettings != null && message.hasOwnProperty("indexSettings"))
                    object.indexSettings = $root.immudb.schema.IndexNullableSettings.toObject(message.indexSettings, options);
                if (message.writeTxHeaderVersion != null && message.hasOwnProperty("writeTxHeaderVersion"))
                    object.writeTxHeaderVersion = $root.immudb.schema.NullableUint32.toObject(message.writeTxHeaderVersion, options);
                if (message.autoload != null && message.hasOwnProperty("autoload"))
                    object.autoload = $root.immudb.schema.NullableBool.toObject(message.autoload, options);
                return object;
            };

            /**
             * Converts this DatabaseNullableSettings to JSON.
             * @function toJSON
             * @memberof immudb.schema.DatabaseNullableSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DatabaseNullableSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DatabaseNullableSettings
             * @function getTypeUrl
             * @memberof immudb.schema.DatabaseNullableSettings
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DatabaseNullableSettings.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.DatabaseNullableSettings";
            };

            return DatabaseNullableSettings;
        })();

        schema.ReplicationNullableSettings = (function() {

            /**
             * Properties of a ReplicationNullableSettings.
             * @memberof immudb.schema
             * @interface IReplicationNullableSettings
             * @property {immudb.schema.INullableBool|null} [replica] ReplicationNullableSettings replica
             * @property {immudb.schema.INullableString|null} [masterDatabase] ReplicationNullableSettings masterDatabase
             * @property {immudb.schema.INullableString|null} [masterAddress] ReplicationNullableSettings masterAddress
             * @property {immudb.schema.INullableUint32|null} [masterPort] ReplicationNullableSettings masterPort
             * @property {immudb.schema.INullableString|null} [followerUsername] ReplicationNullableSettings followerUsername
             * @property {immudb.schema.INullableString|null} [followerPassword] ReplicationNullableSettings followerPassword
             */

            /**
             * Constructs a new ReplicationNullableSettings.
             * @memberof immudb.schema
             * @classdesc Represents a ReplicationNullableSettings.
             * @implements IReplicationNullableSettings
             * @constructor
             * @param {immudb.schema.IReplicationNullableSettings=} [properties] Properties to set
             */
            function ReplicationNullableSettings(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReplicationNullableSettings replica.
             * @member {immudb.schema.INullableBool|null|undefined} replica
             * @memberof immudb.schema.ReplicationNullableSettings
             * @instance
             */
            ReplicationNullableSettings.prototype.replica = null;

            /**
             * ReplicationNullableSettings masterDatabase.
             * @member {immudb.schema.INullableString|null|undefined} masterDatabase
             * @memberof immudb.schema.ReplicationNullableSettings
             * @instance
             */
            ReplicationNullableSettings.prototype.masterDatabase = null;

            /**
             * ReplicationNullableSettings masterAddress.
             * @member {immudb.schema.INullableString|null|undefined} masterAddress
             * @memberof immudb.schema.ReplicationNullableSettings
             * @instance
             */
            ReplicationNullableSettings.prototype.masterAddress = null;

            /**
             * ReplicationNullableSettings masterPort.
             * @member {immudb.schema.INullableUint32|null|undefined} masterPort
             * @memberof immudb.schema.ReplicationNullableSettings
             * @instance
             */
            ReplicationNullableSettings.prototype.masterPort = null;

            /**
             * ReplicationNullableSettings followerUsername.
             * @member {immudb.schema.INullableString|null|undefined} followerUsername
             * @memberof immudb.schema.ReplicationNullableSettings
             * @instance
             */
            ReplicationNullableSettings.prototype.followerUsername = null;

            /**
             * ReplicationNullableSettings followerPassword.
             * @member {immudb.schema.INullableString|null|undefined} followerPassword
             * @memberof immudb.schema.ReplicationNullableSettings
             * @instance
             */
            ReplicationNullableSettings.prototype.followerPassword = null;

            /**
             * Creates a new ReplicationNullableSettings instance using the specified properties.
             * @function create
             * @memberof immudb.schema.ReplicationNullableSettings
             * @static
             * @param {immudb.schema.IReplicationNullableSettings=} [properties] Properties to set
             * @returns {immudb.schema.ReplicationNullableSettings} ReplicationNullableSettings instance
             */
            ReplicationNullableSettings.create = function create(properties) {
                return new ReplicationNullableSettings(properties);
            };

            /**
             * Encodes the specified ReplicationNullableSettings message. Does not implicitly {@link immudb.schema.ReplicationNullableSettings.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.ReplicationNullableSettings
             * @static
             * @param {immudb.schema.IReplicationNullableSettings} message ReplicationNullableSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReplicationNullableSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.replica != null && Object.hasOwnProperty.call(message, "replica"))
                    $root.immudb.schema.NullableBool.encode(message.replica, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.masterDatabase != null && Object.hasOwnProperty.call(message, "masterDatabase"))
                    $root.immudb.schema.NullableString.encode(message.masterDatabase, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.masterAddress != null && Object.hasOwnProperty.call(message, "masterAddress"))
                    $root.immudb.schema.NullableString.encode(message.masterAddress, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.masterPort != null && Object.hasOwnProperty.call(message, "masterPort"))
                    $root.immudb.schema.NullableUint32.encode(message.masterPort, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.followerUsername != null && Object.hasOwnProperty.call(message, "followerUsername"))
                    $root.immudb.schema.NullableString.encode(message.followerUsername, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.followerPassword != null && Object.hasOwnProperty.call(message, "followerPassword"))
                    $root.immudb.schema.NullableString.encode(message.followerPassword, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReplicationNullableSettings message, length delimited. Does not implicitly {@link immudb.schema.ReplicationNullableSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.ReplicationNullableSettings
             * @static
             * @param {immudb.schema.IReplicationNullableSettings} message ReplicationNullableSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReplicationNullableSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReplicationNullableSettings message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.ReplicationNullableSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.ReplicationNullableSettings} ReplicationNullableSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReplicationNullableSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.ReplicationNullableSettings();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.replica = $root.immudb.schema.NullableBool.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.masterDatabase = $root.immudb.schema.NullableString.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.masterAddress = $root.immudb.schema.NullableString.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.masterPort = $root.immudb.schema.NullableUint32.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.followerUsername = $root.immudb.schema.NullableString.decode(reader, reader.uint32());
                            break;
                        }
                    case 6: {
                            message.followerPassword = $root.immudb.schema.NullableString.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReplicationNullableSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.ReplicationNullableSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.ReplicationNullableSettings} ReplicationNullableSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReplicationNullableSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReplicationNullableSettings message.
             * @function verify
             * @memberof immudb.schema.ReplicationNullableSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReplicationNullableSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.replica != null && message.hasOwnProperty("replica")) {
                    let error = $root.immudb.schema.NullableBool.verify(message.replica);
                    if (error)
                        return "replica." + error;
                }
                if (message.masterDatabase != null && message.hasOwnProperty("masterDatabase")) {
                    let error = $root.immudb.schema.NullableString.verify(message.masterDatabase);
                    if (error)
                        return "masterDatabase." + error;
                }
                if (message.masterAddress != null && message.hasOwnProperty("masterAddress")) {
                    let error = $root.immudb.schema.NullableString.verify(message.masterAddress);
                    if (error)
                        return "masterAddress." + error;
                }
                if (message.masterPort != null && message.hasOwnProperty("masterPort")) {
                    let error = $root.immudb.schema.NullableUint32.verify(message.masterPort);
                    if (error)
                        return "masterPort." + error;
                }
                if (message.followerUsername != null && message.hasOwnProperty("followerUsername")) {
                    let error = $root.immudb.schema.NullableString.verify(message.followerUsername);
                    if (error)
                        return "followerUsername." + error;
                }
                if (message.followerPassword != null && message.hasOwnProperty("followerPassword")) {
                    let error = $root.immudb.schema.NullableString.verify(message.followerPassword);
                    if (error)
                        return "followerPassword." + error;
                }
                return null;
            };

            /**
             * Creates a ReplicationNullableSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.ReplicationNullableSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.ReplicationNullableSettings} ReplicationNullableSettings
             */
            ReplicationNullableSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.ReplicationNullableSettings)
                    return object;
                let message = new $root.immudb.schema.ReplicationNullableSettings();
                if (object.replica != null) {
                    if (typeof object.replica !== "object")
                        throw TypeError(".immudb.schema.ReplicationNullableSettings.replica: object expected");
                    message.replica = $root.immudb.schema.NullableBool.fromObject(object.replica);
                }
                if (object.masterDatabase != null) {
                    if (typeof object.masterDatabase !== "object")
                        throw TypeError(".immudb.schema.ReplicationNullableSettings.masterDatabase: object expected");
                    message.masterDatabase = $root.immudb.schema.NullableString.fromObject(object.masterDatabase);
                }
                if (object.masterAddress != null) {
                    if (typeof object.masterAddress !== "object")
                        throw TypeError(".immudb.schema.ReplicationNullableSettings.masterAddress: object expected");
                    message.masterAddress = $root.immudb.schema.NullableString.fromObject(object.masterAddress);
                }
                if (object.masterPort != null) {
                    if (typeof object.masterPort !== "object")
                        throw TypeError(".immudb.schema.ReplicationNullableSettings.masterPort: object expected");
                    message.masterPort = $root.immudb.schema.NullableUint32.fromObject(object.masterPort);
                }
                if (object.followerUsername != null) {
                    if (typeof object.followerUsername !== "object")
                        throw TypeError(".immudb.schema.ReplicationNullableSettings.followerUsername: object expected");
                    message.followerUsername = $root.immudb.schema.NullableString.fromObject(object.followerUsername);
                }
                if (object.followerPassword != null) {
                    if (typeof object.followerPassword !== "object")
                        throw TypeError(".immudb.schema.ReplicationNullableSettings.followerPassword: object expected");
                    message.followerPassword = $root.immudb.schema.NullableString.fromObject(object.followerPassword);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReplicationNullableSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.ReplicationNullableSettings
             * @static
             * @param {immudb.schema.ReplicationNullableSettings} message ReplicationNullableSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReplicationNullableSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.replica = null;
                    object.masterDatabase = null;
                    object.masterAddress = null;
                    object.masterPort = null;
                    object.followerUsername = null;
                    object.followerPassword = null;
                }
                if (message.replica != null && message.hasOwnProperty("replica"))
                    object.replica = $root.immudb.schema.NullableBool.toObject(message.replica, options);
                if (message.masterDatabase != null && message.hasOwnProperty("masterDatabase"))
                    object.masterDatabase = $root.immudb.schema.NullableString.toObject(message.masterDatabase, options);
                if (message.masterAddress != null && message.hasOwnProperty("masterAddress"))
                    object.masterAddress = $root.immudb.schema.NullableString.toObject(message.masterAddress, options);
                if (message.masterPort != null && message.hasOwnProperty("masterPort"))
                    object.masterPort = $root.immudb.schema.NullableUint32.toObject(message.masterPort, options);
                if (message.followerUsername != null && message.hasOwnProperty("followerUsername"))
                    object.followerUsername = $root.immudb.schema.NullableString.toObject(message.followerUsername, options);
                if (message.followerPassword != null && message.hasOwnProperty("followerPassword"))
                    object.followerPassword = $root.immudb.schema.NullableString.toObject(message.followerPassword, options);
                return object;
            };

            /**
             * Converts this ReplicationNullableSettings to JSON.
             * @function toJSON
             * @memberof immudb.schema.ReplicationNullableSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReplicationNullableSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ReplicationNullableSettings
             * @function getTypeUrl
             * @memberof immudb.schema.ReplicationNullableSettings
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ReplicationNullableSettings.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.ReplicationNullableSettings";
            };

            return ReplicationNullableSettings;
        })();

        schema.IndexNullableSettings = (function() {

            /**
             * Properties of an IndexNullableSettings.
             * @memberof immudb.schema
             * @interface IIndexNullableSettings
             * @property {immudb.schema.INullableUint32|null} [flushThreshold] IndexNullableSettings flushThreshold
             * @property {immudb.schema.INullableUint32|null} [syncThreshold] IndexNullableSettings syncThreshold
             * @property {immudb.schema.INullableUint32|null} [cacheSize] IndexNullableSettings cacheSize
             * @property {immudb.schema.INullableUint32|null} [maxNodeSize] IndexNullableSettings maxNodeSize
             * @property {immudb.schema.INullableUint32|null} [maxActiveSnapshots] IndexNullableSettings maxActiveSnapshots
             * @property {immudb.schema.INullableUint64|null} [renewSnapRootAfter] IndexNullableSettings renewSnapRootAfter
             * @property {immudb.schema.INullableUint32|null} [compactionThld] IndexNullableSettings compactionThld
             * @property {immudb.schema.INullableUint32|null} [delayDuringCompaction] IndexNullableSettings delayDuringCompaction
             * @property {immudb.schema.INullableUint32|null} [nodesLogMaxOpenedFiles] IndexNullableSettings nodesLogMaxOpenedFiles
             * @property {immudb.schema.INullableUint32|null} [historyLogMaxOpenedFiles] IndexNullableSettings historyLogMaxOpenedFiles
             * @property {immudb.schema.INullableUint32|null} [commitLogMaxOpenedFiles] IndexNullableSettings commitLogMaxOpenedFiles
             * @property {immudb.schema.INullableUint32|null} [flushBufferSize] IndexNullableSettings flushBufferSize
             * @property {immudb.schema.INullableFloat|null} [cleanupPercentage] IndexNullableSettings cleanupPercentage
             */

            /**
             * Constructs a new IndexNullableSettings.
             * @memberof immudb.schema
             * @classdesc Represents an IndexNullableSettings.
             * @implements IIndexNullableSettings
             * @constructor
             * @param {immudb.schema.IIndexNullableSettings=} [properties] Properties to set
             */
            function IndexNullableSettings(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IndexNullableSettings flushThreshold.
             * @member {immudb.schema.INullableUint32|null|undefined} flushThreshold
             * @memberof immudb.schema.IndexNullableSettings
             * @instance
             */
            IndexNullableSettings.prototype.flushThreshold = null;

            /**
             * IndexNullableSettings syncThreshold.
             * @member {immudb.schema.INullableUint32|null|undefined} syncThreshold
             * @memberof immudb.schema.IndexNullableSettings
             * @instance
             */
            IndexNullableSettings.prototype.syncThreshold = null;

            /**
             * IndexNullableSettings cacheSize.
             * @member {immudb.schema.INullableUint32|null|undefined} cacheSize
             * @memberof immudb.schema.IndexNullableSettings
             * @instance
             */
            IndexNullableSettings.prototype.cacheSize = null;

            /**
             * IndexNullableSettings maxNodeSize.
             * @member {immudb.schema.INullableUint32|null|undefined} maxNodeSize
             * @memberof immudb.schema.IndexNullableSettings
             * @instance
             */
            IndexNullableSettings.prototype.maxNodeSize = null;

            /**
             * IndexNullableSettings maxActiveSnapshots.
             * @member {immudb.schema.INullableUint32|null|undefined} maxActiveSnapshots
             * @memberof immudb.schema.IndexNullableSettings
             * @instance
             */
            IndexNullableSettings.prototype.maxActiveSnapshots = null;

            /**
             * IndexNullableSettings renewSnapRootAfter.
             * @member {immudb.schema.INullableUint64|null|undefined} renewSnapRootAfter
             * @memberof immudb.schema.IndexNullableSettings
             * @instance
             */
            IndexNullableSettings.prototype.renewSnapRootAfter = null;

            /**
             * IndexNullableSettings compactionThld.
             * @member {immudb.schema.INullableUint32|null|undefined} compactionThld
             * @memberof immudb.schema.IndexNullableSettings
             * @instance
             */
            IndexNullableSettings.prototype.compactionThld = null;

            /**
             * IndexNullableSettings delayDuringCompaction.
             * @member {immudb.schema.INullableUint32|null|undefined} delayDuringCompaction
             * @memberof immudb.schema.IndexNullableSettings
             * @instance
             */
            IndexNullableSettings.prototype.delayDuringCompaction = null;

            /**
             * IndexNullableSettings nodesLogMaxOpenedFiles.
             * @member {immudb.schema.INullableUint32|null|undefined} nodesLogMaxOpenedFiles
             * @memberof immudb.schema.IndexNullableSettings
             * @instance
             */
            IndexNullableSettings.prototype.nodesLogMaxOpenedFiles = null;

            /**
             * IndexNullableSettings historyLogMaxOpenedFiles.
             * @member {immudb.schema.INullableUint32|null|undefined} historyLogMaxOpenedFiles
             * @memberof immudb.schema.IndexNullableSettings
             * @instance
             */
            IndexNullableSettings.prototype.historyLogMaxOpenedFiles = null;

            /**
             * IndexNullableSettings commitLogMaxOpenedFiles.
             * @member {immudb.schema.INullableUint32|null|undefined} commitLogMaxOpenedFiles
             * @memberof immudb.schema.IndexNullableSettings
             * @instance
             */
            IndexNullableSettings.prototype.commitLogMaxOpenedFiles = null;

            /**
             * IndexNullableSettings flushBufferSize.
             * @member {immudb.schema.INullableUint32|null|undefined} flushBufferSize
             * @memberof immudb.schema.IndexNullableSettings
             * @instance
             */
            IndexNullableSettings.prototype.flushBufferSize = null;

            /**
             * IndexNullableSettings cleanupPercentage.
             * @member {immudb.schema.INullableFloat|null|undefined} cleanupPercentage
             * @memberof immudb.schema.IndexNullableSettings
             * @instance
             */
            IndexNullableSettings.prototype.cleanupPercentage = null;

            /**
             * Creates a new IndexNullableSettings instance using the specified properties.
             * @function create
             * @memberof immudb.schema.IndexNullableSettings
             * @static
             * @param {immudb.schema.IIndexNullableSettings=} [properties] Properties to set
             * @returns {immudb.schema.IndexNullableSettings} IndexNullableSettings instance
             */
            IndexNullableSettings.create = function create(properties) {
                return new IndexNullableSettings(properties);
            };

            /**
             * Encodes the specified IndexNullableSettings message. Does not implicitly {@link immudb.schema.IndexNullableSettings.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.IndexNullableSettings
             * @static
             * @param {immudb.schema.IIndexNullableSettings} message IndexNullableSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IndexNullableSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flushThreshold != null && Object.hasOwnProperty.call(message, "flushThreshold"))
                    $root.immudb.schema.NullableUint32.encode(message.flushThreshold, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.syncThreshold != null && Object.hasOwnProperty.call(message, "syncThreshold"))
                    $root.immudb.schema.NullableUint32.encode(message.syncThreshold, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.cacheSize != null && Object.hasOwnProperty.call(message, "cacheSize"))
                    $root.immudb.schema.NullableUint32.encode(message.cacheSize, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.maxNodeSize != null && Object.hasOwnProperty.call(message, "maxNodeSize"))
                    $root.immudb.schema.NullableUint32.encode(message.maxNodeSize, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.maxActiveSnapshots != null && Object.hasOwnProperty.call(message, "maxActiveSnapshots"))
                    $root.immudb.schema.NullableUint32.encode(message.maxActiveSnapshots, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.renewSnapRootAfter != null && Object.hasOwnProperty.call(message, "renewSnapRootAfter"))
                    $root.immudb.schema.NullableUint64.encode(message.renewSnapRootAfter, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.compactionThld != null && Object.hasOwnProperty.call(message, "compactionThld"))
                    $root.immudb.schema.NullableUint32.encode(message.compactionThld, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.delayDuringCompaction != null && Object.hasOwnProperty.call(message, "delayDuringCompaction"))
                    $root.immudb.schema.NullableUint32.encode(message.delayDuringCompaction, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.nodesLogMaxOpenedFiles != null && Object.hasOwnProperty.call(message, "nodesLogMaxOpenedFiles"))
                    $root.immudb.schema.NullableUint32.encode(message.nodesLogMaxOpenedFiles, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.historyLogMaxOpenedFiles != null && Object.hasOwnProperty.call(message, "historyLogMaxOpenedFiles"))
                    $root.immudb.schema.NullableUint32.encode(message.historyLogMaxOpenedFiles, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.commitLogMaxOpenedFiles != null && Object.hasOwnProperty.call(message, "commitLogMaxOpenedFiles"))
                    $root.immudb.schema.NullableUint32.encode(message.commitLogMaxOpenedFiles, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.flushBufferSize != null && Object.hasOwnProperty.call(message, "flushBufferSize"))
                    $root.immudb.schema.NullableUint32.encode(message.flushBufferSize, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.cleanupPercentage != null && Object.hasOwnProperty.call(message, "cleanupPercentage"))
                    $root.immudb.schema.NullableFloat.encode(message.cleanupPercentage, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified IndexNullableSettings message, length delimited. Does not implicitly {@link immudb.schema.IndexNullableSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.IndexNullableSettings
             * @static
             * @param {immudb.schema.IIndexNullableSettings} message IndexNullableSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IndexNullableSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an IndexNullableSettings message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.IndexNullableSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.IndexNullableSettings} IndexNullableSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IndexNullableSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.IndexNullableSettings();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flushThreshold = $root.immudb.schema.NullableUint32.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.syncThreshold = $root.immudb.schema.NullableUint32.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.cacheSize = $root.immudb.schema.NullableUint32.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.maxNodeSize = $root.immudb.schema.NullableUint32.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.maxActiveSnapshots = $root.immudb.schema.NullableUint32.decode(reader, reader.uint32());
                            break;
                        }
                    case 6: {
                            message.renewSnapRootAfter = $root.immudb.schema.NullableUint64.decode(reader, reader.uint32());
                            break;
                        }
                    case 7: {
                            message.compactionThld = $root.immudb.schema.NullableUint32.decode(reader, reader.uint32());
                            break;
                        }
                    case 8: {
                            message.delayDuringCompaction = $root.immudb.schema.NullableUint32.decode(reader, reader.uint32());
                            break;
                        }
                    case 9: {
                            message.nodesLogMaxOpenedFiles = $root.immudb.schema.NullableUint32.decode(reader, reader.uint32());
                            break;
                        }
                    case 10: {
                            message.historyLogMaxOpenedFiles = $root.immudb.schema.NullableUint32.decode(reader, reader.uint32());
                            break;
                        }
                    case 11: {
                            message.commitLogMaxOpenedFiles = $root.immudb.schema.NullableUint32.decode(reader, reader.uint32());
                            break;
                        }
                    case 12: {
                            message.flushBufferSize = $root.immudb.schema.NullableUint32.decode(reader, reader.uint32());
                            break;
                        }
                    case 13: {
                            message.cleanupPercentage = $root.immudb.schema.NullableFloat.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an IndexNullableSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.IndexNullableSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.IndexNullableSettings} IndexNullableSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IndexNullableSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an IndexNullableSettings message.
             * @function verify
             * @memberof immudb.schema.IndexNullableSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IndexNullableSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flushThreshold != null && message.hasOwnProperty("flushThreshold")) {
                    let error = $root.immudb.schema.NullableUint32.verify(message.flushThreshold);
                    if (error)
                        return "flushThreshold." + error;
                }
                if (message.syncThreshold != null && message.hasOwnProperty("syncThreshold")) {
                    let error = $root.immudb.schema.NullableUint32.verify(message.syncThreshold);
                    if (error)
                        return "syncThreshold." + error;
                }
                if (message.cacheSize != null && message.hasOwnProperty("cacheSize")) {
                    let error = $root.immudb.schema.NullableUint32.verify(message.cacheSize);
                    if (error)
                        return "cacheSize." + error;
                }
                if (message.maxNodeSize != null && message.hasOwnProperty("maxNodeSize")) {
                    let error = $root.immudb.schema.NullableUint32.verify(message.maxNodeSize);
                    if (error)
                        return "maxNodeSize." + error;
                }
                if (message.maxActiveSnapshots != null && message.hasOwnProperty("maxActiveSnapshots")) {
                    let error = $root.immudb.schema.NullableUint32.verify(message.maxActiveSnapshots);
                    if (error)
                        return "maxActiveSnapshots." + error;
                }
                if (message.renewSnapRootAfter != null && message.hasOwnProperty("renewSnapRootAfter")) {
                    let error = $root.immudb.schema.NullableUint64.verify(message.renewSnapRootAfter);
                    if (error)
                        return "renewSnapRootAfter." + error;
                }
                if (message.compactionThld != null && message.hasOwnProperty("compactionThld")) {
                    let error = $root.immudb.schema.NullableUint32.verify(message.compactionThld);
                    if (error)
                        return "compactionThld." + error;
                }
                if (message.delayDuringCompaction != null && message.hasOwnProperty("delayDuringCompaction")) {
                    let error = $root.immudb.schema.NullableUint32.verify(message.delayDuringCompaction);
                    if (error)
                        return "delayDuringCompaction." + error;
                }
                if (message.nodesLogMaxOpenedFiles != null && message.hasOwnProperty("nodesLogMaxOpenedFiles")) {
                    let error = $root.immudb.schema.NullableUint32.verify(message.nodesLogMaxOpenedFiles);
                    if (error)
                        return "nodesLogMaxOpenedFiles." + error;
                }
                if (message.historyLogMaxOpenedFiles != null && message.hasOwnProperty("historyLogMaxOpenedFiles")) {
                    let error = $root.immudb.schema.NullableUint32.verify(message.historyLogMaxOpenedFiles);
                    if (error)
                        return "historyLogMaxOpenedFiles." + error;
                }
                if (message.commitLogMaxOpenedFiles != null && message.hasOwnProperty("commitLogMaxOpenedFiles")) {
                    let error = $root.immudb.schema.NullableUint32.verify(message.commitLogMaxOpenedFiles);
                    if (error)
                        return "commitLogMaxOpenedFiles." + error;
                }
                if (message.flushBufferSize != null && message.hasOwnProperty("flushBufferSize")) {
                    let error = $root.immudb.schema.NullableUint32.verify(message.flushBufferSize);
                    if (error)
                        return "flushBufferSize." + error;
                }
                if (message.cleanupPercentage != null && message.hasOwnProperty("cleanupPercentage")) {
                    let error = $root.immudb.schema.NullableFloat.verify(message.cleanupPercentage);
                    if (error)
                        return "cleanupPercentage." + error;
                }
                return null;
            };

            /**
             * Creates an IndexNullableSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.IndexNullableSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.IndexNullableSettings} IndexNullableSettings
             */
            IndexNullableSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.IndexNullableSettings)
                    return object;
                let message = new $root.immudb.schema.IndexNullableSettings();
                if (object.flushThreshold != null) {
                    if (typeof object.flushThreshold !== "object")
                        throw TypeError(".immudb.schema.IndexNullableSettings.flushThreshold: object expected");
                    message.flushThreshold = $root.immudb.schema.NullableUint32.fromObject(object.flushThreshold);
                }
                if (object.syncThreshold != null) {
                    if (typeof object.syncThreshold !== "object")
                        throw TypeError(".immudb.schema.IndexNullableSettings.syncThreshold: object expected");
                    message.syncThreshold = $root.immudb.schema.NullableUint32.fromObject(object.syncThreshold);
                }
                if (object.cacheSize != null) {
                    if (typeof object.cacheSize !== "object")
                        throw TypeError(".immudb.schema.IndexNullableSettings.cacheSize: object expected");
                    message.cacheSize = $root.immudb.schema.NullableUint32.fromObject(object.cacheSize);
                }
                if (object.maxNodeSize != null) {
                    if (typeof object.maxNodeSize !== "object")
                        throw TypeError(".immudb.schema.IndexNullableSettings.maxNodeSize: object expected");
                    message.maxNodeSize = $root.immudb.schema.NullableUint32.fromObject(object.maxNodeSize);
                }
                if (object.maxActiveSnapshots != null) {
                    if (typeof object.maxActiveSnapshots !== "object")
                        throw TypeError(".immudb.schema.IndexNullableSettings.maxActiveSnapshots: object expected");
                    message.maxActiveSnapshots = $root.immudb.schema.NullableUint32.fromObject(object.maxActiveSnapshots);
                }
                if (object.renewSnapRootAfter != null) {
                    if (typeof object.renewSnapRootAfter !== "object")
                        throw TypeError(".immudb.schema.IndexNullableSettings.renewSnapRootAfter: object expected");
                    message.renewSnapRootAfter = $root.immudb.schema.NullableUint64.fromObject(object.renewSnapRootAfter);
                }
                if (object.compactionThld != null) {
                    if (typeof object.compactionThld !== "object")
                        throw TypeError(".immudb.schema.IndexNullableSettings.compactionThld: object expected");
                    message.compactionThld = $root.immudb.schema.NullableUint32.fromObject(object.compactionThld);
                }
                if (object.delayDuringCompaction != null) {
                    if (typeof object.delayDuringCompaction !== "object")
                        throw TypeError(".immudb.schema.IndexNullableSettings.delayDuringCompaction: object expected");
                    message.delayDuringCompaction = $root.immudb.schema.NullableUint32.fromObject(object.delayDuringCompaction);
                }
                if (object.nodesLogMaxOpenedFiles != null) {
                    if (typeof object.nodesLogMaxOpenedFiles !== "object")
                        throw TypeError(".immudb.schema.IndexNullableSettings.nodesLogMaxOpenedFiles: object expected");
                    message.nodesLogMaxOpenedFiles = $root.immudb.schema.NullableUint32.fromObject(object.nodesLogMaxOpenedFiles);
                }
                if (object.historyLogMaxOpenedFiles != null) {
                    if (typeof object.historyLogMaxOpenedFiles !== "object")
                        throw TypeError(".immudb.schema.IndexNullableSettings.historyLogMaxOpenedFiles: object expected");
                    message.historyLogMaxOpenedFiles = $root.immudb.schema.NullableUint32.fromObject(object.historyLogMaxOpenedFiles);
                }
                if (object.commitLogMaxOpenedFiles != null) {
                    if (typeof object.commitLogMaxOpenedFiles !== "object")
                        throw TypeError(".immudb.schema.IndexNullableSettings.commitLogMaxOpenedFiles: object expected");
                    message.commitLogMaxOpenedFiles = $root.immudb.schema.NullableUint32.fromObject(object.commitLogMaxOpenedFiles);
                }
                if (object.flushBufferSize != null) {
                    if (typeof object.flushBufferSize !== "object")
                        throw TypeError(".immudb.schema.IndexNullableSettings.flushBufferSize: object expected");
                    message.flushBufferSize = $root.immudb.schema.NullableUint32.fromObject(object.flushBufferSize);
                }
                if (object.cleanupPercentage != null) {
                    if (typeof object.cleanupPercentage !== "object")
                        throw TypeError(".immudb.schema.IndexNullableSettings.cleanupPercentage: object expected");
                    message.cleanupPercentage = $root.immudb.schema.NullableFloat.fromObject(object.cleanupPercentage);
                }
                return message;
            };

            /**
             * Creates a plain object from an IndexNullableSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.IndexNullableSettings
             * @static
             * @param {immudb.schema.IndexNullableSettings} message IndexNullableSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IndexNullableSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.flushThreshold = null;
                    object.syncThreshold = null;
                    object.cacheSize = null;
                    object.maxNodeSize = null;
                    object.maxActiveSnapshots = null;
                    object.renewSnapRootAfter = null;
                    object.compactionThld = null;
                    object.delayDuringCompaction = null;
                    object.nodesLogMaxOpenedFiles = null;
                    object.historyLogMaxOpenedFiles = null;
                    object.commitLogMaxOpenedFiles = null;
                    object.flushBufferSize = null;
                    object.cleanupPercentage = null;
                }
                if (message.flushThreshold != null && message.hasOwnProperty("flushThreshold"))
                    object.flushThreshold = $root.immudb.schema.NullableUint32.toObject(message.flushThreshold, options);
                if (message.syncThreshold != null && message.hasOwnProperty("syncThreshold"))
                    object.syncThreshold = $root.immudb.schema.NullableUint32.toObject(message.syncThreshold, options);
                if (message.cacheSize != null && message.hasOwnProperty("cacheSize"))
                    object.cacheSize = $root.immudb.schema.NullableUint32.toObject(message.cacheSize, options);
                if (message.maxNodeSize != null && message.hasOwnProperty("maxNodeSize"))
                    object.maxNodeSize = $root.immudb.schema.NullableUint32.toObject(message.maxNodeSize, options);
                if (message.maxActiveSnapshots != null && message.hasOwnProperty("maxActiveSnapshots"))
                    object.maxActiveSnapshots = $root.immudb.schema.NullableUint32.toObject(message.maxActiveSnapshots, options);
                if (message.renewSnapRootAfter != null && message.hasOwnProperty("renewSnapRootAfter"))
                    object.renewSnapRootAfter = $root.immudb.schema.NullableUint64.toObject(message.renewSnapRootAfter, options);
                if (message.compactionThld != null && message.hasOwnProperty("compactionThld"))
                    object.compactionThld = $root.immudb.schema.NullableUint32.toObject(message.compactionThld, options);
                if (message.delayDuringCompaction != null && message.hasOwnProperty("delayDuringCompaction"))
                    object.delayDuringCompaction = $root.immudb.schema.NullableUint32.toObject(message.delayDuringCompaction, options);
                if (message.nodesLogMaxOpenedFiles != null && message.hasOwnProperty("nodesLogMaxOpenedFiles"))
                    object.nodesLogMaxOpenedFiles = $root.immudb.schema.NullableUint32.toObject(message.nodesLogMaxOpenedFiles, options);
                if (message.historyLogMaxOpenedFiles != null && message.hasOwnProperty("historyLogMaxOpenedFiles"))
                    object.historyLogMaxOpenedFiles = $root.immudb.schema.NullableUint32.toObject(message.historyLogMaxOpenedFiles, options);
                if (message.commitLogMaxOpenedFiles != null && message.hasOwnProperty("commitLogMaxOpenedFiles"))
                    object.commitLogMaxOpenedFiles = $root.immudb.schema.NullableUint32.toObject(message.commitLogMaxOpenedFiles, options);
                if (message.flushBufferSize != null && message.hasOwnProperty("flushBufferSize"))
                    object.flushBufferSize = $root.immudb.schema.NullableUint32.toObject(message.flushBufferSize, options);
                if (message.cleanupPercentage != null && message.hasOwnProperty("cleanupPercentage"))
                    object.cleanupPercentage = $root.immudb.schema.NullableFloat.toObject(message.cleanupPercentage, options);
                return object;
            };

            /**
             * Converts this IndexNullableSettings to JSON.
             * @function toJSON
             * @memberof immudb.schema.IndexNullableSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IndexNullableSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for IndexNullableSettings
             * @function getTypeUrl
             * @memberof immudb.schema.IndexNullableSettings
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            IndexNullableSettings.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.IndexNullableSettings";
            };

            return IndexNullableSettings;
        })();

        schema.LoadDatabaseRequest = (function() {

            /**
             * Properties of a LoadDatabaseRequest.
             * @memberof immudb.schema
             * @interface ILoadDatabaseRequest
             * @property {string|null} [database] LoadDatabaseRequest database
             */

            /**
             * Constructs a new LoadDatabaseRequest.
             * @memberof immudb.schema
             * @classdesc Represents a LoadDatabaseRequest.
             * @implements ILoadDatabaseRequest
             * @constructor
             * @param {immudb.schema.ILoadDatabaseRequest=} [properties] Properties to set
             */
            function LoadDatabaseRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LoadDatabaseRequest database.
             * @member {string} database
             * @memberof immudb.schema.LoadDatabaseRequest
             * @instance
             */
            LoadDatabaseRequest.prototype.database = "";

            /**
             * Creates a new LoadDatabaseRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.LoadDatabaseRequest
             * @static
             * @param {immudb.schema.ILoadDatabaseRequest=} [properties] Properties to set
             * @returns {immudb.schema.LoadDatabaseRequest} LoadDatabaseRequest instance
             */
            LoadDatabaseRequest.create = function create(properties) {
                return new LoadDatabaseRequest(properties);
            };

            /**
             * Encodes the specified LoadDatabaseRequest message. Does not implicitly {@link immudb.schema.LoadDatabaseRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.LoadDatabaseRequest
             * @static
             * @param {immudb.schema.ILoadDatabaseRequest} message LoadDatabaseRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadDatabaseRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.database);
                return writer;
            };

            /**
             * Encodes the specified LoadDatabaseRequest message, length delimited. Does not implicitly {@link immudb.schema.LoadDatabaseRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.LoadDatabaseRequest
             * @static
             * @param {immudb.schema.ILoadDatabaseRequest} message LoadDatabaseRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadDatabaseRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LoadDatabaseRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.LoadDatabaseRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.LoadDatabaseRequest} LoadDatabaseRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadDatabaseRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.LoadDatabaseRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.database = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LoadDatabaseRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.LoadDatabaseRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.LoadDatabaseRequest} LoadDatabaseRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadDatabaseRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LoadDatabaseRequest message.
             * @function verify
             * @memberof immudb.schema.LoadDatabaseRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LoadDatabaseRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isString(message.database))
                        return "database: string expected";
                return null;
            };

            /**
             * Creates a LoadDatabaseRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.LoadDatabaseRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.LoadDatabaseRequest} LoadDatabaseRequest
             */
            LoadDatabaseRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.LoadDatabaseRequest)
                    return object;
                let message = new $root.immudb.schema.LoadDatabaseRequest();
                if (object.database != null)
                    message.database = String(object.database);
                return message;
            };

            /**
             * Creates a plain object from a LoadDatabaseRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.LoadDatabaseRequest
             * @static
             * @param {immudb.schema.LoadDatabaseRequest} message LoadDatabaseRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LoadDatabaseRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.database = "";
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                return object;
            };

            /**
             * Converts this LoadDatabaseRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.LoadDatabaseRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LoadDatabaseRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LoadDatabaseRequest
             * @function getTypeUrl
             * @memberof immudb.schema.LoadDatabaseRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LoadDatabaseRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.LoadDatabaseRequest";
            };

            return LoadDatabaseRequest;
        })();

        schema.LoadDatabaseResponse = (function() {

            /**
             * Properties of a LoadDatabaseResponse.
             * @memberof immudb.schema
             * @interface ILoadDatabaseResponse
             * @property {string|null} [database] LoadDatabaseResponse database
             */

            /**
             * Constructs a new LoadDatabaseResponse.
             * @memberof immudb.schema
             * @classdesc Represents a LoadDatabaseResponse.
             * @implements ILoadDatabaseResponse
             * @constructor
             * @param {immudb.schema.ILoadDatabaseResponse=} [properties] Properties to set
             */
            function LoadDatabaseResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LoadDatabaseResponse database.
             * @member {string} database
             * @memberof immudb.schema.LoadDatabaseResponse
             * @instance
             */
            LoadDatabaseResponse.prototype.database = "";

            /**
             * Creates a new LoadDatabaseResponse instance using the specified properties.
             * @function create
             * @memberof immudb.schema.LoadDatabaseResponse
             * @static
             * @param {immudb.schema.ILoadDatabaseResponse=} [properties] Properties to set
             * @returns {immudb.schema.LoadDatabaseResponse} LoadDatabaseResponse instance
             */
            LoadDatabaseResponse.create = function create(properties) {
                return new LoadDatabaseResponse(properties);
            };

            /**
             * Encodes the specified LoadDatabaseResponse message. Does not implicitly {@link immudb.schema.LoadDatabaseResponse.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.LoadDatabaseResponse
             * @static
             * @param {immudb.schema.ILoadDatabaseResponse} message LoadDatabaseResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadDatabaseResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.database);
                return writer;
            };

            /**
             * Encodes the specified LoadDatabaseResponse message, length delimited. Does not implicitly {@link immudb.schema.LoadDatabaseResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.LoadDatabaseResponse
             * @static
             * @param {immudb.schema.ILoadDatabaseResponse} message LoadDatabaseResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadDatabaseResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LoadDatabaseResponse message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.LoadDatabaseResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.LoadDatabaseResponse} LoadDatabaseResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadDatabaseResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.LoadDatabaseResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.database = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LoadDatabaseResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.LoadDatabaseResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.LoadDatabaseResponse} LoadDatabaseResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadDatabaseResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LoadDatabaseResponse message.
             * @function verify
             * @memberof immudb.schema.LoadDatabaseResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LoadDatabaseResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isString(message.database))
                        return "database: string expected";
                return null;
            };

            /**
             * Creates a LoadDatabaseResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.LoadDatabaseResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.LoadDatabaseResponse} LoadDatabaseResponse
             */
            LoadDatabaseResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.LoadDatabaseResponse)
                    return object;
                let message = new $root.immudb.schema.LoadDatabaseResponse();
                if (object.database != null)
                    message.database = String(object.database);
                return message;
            };

            /**
             * Creates a plain object from a LoadDatabaseResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.LoadDatabaseResponse
             * @static
             * @param {immudb.schema.LoadDatabaseResponse} message LoadDatabaseResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LoadDatabaseResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.database = "";
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                return object;
            };

            /**
             * Converts this LoadDatabaseResponse to JSON.
             * @function toJSON
             * @memberof immudb.schema.LoadDatabaseResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LoadDatabaseResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LoadDatabaseResponse
             * @function getTypeUrl
             * @memberof immudb.schema.LoadDatabaseResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LoadDatabaseResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.LoadDatabaseResponse";
            };

            return LoadDatabaseResponse;
        })();

        schema.UnloadDatabaseRequest = (function() {

            /**
             * Properties of an UnloadDatabaseRequest.
             * @memberof immudb.schema
             * @interface IUnloadDatabaseRequest
             * @property {string|null} [database] UnloadDatabaseRequest database
             */

            /**
             * Constructs a new UnloadDatabaseRequest.
             * @memberof immudb.schema
             * @classdesc Represents an UnloadDatabaseRequest.
             * @implements IUnloadDatabaseRequest
             * @constructor
             * @param {immudb.schema.IUnloadDatabaseRequest=} [properties] Properties to set
             */
            function UnloadDatabaseRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UnloadDatabaseRequest database.
             * @member {string} database
             * @memberof immudb.schema.UnloadDatabaseRequest
             * @instance
             */
            UnloadDatabaseRequest.prototype.database = "";

            /**
             * Creates a new UnloadDatabaseRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.UnloadDatabaseRequest
             * @static
             * @param {immudb.schema.IUnloadDatabaseRequest=} [properties] Properties to set
             * @returns {immudb.schema.UnloadDatabaseRequest} UnloadDatabaseRequest instance
             */
            UnloadDatabaseRequest.create = function create(properties) {
                return new UnloadDatabaseRequest(properties);
            };

            /**
             * Encodes the specified UnloadDatabaseRequest message. Does not implicitly {@link immudb.schema.UnloadDatabaseRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.UnloadDatabaseRequest
             * @static
             * @param {immudb.schema.IUnloadDatabaseRequest} message UnloadDatabaseRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnloadDatabaseRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.database);
                return writer;
            };

            /**
             * Encodes the specified UnloadDatabaseRequest message, length delimited. Does not implicitly {@link immudb.schema.UnloadDatabaseRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.UnloadDatabaseRequest
             * @static
             * @param {immudb.schema.IUnloadDatabaseRequest} message UnloadDatabaseRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnloadDatabaseRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UnloadDatabaseRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.UnloadDatabaseRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.UnloadDatabaseRequest} UnloadDatabaseRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnloadDatabaseRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.UnloadDatabaseRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.database = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UnloadDatabaseRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.UnloadDatabaseRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.UnloadDatabaseRequest} UnloadDatabaseRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnloadDatabaseRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UnloadDatabaseRequest message.
             * @function verify
             * @memberof immudb.schema.UnloadDatabaseRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UnloadDatabaseRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isString(message.database))
                        return "database: string expected";
                return null;
            };

            /**
             * Creates an UnloadDatabaseRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.UnloadDatabaseRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.UnloadDatabaseRequest} UnloadDatabaseRequest
             */
            UnloadDatabaseRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.UnloadDatabaseRequest)
                    return object;
                let message = new $root.immudb.schema.UnloadDatabaseRequest();
                if (object.database != null)
                    message.database = String(object.database);
                return message;
            };

            /**
             * Creates a plain object from an UnloadDatabaseRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.UnloadDatabaseRequest
             * @static
             * @param {immudb.schema.UnloadDatabaseRequest} message UnloadDatabaseRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UnloadDatabaseRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.database = "";
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                return object;
            };

            /**
             * Converts this UnloadDatabaseRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.UnloadDatabaseRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UnloadDatabaseRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UnloadDatabaseRequest
             * @function getTypeUrl
             * @memberof immudb.schema.UnloadDatabaseRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UnloadDatabaseRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.UnloadDatabaseRequest";
            };

            return UnloadDatabaseRequest;
        })();

        schema.UnloadDatabaseResponse = (function() {

            /**
             * Properties of an UnloadDatabaseResponse.
             * @memberof immudb.schema
             * @interface IUnloadDatabaseResponse
             * @property {string|null} [database] UnloadDatabaseResponse database
             */

            /**
             * Constructs a new UnloadDatabaseResponse.
             * @memberof immudb.schema
             * @classdesc Represents an UnloadDatabaseResponse.
             * @implements IUnloadDatabaseResponse
             * @constructor
             * @param {immudb.schema.IUnloadDatabaseResponse=} [properties] Properties to set
             */
            function UnloadDatabaseResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UnloadDatabaseResponse database.
             * @member {string} database
             * @memberof immudb.schema.UnloadDatabaseResponse
             * @instance
             */
            UnloadDatabaseResponse.prototype.database = "";

            /**
             * Creates a new UnloadDatabaseResponse instance using the specified properties.
             * @function create
             * @memberof immudb.schema.UnloadDatabaseResponse
             * @static
             * @param {immudb.schema.IUnloadDatabaseResponse=} [properties] Properties to set
             * @returns {immudb.schema.UnloadDatabaseResponse} UnloadDatabaseResponse instance
             */
            UnloadDatabaseResponse.create = function create(properties) {
                return new UnloadDatabaseResponse(properties);
            };

            /**
             * Encodes the specified UnloadDatabaseResponse message. Does not implicitly {@link immudb.schema.UnloadDatabaseResponse.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.UnloadDatabaseResponse
             * @static
             * @param {immudb.schema.IUnloadDatabaseResponse} message UnloadDatabaseResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnloadDatabaseResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.database);
                return writer;
            };

            /**
             * Encodes the specified UnloadDatabaseResponse message, length delimited. Does not implicitly {@link immudb.schema.UnloadDatabaseResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.UnloadDatabaseResponse
             * @static
             * @param {immudb.schema.IUnloadDatabaseResponse} message UnloadDatabaseResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnloadDatabaseResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UnloadDatabaseResponse message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.UnloadDatabaseResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.UnloadDatabaseResponse} UnloadDatabaseResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnloadDatabaseResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.UnloadDatabaseResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.database = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UnloadDatabaseResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.UnloadDatabaseResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.UnloadDatabaseResponse} UnloadDatabaseResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnloadDatabaseResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UnloadDatabaseResponse message.
             * @function verify
             * @memberof immudb.schema.UnloadDatabaseResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UnloadDatabaseResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isString(message.database))
                        return "database: string expected";
                return null;
            };

            /**
             * Creates an UnloadDatabaseResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.UnloadDatabaseResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.UnloadDatabaseResponse} UnloadDatabaseResponse
             */
            UnloadDatabaseResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.UnloadDatabaseResponse)
                    return object;
                let message = new $root.immudb.schema.UnloadDatabaseResponse();
                if (object.database != null)
                    message.database = String(object.database);
                return message;
            };

            /**
             * Creates a plain object from an UnloadDatabaseResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.UnloadDatabaseResponse
             * @static
             * @param {immudb.schema.UnloadDatabaseResponse} message UnloadDatabaseResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UnloadDatabaseResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.database = "";
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                return object;
            };

            /**
             * Converts this UnloadDatabaseResponse to JSON.
             * @function toJSON
             * @memberof immudb.schema.UnloadDatabaseResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UnloadDatabaseResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UnloadDatabaseResponse
             * @function getTypeUrl
             * @memberof immudb.schema.UnloadDatabaseResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UnloadDatabaseResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.UnloadDatabaseResponse";
            };

            return UnloadDatabaseResponse;
        })();

        schema.DeleteDatabaseRequest = (function() {

            /**
             * Properties of a DeleteDatabaseRequest.
             * @memberof immudb.schema
             * @interface IDeleteDatabaseRequest
             * @property {string|null} [database] DeleteDatabaseRequest database
             */

            /**
             * Constructs a new DeleteDatabaseRequest.
             * @memberof immudb.schema
             * @classdesc Represents a DeleteDatabaseRequest.
             * @implements IDeleteDatabaseRequest
             * @constructor
             * @param {immudb.schema.IDeleteDatabaseRequest=} [properties] Properties to set
             */
            function DeleteDatabaseRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteDatabaseRequest database.
             * @member {string} database
             * @memberof immudb.schema.DeleteDatabaseRequest
             * @instance
             */
            DeleteDatabaseRequest.prototype.database = "";

            /**
             * Creates a new DeleteDatabaseRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.DeleteDatabaseRequest
             * @static
             * @param {immudb.schema.IDeleteDatabaseRequest=} [properties] Properties to set
             * @returns {immudb.schema.DeleteDatabaseRequest} DeleteDatabaseRequest instance
             */
            DeleteDatabaseRequest.create = function create(properties) {
                return new DeleteDatabaseRequest(properties);
            };

            /**
             * Encodes the specified DeleteDatabaseRequest message. Does not implicitly {@link immudb.schema.DeleteDatabaseRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.DeleteDatabaseRequest
             * @static
             * @param {immudb.schema.IDeleteDatabaseRequest} message DeleteDatabaseRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteDatabaseRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.database);
                return writer;
            };

            /**
             * Encodes the specified DeleteDatabaseRequest message, length delimited. Does not implicitly {@link immudb.schema.DeleteDatabaseRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.DeleteDatabaseRequest
             * @static
             * @param {immudb.schema.IDeleteDatabaseRequest} message DeleteDatabaseRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteDatabaseRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteDatabaseRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.DeleteDatabaseRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.DeleteDatabaseRequest} DeleteDatabaseRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteDatabaseRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.DeleteDatabaseRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.database = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteDatabaseRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.DeleteDatabaseRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.DeleteDatabaseRequest} DeleteDatabaseRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteDatabaseRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteDatabaseRequest message.
             * @function verify
             * @memberof immudb.schema.DeleteDatabaseRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteDatabaseRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isString(message.database))
                        return "database: string expected";
                return null;
            };

            /**
             * Creates a DeleteDatabaseRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.DeleteDatabaseRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.DeleteDatabaseRequest} DeleteDatabaseRequest
             */
            DeleteDatabaseRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.DeleteDatabaseRequest)
                    return object;
                let message = new $root.immudb.schema.DeleteDatabaseRequest();
                if (object.database != null)
                    message.database = String(object.database);
                return message;
            };

            /**
             * Creates a plain object from a DeleteDatabaseRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.DeleteDatabaseRequest
             * @static
             * @param {immudb.schema.DeleteDatabaseRequest} message DeleteDatabaseRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteDatabaseRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.database = "";
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                return object;
            };

            /**
             * Converts this DeleteDatabaseRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.DeleteDatabaseRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteDatabaseRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteDatabaseRequest
             * @function getTypeUrl
             * @memberof immudb.schema.DeleteDatabaseRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteDatabaseRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.DeleteDatabaseRequest";
            };

            return DeleteDatabaseRequest;
        })();

        schema.DeleteDatabaseResponse = (function() {

            /**
             * Properties of a DeleteDatabaseResponse.
             * @memberof immudb.schema
             * @interface IDeleteDatabaseResponse
             * @property {string|null} [database] DeleteDatabaseResponse database
             */

            /**
             * Constructs a new DeleteDatabaseResponse.
             * @memberof immudb.schema
             * @classdesc Represents a DeleteDatabaseResponse.
             * @implements IDeleteDatabaseResponse
             * @constructor
             * @param {immudb.schema.IDeleteDatabaseResponse=} [properties] Properties to set
             */
            function DeleteDatabaseResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteDatabaseResponse database.
             * @member {string} database
             * @memberof immudb.schema.DeleteDatabaseResponse
             * @instance
             */
            DeleteDatabaseResponse.prototype.database = "";

            /**
             * Creates a new DeleteDatabaseResponse instance using the specified properties.
             * @function create
             * @memberof immudb.schema.DeleteDatabaseResponse
             * @static
             * @param {immudb.schema.IDeleteDatabaseResponse=} [properties] Properties to set
             * @returns {immudb.schema.DeleteDatabaseResponse} DeleteDatabaseResponse instance
             */
            DeleteDatabaseResponse.create = function create(properties) {
                return new DeleteDatabaseResponse(properties);
            };

            /**
             * Encodes the specified DeleteDatabaseResponse message. Does not implicitly {@link immudb.schema.DeleteDatabaseResponse.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.DeleteDatabaseResponse
             * @static
             * @param {immudb.schema.IDeleteDatabaseResponse} message DeleteDatabaseResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteDatabaseResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.database);
                return writer;
            };

            /**
             * Encodes the specified DeleteDatabaseResponse message, length delimited. Does not implicitly {@link immudb.schema.DeleteDatabaseResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.DeleteDatabaseResponse
             * @static
             * @param {immudb.schema.IDeleteDatabaseResponse} message DeleteDatabaseResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteDatabaseResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteDatabaseResponse message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.DeleteDatabaseResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.DeleteDatabaseResponse} DeleteDatabaseResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteDatabaseResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.DeleteDatabaseResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.database = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteDatabaseResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.DeleteDatabaseResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.DeleteDatabaseResponse} DeleteDatabaseResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteDatabaseResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteDatabaseResponse message.
             * @function verify
             * @memberof immudb.schema.DeleteDatabaseResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteDatabaseResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isString(message.database))
                        return "database: string expected";
                return null;
            };

            /**
             * Creates a DeleteDatabaseResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.DeleteDatabaseResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.DeleteDatabaseResponse} DeleteDatabaseResponse
             */
            DeleteDatabaseResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.DeleteDatabaseResponse)
                    return object;
                let message = new $root.immudb.schema.DeleteDatabaseResponse();
                if (object.database != null)
                    message.database = String(object.database);
                return message;
            };

            /**
             * Creates a plain object from a DeleteDatabaseResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.DeleteDatabaseResponse
             * @static
             * @param {immudb.schema.DeleteDatabaseResponse} message DeleteDatabaseResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteDatabaseResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.database = "";
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                return object;
            };

            /**
             * Converts this DeleteDatabaseResponse to JSON.
             * @function toJSON
             * @memberof immudb.schema.DeleteDatabaseResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteDatabaseResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteDatabaseResponse
             * @function getTypeUrl
             * @memberof immudb.schema.DeleteDatabaseResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteDatabaseResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.DeleteDatabaseResponse";
            };

            return DeleteDatabaseResponse;
        })();

        schema.FlushIndexRequest = (function() {

            /**
             * Properties of a FlushIndexRequest.
             * @memberof immudb.schema
             * @interface IFlushIndexRequest
             * @property {number|null} [cleanupPercentage] FlushIndexRequest cleanupPercentage
             * @property {boolean|null} [synced] FlushIndexRequest synced
             */

            /**
             * Constructs a new FlushIndexRequest.
             * @memberof immudb.schema
             * @classdesc Represents a FlushIndexRequest.
             * @implements IFlushIndexRequest
             * @constructor
             * @param {immudb.schema.IFlushIndexRequest=} [properties] Properties to set
             */
            function FlushIndexRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FlushIndexRequest cleanupPercentage.
             * @member {number} cleanupPercentage
             * @memberof immudb.schema.FlushIndexRequest
             * @instance
             */
            FlushIndexRequest.prototype.cleanupPercentage = 0;

            /**
             * FlushIndexRequest synced.
             * @member {boolean} synced
             * @memberof immudb.schema.FlushIndexRequest
             * @instance
             */
            FlushIndexRequest.prototype.synced = false;

            /**
             * Creates a new FlushIndexRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.FlushIndexRequest
             * @static
             * @param {immudb.schema.IFlushIndexRequest=} [properties] Properties to set
             * @returns {immudb.schema.FlushIndexRequest} FlushIndexRequest instance
             */
            FlushIndexRequest.create = function create(properties) {
                return new FlushIndexRequest(properties);
            };

            /**
             * Encodes the specified FlushIndexRequest message. Does not implicitly {@link immudb.schema.FlushIndexRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.FlushIndexRequest
             * @static
             * @param {immudb.schema.IFlushIndexRequest} message FlushIndexRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FlushIndexRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.cleanupPercentage != null && Object.hasOwnProperty.call(message, "cleanupPercentage"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.cleanupPercentage);
                if (message.synced != null && Object.hasOwnProperty.call(message, "synced"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.synced);
                return writer;
            };

            /**
             * Encodes the specified FlushIndexRequest message, length delimited. Does not implicitly {@link immudb.schema.FlushIndexRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.FlushIndexRequest
             * @static
             * @param {immudb.schema.IFlushIndexRequest} message FlushIndexRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FlushIndexRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FlushIndexRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.FlushIndexRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.FlushIndexRequest} FlushIndexRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FlushIndexRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.FlushIndexRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.cleanupPercentage = reader.float();
                            break;
                        }
                    case 2: {
                            message.synced = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FlushIndexRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.FlushIndexRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.FlushIndexRequest} FlushIndexRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FlushIndexRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FlushIndexRequest message.
             * @function verify
             * @memberof immudb.schema.FlushIndexRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FlushIndexRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.cleanupPercentage != null && message.hasOwnProperty("cleanupPercentage"))
                    if (typeof message.cleanupPercentage !== "number")
                        return "cleanupPercentage: number expected";
                if (message.synced != null && message.hasOwnProperty("synced"))
                    if (typeof message.synced !== "boolean")
                        return "synced: boolean expected";
                return null;
            };

            /**
             * Creates a FlushIndexRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.FlushIndexRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.FlushIndexRequest} FlushIndexRequest
             */
            FlushIndexRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.FlushIndexRequest)
                    return object;
                let message = new $root.immudb.schema.FlushIndexRequest();
                if (object.cleanupPercentage != null)
                    message.cleanupPercentage = Number(object.cleanupPercentage);
                if (object.synced != null)
                    message.synced = Boolean(object.synced);
                return message;
            };

            /**
             * Creates a plain object from a FlushIndexRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.FlushIndexRequest
             * @static
             * @param {immudb.schema.FlushIndexRequest} message FlushIndexRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FlushIndexRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.cleanupPercentage = 0;
                    object.synced = false;
                }
                if (message.cleanupPercentage != null && message.hasOwnProperty("cleanupPercentage"))
                    object.cleanupPercentage = options.json && !isFinite(message.cleanupPercentage) ? String(message.cleanupPercentage) : message.cleanupPercentage;
                if (message.synced != null && message.hasOwnProperty("synced"))
                    object.synced = message.synced;
                return object;
            };

            /**
             * Converts this FlushIndexRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.FlushIndexRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FlushIndexRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FlushIndexRequest
             * @function getTypeUrl
             * @memberof immudb.schema.FlushIndexRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FlushIndexRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.FlushIndexRequest";
            };

            return FlushIndexRequest;
        })();

        schema.FlushIndexResponse = (function() {

            /**
             * Properties of a FlushIndexResponse.
             * @memberof immudb.schema
             * @interface IFlushIndexResponse
             * @property {string|null} [database] FlushIndexResponse database
             */

            /**
             * Constructs a new FlushIndexResponse.
             * @memberof immudb.schema
             * @classdesc Represents a FlushIndexResponse.
             * @implements IFlushIndexResponse
             * @constructor
             * @param {immudb.schema.IFlushIndexResponse=} [properties] Properties to set
             */
            function FlushIndexResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FlushIndexResponse database.
             * @member {string} database
             * @memberof immudb.schema.FlushIndexResponse
             * @instance
             */
            FlushIndexResponse.prototype.database = "";

            /**
             * Creates a new FlushIndexResponse instance using the specified properties.
             * @function create
             * @memberof immudb.schema.FlushIndexResponse
             * @static
             * @param {immudb.schema.IFlushIndexResponse=} [properties] Properties to set
             * @returns {immudb.schema.FlushIndexResponse} FlushIndexResponse instance
             */
            FlushIndexResponse.create = function create(properties) {
                return new FlushIndexResponse(properties);
            };

            /**
             * Encodes the specified FlushIndexResponse message. Does not implicitly {@link immudb.schema.FlushIndexResponse.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.FlushIndexResponse
             * @static
             * @param {immudb.schema.IFlushIndexResponse} message FlushIndexResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FlushIndexResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.database);
                return writer;
            };

            /**
             * Encodes the specified FlushIndexResponse message, length delimited. Does not implicitly {@link immudb.schema.FlushIndexResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.FlushIndexResponse
             * @static
             * @param {immudb.schema.IFlushIndexResponse} message FlushIndexResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FlushIndexResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FlushIndexResponse message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.FlushIndexResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.FlushIndexResponse} FlushIndexResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FlushIndexResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.FlushIndexResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.database = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FlushIndexResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.FlushIndexResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.FlushIndexResponse} FlushIndexResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FlushIndexResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FlushIndexResponse message.
             * @function verify
             * @memberof immudb.schema.FlushIndexResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FlushIndexResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isString(message.database))
                        return "database: string expected";
                return null;
            };

            /**
             * Creates a FlushIndexResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.FlushIndexResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.FlushIndexResponse} FlushIndexResponse
             */
            FlushIndexResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.FlushIndexResponse)
                    return object;
                let message = new $root.immudb.schema.FlushIndexResponse();
                if (object.database != null)
                    message.database = String(object.database);
                return message;
            };

            /**
             * Creates a plain object from a FlushIndexResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.FlushIndexResponse
             * @static
             * @param {immudb.schema.FlushIndexResponse} message FlushIndexResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FlushIndexResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.database = "";
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                return object;
            };

            /**
             * Converts this FlushIndexResponse to JSON.
             * @function toJSON
             * @memberof immudb.schema.FlushIndexResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FlushIndexResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FlushIndexResponse
             * @function getTypeUrl
             * @memberof immudb.schema.FlushIndexResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FlushIndexResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.FlushIndexResponse";
            };

            return FlushIndexResponse;
        })();

        schema.Table = (function() {

            /**
             * Properties of a Table.
             * @memberof immudb.schema
             * @interface ITable
             * @property {string|null} [tableName] Table tableName
             */

            /**
             * Constructs a new Table.
             * @memberof immudb.schema
             * @classdesc Represents a Table.
             * @implements ITable
             * @constructor
             * @param {immudb.schema.ITable=} [properties] Properties to set
             */
            function Table(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Table tableName.
             * @member {string} tableName
             * @memberof immudb.schema.Table
             * @instance
             */
            Table.prototype.tableName = "";

            /**
             * Creates a new Table instance using the specified properties.
             * @function create
             * @memberof immudb.schema.Table
             * @static
             * @param {immudb.schema.ITable=} [properties] Properties to set
             * @returns {immudb.schema.Table} Table instance
             */
            Table.create = function create(properties) {
                return new Table(properties);
            };

            /**
             * Encodes the specified Table message. Does not implicitly {@link immudb.schema.Table.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.Table
             * @static
             * @param {immudb.schema.ITable} message Table message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Table.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tableName != null && Object.hasOwnProperty.call(message, "tableName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.tableName);
                return writer;
            };

            /**
             * Encodes the specified Table message, length delimited. Does not implicitly {@link immudb.schema.Table.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.Table
             * @static
             * @param {immudb.schema.ITable} message Table message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Table.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Table message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.Table
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.Table} Table
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Table.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.Table();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.tableName = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Table message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.Table
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.Table} Table
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Table.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Table message.
             * @function verify
             * @memberof immudb.schema.Table
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Table.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    if (!$util.isString(message.tableName))
                        return "tableName: string expected";
                return null;
            };

            /**
             * Creates a Table message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.Table
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.Table} Table
             */
            Table.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.Table)
                    return object;
                let message = new $root.immudb.schema.Table();
                if (object.tableName != null)
                    message.tableName = String(object.tableName);
                return message;
            };

            /**
             * Creates a plain object from a Table message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.Table
             * @static
             * @param {immudb.schema.Table} message Table
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Table.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.tableName = "";
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    object.tableName = message.tableName;
                return object;
            };

            /**
             * Converts this Table to JSON.
             * @function toJSON
             * @memberof immudb.schema.Table
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Table.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Table
             * @function getTypeUrl
             * @memberof immudb.schema.Table
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Table.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.Table";
            };

            return Table;
        })();

        schema.SQLGetRequest = (function() {

            /**
             * Properties of a SQLGetRequest.
             * @memberof immudb.schema
             * @interface ISQLGetRequest
             * @property {string|null} [table] SQLGetRequest table
             * @property {Array.<immudb.schema.ISQLValue>|null} [pkValues] SQLGetRequest pkValues
             * @property {Long|null} [atTx] SQLGetRequest atTx
             * @property {Long|null} [sinceTx] SQLGetRequest sinceTx
             */

            /**
             * Constructs a new SQLGetRequest.
             * @memberof immudb.schema
             * @classdesc Represents a SQLGetRequest.
             * @implements ISQLGetRequest
             * @constructor
             * @param {immudb.schema.ISQLGetRequest=} [properties] Properties to set
             */
            function SQLGetRequest(properties) {
                this.pkValues = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SQLGetRequest table.
             * @member {string} table
             * @memberof immudb.schema.SQLGetRequest
             * @instance
             */
            SQLGetRequest.prototype.table = "";

            /**
             * SQLGetRequest pkValues.
             * @member {Array.<immudb.schema.ISQLValue>} pkValues
             * @memberof immudb.schema.SQLGetRequest
             * @instance
             */
            SQLGetRequest.prototype.pkValues = $util.emptyArray;

            /**
             * SQLGetRequest atTx.
             * @member {Long} atTx
             * @memberof immudb.schema.SQLGetRequest
             * @instance
             */
            SQLGetRequest.prototype.atTx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SQLGetRequest sinceTx.
             * @member {Long} sinceTx
             * @memberof immudb.schema.SQLGetRequest
             * @instance
             */
            SQLGetRequest.prototype.sinceTx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new SQLGetRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.SQLGetRequest
             * @static
             * @param {immudb.schema.ISQLGetRequest=} [properties] Properties to set
             * @returns {immudb.schema.SQLGetRequest} SQLGetRequest instance
             */
            SQLGetRequest.create = function create(properties) {
                return new SQLGetRequest(properties);
            };

            /**
             * Encodes the specified SQLGetRequest message. Does not implicitly {@link immudb.schema.SQLGetRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.SQLGetRequest
             * @static
             * @param {immudb.schema.ISQLGetRequest} message SQLGetRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SQLGetRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.table != null && Object.hasOwnProperty.call(message, "table"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.table);
                if (message.pkValues != null && message.pkValues.length)
                    for (let i = 0; i < message.pkValues.length; ++i)
                        $root.immudb.schema.SQLValue.encode(message.pkValues[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.atTx != null && Object.hasOwnProperty.call(message, "atTx"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.atTx);
                if (message.sinceTx != null && Object.hasOwnProperty.call(message, "sinceTx"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.sinceTx);
                return writer;
            };

            /**
             * Encodes the specified SQLGetRequest message, length delimited. Does not implicitly {@link immudb.schema.SQLGetRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.SQLGetRequest
             * @static
             * @param {immudb.schema.ISQLGetRequest} message SQLGetRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SQLGetRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SQLGetRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.SQLGetRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.SQLGetRequest} SQLGetRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SQLGetRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.SQLGetRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.table = reader.string();
                            break;
                        }
                    case 2: {
                            if (!(message.pkValues && message.pkValues.length))
                                message.pkValues = [];
                            message.pkValues.push($root.immudb.schema.SQLValue.decode(reader, reader.uint32()));
                            break;
                        }
                    case 3: {
                            message.atTx = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.sinceTx = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SQLGetRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.SQLGetRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.SQLGetRequest} SQLGetRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SQLGetRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SQLGetRequest message.
             * @function verify
             * @memberof immudb.schema.SQLGetRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SQLGetRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.table != null && message.hasOwnProperty("table"))
                    if (!$util.isString(message.table))
                        return "table: string expected";
                if (message.pkValues != null && message.hasOwnProperty("pkValues")) {
                    if (!Array.isArray(message.pkValues))
                        return "pkValues: array expected";
                    for (let i = 0; i < message.pkValues.length; ++i) {
                        let error = $root.immudb.schema.SQLValue.verify(message.pkValues[i]);
                        if (error)
                            return "pkValues." + error;
                    }
                }
                if (message.atTx != null && message.hasOwnProperty("atTx"))
                    if (!$util.isInteger(message.atTx) && !(message.atTx && $util.isInteger(message.atTx.low) && $util.isInteger(message.atTx.high)))
                        return "atTx: integer|Long expected";
                if (message.sinceTx != null && message.hasOwnProperty("sinceTx"))
                    if (!$util.isInteger(message.sinceTx) && !(message.sinceTx && $util.isInteger(message.sinceTx.low) && $util.isInteger(message.sinceTx.high)))
                        return "sinceTx: integer|Long expected";
                return null;
            };

            /**
             * Creates a SQLGetRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.SQLGetRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.SQLGetRequest} SQLGetRequest
             */
            SQLGetRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.SQLGetRequest)
                    return object;
                let message = new $root.immudb.schema.SQLGetRequest();
                if (object.table != null)
                    message.table = String(object.table);
                if (object.pkValues) {
                    if (!Array.isArray(object.pkValues))
                        throw TypeError(".immudb.schema.SQLGetRequest.pkValues: array expected");
                    message.pkValues = [];
                    for (let i = 0; i < object.pkValues.length; ++i) {
                        if (typeof object.pkValues[i] !== "object")
                            throw TypeError(".immudb.schema.SQLGetRequest.pkValues: object expected");
                        message.pkValues[i] = $root.immudb.schema.SQLValue.fromObject(object.pkValues[i]);
                    }
                }
                if (object.atTx != null)
                    if ($util.Long)
                        (message.atTx = $util.Long.fromValue(object.atTx)).unsigned = true;
                    else if (typeof object.atTx === "string")
                        message.atTx = parseInt(object.atTx, 10);
                    else if (typeof object.atTx === "number")
                        message.atTx = object.atTx;
                    else if (typeof object.atTx === "object")
                        message.atTx = new $util.LongBits(object.atTx.low >>> 0, object.atTx.high >>> 0).toNumber(true);
                if (object.sinceTx != null)
                    if ($util.Long)
                        (message.sinceTx = $util.Long.fromValue(object.sinceTx)).unsigned = true;
                    else if (typeof object.sinceTx === "string")
                        message.sinceTx = parseInt(object.sinceTx, 10);
                    else if (typeof object.sinceTx === "number")
                        message.sinceTx = object.sinceTx;
                    else if (typeof object.sinceTx === "object")
                        message.sinceTx = new $util.LongBits(object.sinceTx.low >>> 0, object.sinceTx.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a SQLGetRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.SQLGetRequest
             * @static
             * @param {immudb.schema.SQLGetRequest} message SQLGetRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SQLGetRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.pkValues = [];
                if (options.defaults) {
                    object.table = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.atTx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.atTx = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.sinceTx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sinceTx = options.longs === String ? "0" : 0;
                }
                if (message.table != null && message.hasOwnProperty("table"))
                    object.table = message.table;
                if (message.pkValues && message.pkValues.length) {
                    object.pkValues = [];
                    for (let j = 0; j < message.pkValues.length; ++j)
                        object.pkValues[j] = $root.immudb.schema.SQLValue.toObject(message.pkValues[j], options);
                }
                if (message.atTx != null && message.hasOwnProperty("atTx"))
                    if (typeof message.atTx === "number")
                        object.atTx = options.longs === String ? String(message.atTx) : message.atTx;
                    else
                        object.atTx = options.longs === String ? $util.Long.prototype.toString.call(message.atTx) : options.longs === Number ? new $util.LongBits(message.atTx.low >>> 0, message.atTx.high >>> 0).toNumber(true) : message.atTx;
                if (message.sinceTx != null && message.hasOwnProperty("sinceTx"))
                    if (typeof message.sinceTx === "number")
                        object.sinceTx = options.longs === String ? String(message.sinceTx) : message.sinceTx;
                    else
                        object.sinceTx = options.longs === String ? $util.Long.prototype.toString.call(message.sinceTx) : options.longs === Number ? new $util.LongBits(message.sinceTx.low >>> 0, message.sinceTx.high >>> 0).toNumber(true) : message.sinceTx;
                return object;
            };

            /**
             * Converts this SQLGetRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.SQLGetRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SQLGetRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SQLGetRequest
             * @function getTypeUrl
             * @memberof immudb.schema.SQLGetRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SQLGetRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.SQLGetRequest";
            };

            return SQLGetRequest;
        })();

        schema.VerifiableSQLGetRequest = (function() {

            /**
             * Properties of a VerifiableSQLGetRequest.
             * @memberof immudb.schema
             * @interface IVerifiableSQLGetRequest
             * @property {immudb.schema.ISQLGetRequest|null} [sqlGetRequest] VerifiableSQLGetRequest sqlGetRequest
             * @property {Long|null} [proveSinceTx] VerifiableSQLGetRequest proveSinceTx
             */

            /**
             * Constructs a new VerifiableSQLGetRequest.
             * @memberof immudb.schema
             * @classdesc Represents a VerifiableSQLGetRequest.
             * @implements IVerifiableSQLGetRequest
             * @constructor
             * @param {immudb.schema.IVerifiableSQLGetRequest=} [properties] Properties to set
             */
            function VerifiableSQLGetRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VerifiableSQLGetRequest sqlGetRequest.
             * @member {immudb.schema.ISQLGetRequest|null|undefined} sqlGetRequest
             * @memberof immudb.schema.VerifiableSQLGetRequest
             * @instance
             */
            VerifiableSQLGetRequest.prototype.sqlGetRequest = null;

            /**
             * VerifiableSQLGetRequest proveSinceTx.
             * @member {Long} proveSinceTx
             * @memberof immudb.schema.VerifiableSQLGetRequest
             * @instance
             */
            VerifiableSQLGetRequest.prototype.proveSinceTx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new VerifiableSQLGetRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.VerifiableSQLGetRequest
             * @static
             * @param {immudb.schema.IVerifiableSQLGetRequest=} [properties] Properties to set
             * @returns {immudb.schema.VerifiableSQLGetRequest} VerifiableSQLGetRequest instance
             */
            VerifiableSQLGetRequest.create = function create(properties) {
                return new VerifiableSQLGetRequest(properties);
            };

            /**
             * Encodes the specified VerifiableSQLGetRequest message. Does not implicitly {@link immudb.schema.VerifiableSQLGetRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.VerifiableSQLGetRequest
             * @static
             * @param {immudb.schema.IVerifiableSQLGetRequest} message VerifiableSQLGetRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VerifiableSQLGetRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sqlGetRequest != null && Object.hasOwnProperty.call(message, "sqlGetRequest"))
                    $root.immudb.schema.SQLGetRequest.encode(message.sqlGetRequest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.proveSinceTx != null && Object.hasOwnProperty.call(message, "proveSinceTx"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.proveSinceTx);
                return writer;
            };

            /**
             * Encodes the specified VerifiableSQLGetRequest message, length delimited. Does not implicitly {@link immudb.schema.VerifiableSQLGetRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.VerifiableSQLGetRequest
             * @static
             * @param {immudb.schema.IVerifiableSQLGetRequest} message VerifiableSQLGetRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VerifiableSQLGetRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VerifiableSQLGetRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.VerifiableSQLGetRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.VerifiableSQLGetRequest} VerifiableSQLGetRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VerifiableSQLGetRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.VerifiableSQLGetRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.sqlGetRequest = $root.immudb.schema.SQLGetRequest.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.proveSinceTx = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VerifiableSQLGetRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.VerifiableSQLGetRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.VerifiableSQLGetRequest} VerifiableSQLGetRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VerifiableSQLGetRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VerifiableSQLGetRequest message.
             * @function verify
             * @memberof immudb.schema.VerifiableSQLGetRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VerifiableSQLGetRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sqlGetRequest != null && message.hasOwnProperty("sqlGetRequest")) {
                    let error = $root.immudb.schema.SQLGetRequest.verify(message.sqlGetRequest);
                    if (error)
                        return "sqlGetRequest." + error;
                }
                if (message.proveSinceTx != null && message.hasOwnProperty("proveSinceTx"))
                    if (!$util.isInteger(message.proveSinceTx) && !(message.proveSinceTx && $util.isInteger(message.proveSinceTx.low) && $util.isInteger(message.proveSinceTx.high)))
                        return "proveSinceTx: integer|Long expected";
                return null;
            };

            /**
             * Creates a VerifiableSQLGetRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.VerifiableSQLGetRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.VerifiableSQLGetRequest} VerifiableSQLGetRequest
             */
            VerifiableSQLGetRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.VerifiableSQLGetRequest)
                    return object;
                let message = new $root.immudb.schema.VerifiableSQLGetRequest();
                if (object.sqlGetRequest != null) {
                    if (typeof object.sqlGetRequest !== "object")
                        throw TypeError(".immudb.schema.VerifiableSQLGetRequest.sqlGetRequest: object expected");
                    message.sqlGetRequest = $root.immudb.schema.SQLGetRequest.fromObject(object.sqlGetRequest);
                }
                if (object.proveSinceTx != null)
                    if ($util.Long)
                        (message.proveSinceTx = $util.Long.fromValue(object.proveSinceTx)).unsigned = true;
                    else if (typeof object.proveSinceTx === "string")
                        message.proveSinceTx = parseInt(object.proveSinceTx, 10);
                    else if (typeof object.proveSinceTx === "number")
                        message.proveSinceTx = object.proveSinceTx;
                    else if (typeof object.proveSinceTx === "object")
                        message.proveSinceTx = new $util.LongBits(object.proveSinceTx.low >>> 0, object.proveSinceTx.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a VerifiableSQLGetRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.VerifiableSQLGetRequest
             * @static
             * @param {immudb.schema.VerifiableSQLGetRequest} message VerifiableSQLGetRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VerifiableSQLGetRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.sqlGetRequest = null;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.proveSinceTx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.proveSinceTx = options.longs === String ? "0" : 0;
                }
                if (message.sqlGetRequest != null && message.hasOwnProperty("sqlGetRequest"))
                    object.sqlGetRequest = $root.immudb.schema.SQLGetRequest.toObject(message.sqlGetRequest, options);
                if (message.proveSinceTx != null && message.hasOwnProperty("proveSinceTx"))
                    if (typeof message.proveSinceTx === "number")
                        object.proveSinceTx = options.longs === String ? String(message.proveSinceTx) : message.proveSinceTx;
                    else
                        object.proveSinceTx = options.longs === String ? $util.Long.prototype.toString.call(message.proveSinceTx) : options.longs === Number ? new $util.LongBits(message.proveSinceTx.low >>> 0, message.proveSinceTx.high >>> 0).toNumber(true) : message.proveSinceTx;
                return object;
            };

            /**
             * Converts this VerifiableSQLGetRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.VerifiableSQLGetRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VerifiableSQLGetRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for VerifiableSQLGetRequest
             * @function getTypeUrl
             * @memberof immudb.schema.VerifiableSQLGetRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            VerifiableSQLGetRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.VerifiableSQLGetRequest";
            };

            return VerifiableSQLGetRequest;
        })();

        schema.SQLEntry = (function() {

            /**
             * Properties of a SQLEntry.
             * @memberof immudb.schema
             * @interface ISQLEntry
             * @property {Long|null} [tx] SQLEntry tx
             * @property {Uint8Array|null} [key] SQLEntry key
             * @property {Uint8Array|null} [value] SQLEntry value
             * @property {immudb.schema.IKVMetadata|null} [metadata] SQLEntry metadata
             */

            /**
             * Constructs a new SQLEntry.
             * @memberof immudb.schema
             * @classdesc Represents a SQLEntry.
             * @implements ISQLEntry
             * @constructor
             * @param {immudb.schema.ISQLEntry=} [properties] Properties to set
             */
            function SQLEntry(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SQLEntry tx.
             * @member {Long} tx
             * @memberof immudb.schema.SQLEntry
             * @instance
             */
            SQLEntry.prototype.tx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SQLEntry key.
             * @member {Uint8Array} key
             * @memberof immudb.schema.SQLEntry
             * @instance
             */
            SQLEntry.prototype.key = $util.newBuffer([]);

            /**
             * SQLEntry value.
             * @member {Uint8Array} value
             * @memberof immudb.schema.SQLEntry
             * @instance
             */
            SQLEntry.prototype.value = $util.newBuffer([]);

            /**
             * SQLEntry metadata.
             * @member {immudb.schema.IKVMetadata|null|undefined} metadata
             * @memberof immudb.schema.SQLEntry
             * @instance
             */
            SQLEntry.prototype.metadata = null;

            /**
             * Creates a new SQLEntry instance using the specified properties.
             * @function create
             * @memberof immudb.schema.SQLEntry
             * @static
             * @param {immudb.schema.ISQLEntry=} [properties] Properties to set
             * @returns {immudb.schema.SQLEntry} SQLEntry instance
             */
            SQLEntry.create = function create(properties) {
                return new SQLEntry(properties);
            };

            /**
             * Encodes the specified SQLEntry message. Does not implicitly {@link immudb.schema.SQLEntry.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.SQLEntry
             * @static
             * @param {immudb.schema.ISQLEntry} message SQLEntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SQLEntry.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tx != null && Object.hasOwnProperty.call(message, "tx"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.tx);
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.key);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.value);
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    $root.immudb.schema.KVMetadata.encode(message.metadata, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SQLEntry message, length delimited. Does not implicitly {@link immudb.schema.SQLEntry.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.SQLEntry
             * @static
             * @param {immudb.schema.ISQLEntry} message SQLEntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SQLEntry.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SQLEntry message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.SQLEntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.SQLEntry} SQLEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SQLEntry.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.SQLEntry();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.tx = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.key = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.value = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.metadata = $root.immudb.schema.KVMetadata.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SQLEntry message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.SQLEntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.SQLEntry} SQLEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SQLEntry.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SQLEntry message.
             * @function verify
             * @memberof immudb.schema.SQLEntry
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SQLEntry.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tx != null && message.hasOwnProperty("tx"))
                    if (!$util.isInteger(message.tx) && !(message.tx && $util.isInteger(message.tx.low) && $util.isInteger(message.tx.high)))
                        return "tx: integer|Long expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                        return "key: buffer expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    let error = $root.immudb.schema.KVMetadata.verify(message.metadata);
                    if (error)
                        return "metadata." + error;
                }
                return null;
            };

            /**
             * Creates a SQLEntry message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.SQLEntry
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.SQLEntry} SQLEntry
             */
            SQLEntry.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.SQLEntry)
                    return object;
                let message = new $root.immudb.schema.SQLEntry();
                if (object.tx != null)
                    if ($util.Long)
                        (message.tx = $util.Long.fromValue(object.tx)).unsigned = true;
                    else if (typeof object.tx === "string")
                        message.tx = parseInt(object.tx, 10);
                    else if (typeof object.tx === "number")
                        message.tx = object.tx;
                    else if (typeof object.tx === "object")
                        message.tx = new $util.LongBits(object.tx.low >>> 0, object.tx.high >>> 0).toNumber(true);
                if (object.key != null)
                    if (typeof object.key === "string")
                        $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                    else if (object.key.length >= 0)
                        message.key = object.key;
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length >= 0)
                        message.value = object.value;
                if (object.metadata != null) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".immudb.schema.SQLEntry.metadata: object expected");
                    message.metadata = $root.immudb.schema.KVMetadata.fromObject(object.metadata);
                }
                return message;
            };

            /**
             * Creates a plain object from a SQLEntry message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.SQLEntry
             * @static
             * @param {immudb.schema.SQLEntry} message SQLEntry
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SQLEntry.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.tx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.tx = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.key = "";
                    else {
                        object.key = [];
                        if (options.bytes !== Array)
                            object.key = $util.newBuffer(object.key);
                    }
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    object.metadata = null;
                }
                if (message.tx != null && message.hasOwnProperty("tx"))
                    if (typeof message.tx === "number")
                        object.tx = options.longs === String ? String(message.tx) : message.tx;
                    else
                        object.tx = options.longs === String ? $util.Long.prototype.toString.call(message.tx) : options.longs === Number ? new $util.LongBits(message.tx.low >>> 0, message.tx.high >>> 0).toNumber(true) : message.tx;
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = $root.immudb.schema.KVMetadata.toObject(message.metadata, options);
                return object;
            };

            /**
             * Converts this SQLEntry to JSON.
             * @function toJSON
             * @memberof immudb.schema.SQLEntry
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SQLEntry.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SQLEntry
             * @function getTypeUrl
             * @memberof immudb.schema.SQLEntry
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SQLEntry.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.SQLEntry";
            };

            return SQLEntry;
        })();

        schema.VerifiableSQLEntry = (function() {

            /**
             * Properties of a VerifiableSQLEntry.
             * @memberof immudb.schema
             * @interface IVerifiableSQLEntry
             * @property {immudb.schema.ISQLEntry|null} [sqlEntry] VerifiableSQLEntry sqlEntry
             * @property {immudb.schema.IVerifiableTx|null} [verifiableTx] VerifiableSQLEntry verifiableTx
             * @property {immudb.schema.IInclusionProof|null} [inclusionProof] VerifiableSQLEntry inclusionProof
             * @property {number|null} [DatabaseId] VerifiableSQLEntry DatabaseId
             * @property {number|null} [TableId] VerifiableSQLEntry TableId
             * @property {Array.<number>|null} [PKIDs] VerifiableSQLEntry PKIDs
             * @property {Object.<string,string>|null} [ColNamesById] VerifiableSQLEntry ColNamesById
             * @property {Object.<string,number>|null} [ColIdsByName] VerifiableSQLEntry ColIdsByName
             * @property {Object.<string,string>|null} [ColTypesById] VerifiableSQLEntry ColTypesById
             * @property {Object.<string,number>|null} [ColLenById] VerifiableSQLEntry ColLenById
             */

            /**
             * Constructs a new VerifiableSQLEntry.
             * @memberof immudb.schema
             * @classdesc Represents a VerifiableSQLEntry.
             * @implements IVerifiableSQLEntry
             * @constructor
             * @param {immudb.schema.IVerifiableSQLEntry=} [properties] Properties to set
             */
            function VerifiableSQLEntry(properties) {
                this.PKIDs = [];
                this.ColNamesById = {};
                this.ColIdsByName = {};
                this.ColTypesById = {};
                this.ColLenById = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VerifiableSQLEntry sqlEntry.
             * @member {immudb.schema.ISQLEntry|null|undefined} sqlEntry
             * @memberof immudb.schema.VerifiableSQLEntry
             * @instance
             */
            VerifiableSQLEntry.prototype.sqlEntry = null;

            /**
             * VerifiableSQLEntry verifiableTx.
             * @member {immudb.schema.IVerifiableTx|null|undefined} verifiableTx
             * @memberof immudb.schema.VerifiableSQLEntry
             * @instance
             */
            VerifiableSQLEntry.prototype.verifiableTx = null;

            /**
             * VerifiableSQLEntry inclusionProof.
             * @member {immudb.schema.IInclusionProof|null|undefined} inclusionProof
             * @memberof immudb.schema.VerifiableSQLEntry
             * @instance
             */
            VerifiableSQLEntry.prototype.inclusionProof = null;

            /**
             * VerifiableSQLEntry DatabaseId.
             * @member {number} DatabaseId
             * @memberof immudb.schema.VerifiableSQLEntry
             * @instance
             */
            VerifiableSQLEntry.prototype.DatabaseId = 0;

            /**
             * VerifiableSQLEntry TableId.
             * @member {number} TableId
             * @memberof immudb.schema.VerifiableSQLEntry
             * @instance
             */
            VerifiableSQLEntry.prototype.TableId = 0;

            /**
             * VerifiableSQLEntry PKIDs.
             * @member {Array.<number>} PKIDs
             * @memberof immudb.schema.VerifiableSQLEntry
             * @instance
             */
            VerifiableSQLEntry.prototype.PKIDs = $util.emptyArray;

            /**
             * VerifiableSQLEntry ColNamesById.
             * @member {Object.<string,string>} ColNamesById
             * @memberof immudb.schema.VerifiableSQLEntry
             * @instance
             */
            VerifiableSQLEntry.prototype.ColNamesById = $util.emptyObject;

            /**
             * VerifiableSQLEntry ColIdsByName.
             * @member {Object.<string,number>} ColIdsByName
             * @memberof immudb.schema.VerifiableSQLEntry
             * @instance
             */
            VerifiableSQLEntry.prototype.ColIdsByName = $util.emptyObject;

            /**
             * VerifiableSQLEntry ColTypesById.
             * @member {Object.<string,string>} ColTypesById
             * @memberof immudb.schema.VerifiableSQLEntry
             * @instance
             */
            VerifiableSQLEntry.prototype.ColTypesById = $util.emptyObject;

            /**
             * VerifiableSQLEntry ColLenById.
             * @member {Object.<string,number>} ColLenById
             * @memberof immudb.schema.VerifiableSQLEntry
             * @instance
             */
            VerifiableSQLEntry.prototype.ColLenById = $util.emptyObject;

            /**
             * Creates a new VerifiableSQLEntry instance using the specified properties.
             * @function create
             * @memberof immudb.schema.VerifiableSQLEntry
             * @static
             * @param {immudb.schema.IVerifiableSQLEntry=} [properties] Properties to set
             * @returns {immudb.schema.VerifiableSQLEntry} VerifiableSQLEntry instance
             */
            VerifiableSQLEntry.create = function create(properties) {
                return new VerifiableSQLEntry(properties);
            };

            /**
             * Encodes the specified VerifiableSQLEntry message. Does not implicitly {@link immudb.schema.VerifiableSQLEntry.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.VerifiableSQLEntry
             * @static
             * @param {immudb.schema.IVerifiableSQLEntry} message VerifiableSQLEntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VerifiableSQLEntry.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sqlEntry != null && Object.hasOwnProperty.call(message, "sqlEntry"))
                    $root.immudb.schema.SQLEntry.encode(message.sqlEntry, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.verifiableTx != null && Object.hasOwnProperty.call(message, "verifiableTx"))
                    $root.immudb.schema.VerifiableTx.encode(message.verifiableTx, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.inclusionProof != null && Object.hasOwnProperty.call(message, "inclusionProof"))
                    $root.immudb.schema.InclusionProof.encode(message.inclusionProof, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.DatabaseId != null && Object.hasOwnProperty.call(message, "DatabaseId"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.DatabaseId);
                if (message.TableId != null && Object.hasOwnProperty.call(message, "TableId"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.TableId);
                if (message.ColNamesById != null && Object.hasOwnProperty.call(message, "ColNamesById"))
                    for (let keys = Object.keys(message.ColNamesById), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 8, wireType 2 =*/66).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.ColNamesById[keys[i]]).ldelim();
                if (message.ColIdsByName != null && Object.hasOwnProperty.call(message, "ColIdsByName"))
                    for (let keys = Object.keys(message.ColIdsByName), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 9, wireType 2 =*/74).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).uint32(message.ColIdsByName[keys[i]]).ldelim();
                if (message.ColTypesById != null && Object.hasOwnProperty.call(message, "ColTypesById"))
                    for (let keys = Object.keys(message.ColTypesById), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.ColTypesById[keys[i]]).ldelim();
                if (message.ColLenById != null && Object.hasOwnProperty.call(message, "ColLenById"))
                    for (let keys = Object.keys(message.ColLenById), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 11, wireType 2 =*/90).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]).uint32(/* id 2, wireType 0 =*/16).int32(message.ColLenById[keys[i]]).ldelim();
                if (message.PKIDs != null && message.PKIDs.length) {
                    writer.uint32(/* id 16, wireType 2 =*/130).fork();
                    for (let i = 0; i < message.PKIDs.length; ++i)
                        writer.uint32(message.PKIDs[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified VerifiableSQLEntry message, length delimited. Does not implicitly {@link immudb.schema.VerifiableSQLEntry.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.VerifiableSQLEntry
             * @static
             * @param {immudb.schema.IVerifiableSQLEntry} message VerifiableSQLEntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VerifiableSQLEntry.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VerifiableSQLEntry message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.VerifiableSQLEntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.VerifiableSQLEntry} VerifiableSQLEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VerifiableSQLEntry.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.VerifiableSQLEntry(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.sqlEntry = $root.immudb.schema.SQLEntry.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.verifiableTx = $root.immudb.schema.VerifiableTx.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.inclusionProof = $root.immudb.schema.InclusionProof.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.DatabaseId = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.TableId = reader.uint32();
                            break;
                        }
                    case 16: {
                            if (!(message.PKIDs && message.PKIDs.length))
                                message.PKIDs = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.PKIDs.push(reader.uint32());
                            } else
                                message.PKIDs.push(reader.uint32());
                            break;
                        }
                    case 8: {
                            if (message.ColNamesById === $util.emptyObject)
                                message.ColNamesById = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = 0;
                            value = "";
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.uint32();
                                    break;
                                case 2:
                                    value = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.ColNamesById[key] = value;
                            break;
                        }
                    case 9: {
                            if (message.ColIdsByName === $util.emptyObject)
                                message.ColIdsByName = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = 0;
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = reader.uint32();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.ColIdsByName[key] = value;
                            break;
                        }
                    case 10: {
                            if (message.ColTypesById === $util.emptyObject)
                                message.ColTypesById = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = 0;
                            value = "";
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.uint32();
                                    break;
                                case 2:
                                    value = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.ColTypesById[key] = value;
                            break;
                        }
                    case 11: {
                            if (message.ColLenById === $util.emptyObject)
                                message.ColLenById = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = 0;
                            value = 0;
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.uint32();
                                    break;
                                case 2:
                                    value = reader.int32();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.ColLenById[key] = value;
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VerifiableSQLEntry message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.VerifiableSQLEntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.VerifiableSQLEntry} VerifiableSQLEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VerifiableSQLEntry.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VerifiableSQLEntry message.
             * @function verify
             * @memberof immudb.schema.VerifiableSQLEntry
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VerifiableSQLEntry.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sqlEntry != null && message.hasOwnProperty("sqlEntry")) {
                    let error = $root.immudb.schema.SQLEntry.verify(message.sqlEntry);
                    if (error)
                        return "sqlEntry." + error;
                }
                if (message.verifiableTx != null && message.hasOwnProperty("verifiableTx")) {
                    let error = $root.immudb.schema.VerifiableTx.verify(message.verifiableTx);
                    if (error)
                        return "verifiableTx." + error;
                }
                if (message.inclusionProof != null && message.hasOwnProperty("inclusionProof")) {
                    let error = $root.immudb.schema.InclusionProof.verify(message.inclusionProof);
                    if (error)
                        return "inclusionProof." + error;
                }
                if (message.DatabaseId != null && message.hasOwnProperty("DatabaseId"))
                    if (!$util.isInteger(message.DatabaseId))
                        return "DatabaseId: integer expected";
                if (message.TableId != null && message.hasOwnProperty("TableId"))
                    if (!$util.isInteger(message.TableId))
                        return "TableId: integer expected";
                if (message.PKIDs != null && message.hasOwnProperty("PKIDs")) {
                    if (!Array.isArray(message.PKIDs))
                        return "PKIDs: array expected";
                    for (let i = 0; i < message.PKIDs.length; ++i)
                        if (!$util.isInteger(message.PKIDs[i]))
                            return "PKIDs: integer[] expected";
                }
                if (message.ColNamesById != null && message.hasOwnProperty("ColNamesById")) {
                    if (!$util.isObject(message.ColNamesById))
                        return "ColNamesById: object expected";
                    let key = Object.keys(message.ColNamesById);
                    for (let i = 0; i < key.length; ++i) {
                        if (!$util.key32Re.test(key[i]))
                            return "ColNamesById: integer key{k:uint32} expected";
                        if (!$util.isString(message.ColNamesById[key[i]]))
                            return "ColNamesById: string{k:uint32} expected";
                    }
                }
                if (message.ColIdsByName != null && message.hasOwnProperty("ColIdsByName")) {
                    if (!$util.isObject(message.ColIdsByName))
                        return "ColIdsByName: object expected";
                    let key = Object.keys(message.ColIdsByName);
                    for (let i = 0; i < key.length; ++i)
                        if (!$util.isInteger(message.ColIdsByName[key[i]]))
                            return "ColIdsByName: integer{k:string} expected";
                }
                if (message.ColTypesById != null && message.hasOwnProperty("ColTypesById")) {
                    if (!$util.isObject(message.ColTypesById))
                        return "ColTypesById: object expected";
                    let key = Object.keys(message.ColTypesById);
                    for (let i = 0; i < key.length; ++i) {
                        if (!$util.key32Re.test(key[i]))
                            return "ColTypesById: integer key{k:uint32} expected";
                        if (!$util.isString(message.ColTypesById[key[i]]))
                            return "ColTypesById: string{k:uint32} expected";
                    }
                }
                if (message.ColLenById != null && message.hasOwnProperty("ColLenById")) {
                    if (!$util.isObject(message.ColLenById))
                        return "ColLenById: object expected";
                    let key = Object.keys(message.ColLenById);
                    for (let i = 0; i < key.length; ++i) {
                        if (!$util.key32Re.test(key[i]))
                            return "ColLenById: integer key{k:uint32} expected";
                        if (!$util.isInteger(message.ColLenById[key[i]]))
                            return "ColLenById: integer{k:uint32} expected";
                    }
                }
                return null;
            };

            /**
             * Creates a VerifiableSQLEntry message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.VerifiableSQLEntry
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.VerifiableSQLEntry} VerifiableSQLEntry
             */
            VerifiableSQLEntry.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.VerifiableSQLEntry)
                    return object;
                let message = new $root.immudb.schema.VerifiableSQLEntry();
                if (object.sqlEntry != null) {
                    if (typeof object.sqlEntry !== "object")
                        throw TypeError(".immudb.schema.VerifiableSQLEntry.sqlEntry: object expected");
                    message.sqlEntry = $root.immudb.schema.SQLEntry.fromObject(object.sqlEntry);
                }
                if (object.verifiableTx != null) {
                    if (typeof object.verifiableTx !== "object")
                        throw TypeError(".immudb.schema.VerifiableSQLEntry.verifiableTx: object expected");
                    message.verifiableTx = $root.immudb.schema.VerifiableTx.fromObject(object.verifiableTx);
                }
                if (object.inclusionProof != null) {
                    if (typeof object.inclusionProof !== "object")
                        throw TypeError(".immudb.schema.VerifiableSQLEntry.inclusionProof: object expected");
                    message.inclusionProof = $root.immudb.schema.InclusionProof.fromObject(object.inclusionProof);
                }
                if (object.DatabaseId != null)
                    message.DatabaseId = object.DatabaseId >>> 0;
                if (object.TableId != null)
                    message.TableId = object.TableId >>> 0;
                if (object.PKIDs) {
                    if (!Array.isArray(object.PKIDs))
                        throw TypeError(".immudb.schema.VerifiableSQLEntry.PKIDs: array expected");
                    message.PKIDs = [];
                    for (let i = 0; i < object.PKIDs.length; ++i)
                        message.PKIDs[i] = object.PKIDs[i] >>> 0;
                }
                if (object.ColNamesById) {
                    if (typeof object.ColNamesById !== "object")
                        throw TypeError(".immudb.schema.VerifiableSQLEntry.ColNamesById: object expected");
                    message.ColNamesById = {};
                    for (let keys = Object.keys(object.ColNamesById), i = 0; i < keys.length; ++i)
                        message.ColNamesById[keys[i]] = String(object.ColNamesById[keys[i]]);
                }
                if (object.ColIdsByName) {
                    if (typeof object.ColIdsByName !== "object")
                        throw TypeError(".immudb.schema.VerifiableSQLEntry.ColIdsByName: object expected");
                    message.ColIdsByName = {};
                    for (let keys = Object.keys(object.ColIdsByName), i = 0; i < keys.length; ++i)
                        message.ColIdsByName[keys[i]] = object.ColIdsByName[keys[i]] >>> 0;
                }
                if (object.ColTypesById) {
                    if (typeof object.ColTypesById !== "object")
                        throw TypeError(".immudb.schema.VerifiableSQLEntry.ColTypesById: object expected");
                    message.ColTypesById = {};
                    for (let keys = Object.keys(object.ColTypesById), i = 0; i < keys.length; ++i)
                        message.ColTypesById[keys[i]] = String(object.ColTypesById[keys[i]]);
                }
                if (object.ColLenById) {
                    if (typeof object.ColLenById !== "object")
                        throw TypeError(".immudb.schema.VerifiableSQLEntry.ColLenById: object expected");
                    message.ColLenById = {};
                    for (let keys = Object.keys(object.ColLenById), i = 0; i < keys.length; ++i)
                        message.ColLenById[keys[i]] = object.ColLenById[keys[i]] | 0;
                }
                return message;
            };

            /**
             * Creates a plain object from a VerifiableSQLEntry message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.VerifiableSQLEntry
             * @static
             * @param {immudb.schema.VerifiableSQLEntry} message VerifiableSQLEntry
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VerifiableSQLEntry.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.PKIDs = [];
                if (options.objects || options.defaults) {
                    object.ColNamesById = {};
                    object.ColIdsByName = {};
                    object.ColTypesById = {};
                    object.ColLenById = {};
                }
                if (options.defaults) {
                    object.sqlEntry = null;
                    object.verifiableTx = null;
                    object.inclusionProof = null;
                    object.DatabaseId = 0;
                    object.TableId = 0;
                }
                if (message.sqlEntry != null && message.hasOwnProperty("sqlEntry"))
                    object.sqlEntry = $root.immudb.schema.SQLEntry.toObject(message.sqlEntry, options);
                if (message.verifiableTx != null && message.hasOwnProperty("verifiableTx"))
                    object.verifiableTx = $root.immudb.schema.VerifiableTx.toObject(message.verifiableTx, options);
                if (message.inclusionProof != null && message.hasOwnProperty("inclusionProof"))
                    object.inclusionProof = $root.immudb.schema.InclusionProof.toObject(message.inclusionProof, options);
                if (message.DatabaseId != null && message.hasOwnProperty("DatabaseId"))
                    object.DatabaseId = message.DatabaseId;
                if (message.TableId != null && message.hasOwnProperty("TableId"))
                    object.TableId = message.TableId;
                let keys2;
                if (message.ColNamesById && (keys2 = Object.keys(message.ColNamesById)).length) {
                    object.ColNamesById = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.ColNamesById[keys2[j]] = message.ColNamesById[keys2[j]];
                }
                if (message.ColIdsByName && (keys2 = Object.keys(message.ColIdsByName)).length) {
                    object.ColIdsByName = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.ColIdsByName[keys2[j]] = message.ColIdsByName[keys2[j]];
                }
                if (message.ColTypesById && (keys2 = Object.keys(message.ColTypesById)).length) {
                    object.ColTypesById = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.ColTypesById[keys2[j]] = message.ColTypesById[keys2[j]];
                }
                if (message.ColLenById && (keys2 = Object.keys(message.ColLenById)).length) {
                    object.ColLenById = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.ColLenById[keys2[j]] = message.ColLenById[keys2[j]];
                }
                if (message.PKIDs && message.PKIDs.length) {
                    object.PKIDs = [];
                    for (let j = 0; j < message.PKIDs.length; ++j)
                        object.PKIDs[j] = message.PKIDs[j];
                }
                return object;
            };

            /**
             * Converts this VerifiableSQLEntry to JSON.
             * @function toJSON
             * @memberof immudb.schema.VerifiableSQLEntry
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VerifiableSQLEntry.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for VerifiableSQLEntry
             * @function getTypeUrl
             * @memberof immudb.schema.VerifiableSQLEntry
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            VerifiableSQLEntry.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.VerifiableSQLEntry";
            };

            return VerifiableSQLEntry;
        })();

        schema.UseDatabaseReply = (function() {

            /**
             * Properties of a UseDatabaseReply.
             * @memberof immudb.schema
             * @interface IUseDatabaseReply
             * @property {string|null} [token] UseDatabaseReply token
             */

            /**
             * Constructs a new UseDatabaseReply.
             * @memberof immudb.schema
             * @classdesc Represents a UseDatabaseReply.
             * @implements IUseDatabaseReply
             * @constructor
             * @param {immudb.schema.IUseDatabaseReply=} [properties] Properties to set
             */
            function UseDatabaseReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UseDatabaseReply token.
             * @member {string} token
             * @memberof immudb.schema.UseDatabaseReply
             * @instance
             */
            UseDatabaseReply.prototype.token = "";

            /**
             * Creates a new UseDatabaseReply instance using the specified properties.
             * @function create
             * @memberof immudb.schema.UseDatabaseReply
             * @static
             * @param {immudb.schema.IUseDatabaseReply=} [properties] Properties to set
             * @returns {immudb.schema.UseDatabaseReply} UseDatabaseReply instance
             */
            UseDatabaseReply.create = function create(properties) {
                return new UseDatabaseReply(properties);
            };

            /**
             * Encodes the specified UseDatabaseReply message. Does not implicitly {@link immudb.schema.UseDatabaseReply.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.UseDatabaseReply
             * @static
             * @param {immudb.schema.IUseDatabaseReply} message UseDatabaseReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UseDatabaseReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.token);
                return writer;
            };

            /**
             * Encodes the specified UseDatabaseReply message, length delimited. Does not implicitly {@link immudb.schema.UseDatabaseReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.UseDatabaseReply
             * @static
             * @param {immudb.schema.IUseDatabaseReply} message UseDatabaseReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UseDatabaseReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a UseDatabaseReply message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.UseDatabaseReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.UseDatabaseReply} UseDatabaseReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UseDatabaseReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.UseDatabaseReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.token = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a UseDatabaseReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.UseDatabaseReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.UseDatabaseReply} UseDatabaseReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UseDatabaseReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a UseDatabaseReply message.
             * @function verify
             * @memberof immudb.schema.UseDatabaseReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UseDatabaseReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                return null;
            };

            /**
             * Creates a UseDatabaseReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.UseDatabaseReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.UseDatabaseReply} UseDatabaseReply
             */
            UseDatabaseReply.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.UseDatabaseReply)
                    return object;
                let message = new $root.immudb.schema.UseDatabaseReply();
                if (object.token != null)
                    message.token = String(object.token);
                return message;
            };

            /**
             * Creates a plain object from a UseDatabaseReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.UseDatabaseReply
             * @static
             * @param {immudb.schema.UseDatabaseReply} message UseDatabaseReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UseDatabaseReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.token = "";
                if (message.token != null && message.hasOwnProperty("token"))
                    object.token = message.token;
                return object;
            };

            /**
             * Converts this UseDatabaseReply to JSON.
             * @function toJSON
             * @memberof immudb.schema.UseDatabaseReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UseDatabaseReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UseDatabaseReply
             * @function getTypeUrl
             * @memberof immudb.schema.UseDatabaseReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UseDatabaseReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.UseDatabaseReply";
            };

            return UseDatabaseReply;
        })();

        /**
         * PermissionAction enum.
         * @name immudb.schema.PermissionAction
         * @enum {number}
         * @property {number} GRANT=0 GRANT value
         * @property {number} REVOKE=1 REVOKE value
         */
        schema.PermissionAction = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "GRANT"] = 0;
            values[valuesById[1] = "REVOKE"] = 1;
            return values;
        })();

        schema.ChangePermissionRequest = (function() {

            /**
             * Properties of a ChangePermissionRequest.
             * @memberof immudb.schema
             * @interface IChangePermissionRequest
             * @property {immudb.schema.PermissionAction|null} [action] ChangePermissionRequest action
             * @property {string|null} [username] ChangePermissionRequest username
             * @property {string|null} [database] ChangePermissionRequest database
             * @property {number|null} [permission] ChangePermissionRequest permission
             */

            /**
             * Constructs a new ChangePermissionRequest.
             * @memberof immudb.schema
             * @classdesc Represents a ChangePermissionRequest.
             * @implements IChangePermissionRequest
             * @constructor
             * @param {immudb.schema.IChangePermissionRequest=} [properties] Properties to set
             */
            function ChangePermissionRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ChangePermissionRequest action.
             * @member {immudb.schema.PermissionAction} action
             * @memberof immudb.schema.ChangePermissionRequest
             * @instance
             */
            ChangePermissionRequest.prototype.action = 0;

            /**
             * ChangePermissionRequest username.
             * @member {string} username
             * @memberof immudb.schema.ChangePermissionRequest
             * @instance
             */
            ChangePermissionRequest.prototype.username = "";

            /**
             * ChangePermissionRequest database.
             * @member {string} database
             * @memberof immudb.schema.ChangePermissionRequest
             * @instance
             */
            ChangePermissionRequest.prototype.database = "";

            /**
             * ChangePermissionRequest permission.
             * @member {number} permission
             * @memberof immudb.schema.ChangePermissionRequest
             * @instance
             */
            ChangePermissionRequest.prototype.permission = 0;

            /**
             * Creates a new ChangePermissionRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.ChangePermissionRequest
             * @static
             * @param {immudb.schema.IChangePermissionRequest=} [properties] Properties to set
             * @returns {immudb.schema.ChangePermissionRequest} ChangePermissionRequest instance
             */
            ChangePermissionRequest.create = function create(properties) {
                return new ChangePermissionRequest(properties);
            };

            /**
             * Encodes the specified ChangePermissionRequest message. Does not implicitly {@link immudb.schema.ChangePermissionRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.ChangePermissionRequest
             * @static
             * @param {immudb.schema.IChangePermissionRequest} message ChangePermissionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChangePermissionRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.action);
                if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
                if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.database);
                if (message.permission != null && Object.hasOwnProperty.call(message, "permission"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.permission);
                return writer;
            };

            /**
             * Encodes the specified ChangePermissionRequest message, length delimited. Does not implicitly {@link immudb.schema.ChangePermissionRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.ChangePermissionRequest
             * @static
             * @param {immudb.schema.IChangePermissionRequest} message ChangePermissionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChangePermissionRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ChangePermissionRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.ChangePermissionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.ChangePermissionRequest} ChangePermissionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChangePermissionRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.ChangePermissionRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.action = reader.int32();
                            break;
                        }
                    case 2: {
                            message.username = reader.string();
                            break;
                        }
                    case 3: {
                            message.database = reader.string();
                            break;
                        }
                    case 4: {
                            message.permission = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ChangePermissionRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.ChangePermissionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.ChangePermissionRequest} ChangePermissionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChangePermissionRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ChangePermissionRequest message.
             * @function verify
             * @memberof immudb.schema.ChangePermissionRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChangePermissionRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.action != null && message.hasOwnProperty("action"))
                    switch (message.action) {
                    default:
                        return "action: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.username != null && message.hasOwnProperty("username"))
                    if (!$util.isString(message.username))
                        return "username: string expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isString(message.database))
                        return "database: string expected";
                if (message.permission != null && message.hasOwnProperty("permission"))
                    if (!$util.isInteger(message.permission))
                        return "permission: integer expected";
                return null;
            };

            /**
             * Creates a ChangePermissionRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.ChangePermissionRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.ChangePermissionRequest} ChangePermissionRequest
             */
            ChangePermissionRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.ChangePermissionRequest)
                    return object;
                let message = new $root.immudb.schema.ChangePermissionRequest();
                switch (object.action) {
                default:
                    if (typeof object.action === "number") {
                        message.action = object.action;
                        break;
                    }
                    break;
                case "GRANT":
                case 0:
                    message.action = 0;
                    break;
                case "REVOKE":
                case 1:
                    message.action = 1;
                    break;
                }
                if (object.username != null)
                    message.username = String(object.username);
                if (object.database != null)
                    message.database = String(object.database);
                if (object.permission != null)
                    message.permission = object.permission >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a ChangePermissionRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.ChangePermissionRequest
             * @static
             * @param {immudb.schema.ChangePermissionRequest} message ChangePermissionRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChangePermissionRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.action = options.enums === String ? "GRANT" : 0;
                    object.username = "";
                    object.database = "";
                    object.permission = 0;
                }
                if (message.action != null && message.hasOwnProperty("action"))
                    object.action = options.enums === String ? $root.immudb.schema.PermissionAction[message.action] === undefined ? message.action : $root.immudb.schema.PermissionAction[message.action] : message.action;
                if (message.username != null && message.hasOwnProperty("username"))
                    object.username = message.username;
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                if (message.permission != null && message.hasOwnProperty("permission"))
                    object.permission = message.permission;
                return object;
            };

            /**
             * Converts this ChangePermissionRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.ChangePermissionRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChangePermissionRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ChangePermissionRequest
             * @function getTypeUrl
             * @memberof immudb.schema.ChangePermissionRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ChangePermissionRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.ChangePermissionRequest";
            };

            return ChangePermissionRequest;
        })();

        schema.SetActiveUserRequest = (function() {

            /**
             * Properties of a SetActiveUserRequest.
             * @memberof immudb.schema
             * @interface ISetActiveUserRequest
             * @property {boolean|null} [active] SetActiveUserRequest active
             * @property {string|null} [username] SetActiveUserRequest username
             */

            /**
             * Constructs a new SetActiveUserRequest.
             * @memberof immudb.schema
             * @classdesc Represents a SetActiveUserRequest.
             * @implements ISetActiveUserRequest
             * @constructor
             * @param {immudb.schema.ISetActiveUserRequest=} [properties] Properties to set
             */
            function SetActiveUserRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetActiveUserRequest active.
             * @member {boolean} active
             * @memberof immudb.schema.SetActiveUserRequest
             * @instance
             */
            SetActiveUserRequest.prototype.active = false;

            /**
             * SetActiveUserRequest username.
             * @member {string} username
             * @memberof immudb.schema.SetActiveUserRequest
             * @instance
             */
            SetActiveUserRequest.prototype.username = "";

            /**
             * Creates a new SetActiveUserRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.SetActiveUserRequest
             * @static
             * @param {immudb.schema.ISetActiveUserRequest=} [properties] Properties to set
             * @returns {immudb.schema.SetActiveUserRequest} SetActiveUserRequest instance
             */
            SetActiveUserRequest.create = function create(properties) {
                return new SetActiveUserRequest(properties);
            };

            /**
             * Encodes the specified SetActiveUserRequest message. Does not implicitly {@link immudb.schema.SetActiveUserRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.SetActiveUserRequest
             * @static
             * @param {immudb.schema.ISetActiveUserRequest} message SetActiveUserRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetActiveUserRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.active != null && Object.hasOwnProperty.call(message, "active"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.active);
                if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
                return writer;
            };

            /**
             * Encodes the specified SetActiveUserRequest message, length delimited. Does not implicitly {@link immudb.schema.SetActiveUserRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.SetActiveUserRequest
             * @static
             * @param {immudb.schema.ISetActiveUserRequest} message SetActiveUserRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetActiveUserRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetActiveUserRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.SetActiveUserRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.SetActiveUserRequest} SetActiveUserRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetActiveUserRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.SetActiveUserRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.active = reader.bool();
                            break;
                        }
                    case 2: {
                            message.username = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetActiveUserRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.SetActiveUserRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.SetActiveUserRequest} SetActiveUserRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetActiveUserRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetActiveUserRequest message.
             * @function verify
             * @memberof immudb.schema.SetActiveUserRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetActiveUserRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.active != null && message.hasOwnProperty("active"))
                    if (typeof message.active !== "boolean")
                        return "active: boolean expected";
                if (message.username != null && message.hasOwnProperty("username"))
                    if (!$util.isString(message.username))
                        return "username: string expected";
                return null;
            };

            /**
             * Creates a SetActiveUserRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.SetActiveUserRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.SetActiveUserRequest} SetActiveUserRequest
             */
            SetActiveUserRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.SetActiveUserRequest)
                    return object;
                let message = new $root.immudb.schema.SetActiveUserRequest();
                if (object.active != null)
                    message.active = Boolean(object.active);
                if (object.username != null)
                    message.username = String(object.username);
                return message;
            };

            /**
             * Creates a plain object from a SetActiveUserRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.SetActiveUserRequest
             * @static
             * @param {immudb.schema.SetActiveUserRequest} message SetActiveUserRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetActiveUserRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.active = false;
                    object.username = "";
                }
                if (message.active != null && message.hasOwnProperty("active"))
                    object.active = message.active;
                if (message.username != null && message.hasOwnProperty("username"))
                    object.username = message.username;
                return object;
            };

            /**
             * Converts this SetActiveUserRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.SetActiveUserRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetActiveUserRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetActiveUserRequest
             * @function getTypeUrl
             * @memberof immudb.schema.SetActiveUserRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetActiveUserRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.SetActiveUserRequest";
            };

            return SetActiveUserRequest;
        })();

        schema.DatabaseListResponse = (function() {

            /**
             * Properties of a DatabaseListResponse.
             * @memberof immudb.schema
             * @interface IDatabaseListResponse
             * @property {Array.<immudb.schema.IDatabase>|null} [databases] DatabaseListResponse databases
             */

            /**
             * Constructs a new DatabaseListResponse.
             * @memberof immudb.schema
             * @classdesc Represents a DatabaseListResponse.
             * @implements IDatabaseListResponse
             * @constructor
             * @param {immudb.schema.IDatabaseListResponse=} [properties] Properties to set
             */
            function DatabaseListResponse(properties) {
                this.databases = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DatabaseListResponse databases.
             * @member {Array.<immudb.schema.IDatabase>} databases
             * @memberof immudb.schema.DatabaseListResponse
             * @instance
             */
            DatabaseListResponse.prototype.databases = $util.emptyArray;

            /**
             * Creates a new DatabaseListResponse instance using the specified properties.
             * @function create
             * @memberof immudb.schema.DatabaseListResponse
             * @static
             * @param {immudb.schema.IDatabaseListResponse=} [properties] Properties to set
             * @returns {immudb.schema.DatabaseListResponse} DatabaseListResponse instance
             */
            DatabaseListResponse.create = function create(properties) {
                return new DatabaseListResponse(properties);
            };

            /**
             * Encodes the specified DatabaseListResponse message. Does not implicitly {@link immudb.schema.DatabaseListResponse.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.DatabaseListResponse
             * @static
             * @param {immudb.schema.IDatabaseListResponse} message DatabaseListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DatabaseListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.databases != null && message.databases.length)
                    for (let i = 0; i < message.databases.length; ++i)
                        $root.immudb.schema.Database.encode(message.databases[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DatabaseListResponse message, length delimited. Does not implicitly {@link immudb.schema.DatabaseListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.DatabaseListResponse
             * @static
             * @param {immudb.schema.IDatabaseListResponse} message DatabaseListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DatabaseListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DatabaseListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.DatabaseListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.DatabaseListResponse} DatabaseListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DatabaseListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.DatabaseListResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.databases && message.databases.length))
                                message.databases = [];
                            message.databases.push($root.immudb.schema.Database.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DatabaseListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.DatabaseListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.DatabaseListResponse} DatabaseListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DatabaseListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DatabaseListResponse message.
             * @function verify
             * @memberof immudb.schema.DatabaseListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DatabaseListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.databases != null && message.hasOwnProperty("databases")) {
                    if (!Array.isArray(message.databases))
                        return "databases: array expected";
                    for (let i = 0; i < message.databases.length; ++i) {
                        let error = $root.immudb.schema.Database.verify(message.databases[i]);
                        if (error)
                            return "databases." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a DatabaseListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.DatabaseListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.DatabaseListResponse} DatabaseListResponse
             */
            DatabaseListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.DatabaseListResponse)
                    return object;
                let message = new $root.immudb.schema.DatabaseListResponse();
                if (object.databases) {
                    if (!Array.isArray(object.databases))
                        throw TypeError(".immudb.schema.DatabaseListResponse.databases: array expected");
                    message.databases = [];
                    for (let i = 0; i < object.databases.length; ++i) {
                        if (typeof object.databases[i] !== "object")
                            throw TypeError(".immudb.schema.DatabaseListResponse.databases: object expected");
                        message.databases[i] = $root.immudb.schema.Database.fromObject(object.databases[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a DatabaseListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.DatabaseListResponse
             * @static
             * @param {immudb.schema.DatabaseListResponse} message DatabaseListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DatabaseListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.databases = [];
                if (message.databases && message.databases.length) {
                    object.databases = [];
                    for (let j = 0; j < message.databases.length; ++j)
                        object.databases[j] = $root.immudb.schema.Database.toObject(message.databases[j], options);
                }
                return object;
            };

            /**
             * Converts this DatabaseListResponse to JSON.
             * @function toJSON
             * @memberof immudb.schema.DatabaseListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DatabaseListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DatabaseListResponse
             * @function getTypeUrl
             * @memberof immudb.schema.DatabaseListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DatabaseListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.DatabaseListResponse";
            };

            return DatabaseListResponse;
        })();

        schema.DatabaseListRequestV2 = (function() {

            /**
             * Properties of a DatabaseListRequestV2.
             * @memberof immudb.schema
             * @interface IDatabaseListRequestV2
             */

            /**
             * Constructs a new DatabaseListRequestV2.
             * @memberof immudb.schema
             * @classdesc Represents a DatabaseListRequestV2.
             * @implements IDatabaseListRequestV2
             * @constructor
             * @param {immudb.schema.IDatabaseListRequestV2=} [properties] Properties to set
             */
            function DatabaseListRequestV2(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new DatabaseListRequestV2 instance using the specified properties.
             * @function create
             * @memberof immudb.schema.DatabaseListRequestV2
             * @static
             * @param {immudb.schema.IDatabaseListRequestV2=} [properties] Properties to set
             * @returns {immudb.schema.DatabaseListRequestV2} DatabaseListRequestV2 instance
             */
            DatabaseListRequestV2.create = function create(properties) {
                return new DatabaseListRequestV2(properties);
            };

            /**
             * Encodes the specified DatabaseListRequestV2 message. Does not implicitly {@link immudb.schema.DatabaseListRequestV2.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.DatabaseListRequestV2
             * @static
             * @param {immudb.schema.IDatabaseListRequestV2} message DatabaseListRequestV2 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DatabaseListRequestV2.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified DatabaseListRequestV2 message, length delimited. Does not implicitly {@link immudb.schema.DatabaseListRequestV2.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.DatabaseListRequestV2
             * @static
             * @param {immudb.schema.IDatabaseListRequestV2} message DatabaseListRequestV2 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DatabaseListRequestV2.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DatabaseListRequestV2 message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.DatabaseListRequestV2
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.DatabaseListRequestV2} DatabaseListRequestV2
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DatabaseListRequestV2.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.DatabaseListRequestV2();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DatabaseListRequestV2 message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.DatabaseListRequestV2
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.DatabaseListRequestV2} DatabaseListRequestV2
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DatabaseListRequestV2.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DatabaseListRequestV2 message.
             * @function verify
             * @memberof immudb.schema.DatabaseListRequestV2
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DatabaseListRequestV2.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a DatabaseListRequestV2 message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.DatabaseListRequestV2
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.DatabaseListRequestV2} DatabaseListRequestV2
             */
            DatabaseListRequestV2.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.DatabaseListRequestV2)
                    return object;
                return new $root.immudb.schema.DatabaseListRequestV2();
            };

            /**
             * Creates a plain object from a DatabaseListRequestV2 message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.DatabaseListRequestV2
             * @static
             * @param {immudb.schema.DatabaseListRequestV2} message DatabaseListRequestV2
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DatabaseListRequestV2.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this DatabaseListRequestV2 to JSON.
             * @function toJSON
             * @memberof immudb.schema.DatabaseListRequestV2
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DatabaseListRequestV2.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DatabaseListRequestV2
             * @function getTypeUrl
             * @memberof immudb.schema.DatabaseListRequestV2
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DatabaseListRequestV2.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.DatabaseListRequestV2";
            };

            return DatabaseListRequestV2;
        })();

        schema.DatabaseListResponseV2 = (function() {

            /**
             * Properties of a DatabaseListResponseV2.
             * @memberof immudb.schema
             * @interface IDatabaseListResponseV2
             * @property {Array.<immudb.schema.IDatabaseWithSettings>|null} [databases] DatabaseListResponseV2 databases
             */

            /**
             * Constructs a new DatabaseListResponseV2.
             * @memberof immudb.schema
             * @classdesc Represents a DatabaseListResponseV2.
             * @implements IDatabaseListResponseV2
             * @constructor
             * @param {immudb.schema.IDatabaseListResponseV2=} [properties] Properties to set
             */
            function DatabaseListResponseV2(properties) {
                this.databases = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DatabaseListResponseV2 databases.
             * @member {Array.<immudb.schema.IDatabaseWithSettings>} databases
             * @memberof immudb.schema.DatabaseListResponseV2
             * @instance
             */
            DatabaseListResponseV2.prototype.databases = $util.emptyArray;

            /**
             * Creates a new DatabaseListResponseV2 instance using the specified properties.
             * @function create
             * @memberof immudb.schema.DatabaseListResponseV2
             * @static
             * @param {immudb.schema.IDatabaseListResponseV2=} [properties] Properties to set
             * @returns {immudb.schema.DatabaseListResponseV2} DatabaseListResponseV2 instance
             */
            DatabaseListResponseV2.create = function create(properties) {
                return new DatabaseListResponseV2(properties);
            };

            /**
             * Encodes the specified DatabaseListResponseV2 message. Does not implicitly {@link immudb.schema.DatabaseListResponseV2.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.DatabaseListResponseV2
             * @static
             * @param {immudb.schema.IDatabaseListResponseV2} message DatabaseListResponseV2 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DatabaseListResponseV2.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.databases != null && message.databases.length)
                    for (let i = 0; i < message.databases.length; ++i)
                        $root.immudb.schema.DatabaseWithSettings.encode(message.databases[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DatabaseListResponseV2 message, length delimited. Does not implicitly {@link immudb.schema.DatabaseListResponseV2.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.DatabaseListResponseV2
             * @static
             * @param {immudb.schema.IDatabaseListResponseV2} message DatabaseListResponseV2 message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DatabaseListResponseV2.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DatabaseListResponseV2 message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.DatabaseListResponseV2
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.DatabaseListResponseV2} DatabaseListResponseV2
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DatabaseListResponseV2.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.DatabaseListResponseV2();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.databases && message.databases.length))
                                message.databases = [];
                            message.databases.push($root.immudb.schema.DatabaseWithSettings.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DatabaseListResponseV2 message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.DatabaseListResponseV2
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.DatabaseListResponseV2} DatabaseListResponseV2
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DatabaseListResponseV2.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DatabaseListResponseV2 message.
             * @function verify
             * @memberof immudb.schema.DatabaseListResponseV2
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DatabaseListResponseV2.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.databases != null && message.hasOwnProperty("databases")) {
                    if (!Array.isArray(message.databases))
                        return "databases: array expected";
                    for (let i = 0; i < message.databases.length; ++i) {
                        let error = $root.immudb.schema.DatabaseWithSettings.verify(message.databases[i]);
                        if (error)
                            return "databases." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a DatabaseListResponseV2 message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.DatabaseListResponseV2
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.DatabaseListResponseV2} DatabaseListResponseV2
             */
            DatabaseListResponseV2.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.DatabaseListResponseV2)
                    return object;
                let message = new $root.immudb.schema.DatabaseListResponseV2();
                if (object.databases) {
                    if (!Array.isArray(object.databases))
                        throw TypeError(".immudb.schema.DatabaseListResponseV2.databases: array expected");
                    message.databases = [];
                    for (let i = 0; i < object.databases.length; ++i) {
                        if (typeof object.databases[i] !== "object")
                            throw TypeError(".immudb.schema.DatabaseListResponseV2.databases: object expected");
                        message.databases[i] = $root.immudb.schema.DatabaseWithSettings.fromObject(object.databases[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a DatabaseListResponseV2 message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.DatabaseListResponseV2
             * @static
             * @param {immudb.schema.DatabaseListResponseV2} message DatabaseListResponseV2
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DatabaseListResponseV2.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.databases = [];
                if (message.databases && message.databases.length) {
                    object.databases = [];
                    for (let j = 0; j < message.databases.length; ++j)
                        object.databases[j] = $root.immudb.schema.DatabaseWithSettings.toObject(message.databases[j], options);
                }
                return object;
            };

            /**
             * Converts this DatabaseListResponseV2 to JSON.
             * @function toJSON
             * @memberof immudb.schema.DatabaseListResponseV2
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DatabaseListResponseV2.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DatabaseListResponseV2
             * @function getTypeUrl
             * @memberof immudb.schema.DatabaseListResponseV2
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DatabaseListResponseV2.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.DatabaseListResponseV2";
            };

            return DatabaseListResponseV2;
        })();

        schema.DatabaseWithSettings = (function() {

            /**
             * Properties of a DatabaseWithSettings.
             * @memberof immudb.schema
             * @interface IDatabaseWithSettings
             * @property {string|null} [name] DatabaseWithSettings name
             * @property {immudb.schema.IDatabaseNullableSettings|null} [settings] DatabaseWithSettings settings
             * @property {boolean|null} [loaded] DatabaseWithSettings loaded
             */

            /**
             * Constructs a new DatabaseWithSettings.
             * @memberof immudb.schema
             * @classdesc Represents a DatabaseWithSettings.
             * @implements IDatabaseWithSettings
             * @constructor
             * @param {immudb.schema.IDatabaseWithSettings=} [properties] Properties to set
             */
            function DatabaseWithSettings(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DatabaseWithSettings name.
             * @member {string} name
             * @memberof immudb.schema.DatabaseWithSettings
             * @instance
             */
            DatabaseWithSettings.prototype.name = "";

            /**
             * DatabaseWithSettings settings.
             * @member {immudb.schema.IDatabaseNullableSettings|null|undefined} settings
             * @memberof immudb.schema.DatabaseWithSettings
             * @instance
             */
            DatabaseWithSettings.prototype.settings = null;

            /**
             * DatabaseWithSettings loaded.
             * @member {boolean} loaded
             * @memberof immudb.schema.DatabaseWithSettings
             * @instance
             */
            DatabaseWithSettings.prototype.loaded = false;

            /**
             * Creates a new DatabaseWithSettings instance using the specified properties.
             * @function create
             * @memberof immudb.schema.DatabaseWithSettings
             * @static
             * @param {immudb.schema.IDatabaseWithSettings=} [properties] Properties to set
             * @returns {immudb.schema.DatabaseWithSettings} DatabaseWithSettings instance
             */
            DatabaseWithSettings.create = function create(properties) {
                return new DatabaseWithSettings(properties);
            };

            /**
             * Encodes the specified DatabaseWithSettings message. Does not implicitly {@link immudb.schema.DatabaseWithSettings.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.DatabaseWithSettings
             * @static
             * @param {immudb.schema.IDatabaseWithSettings} message DatabaseWithSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DatabaseWithSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.settings != null && Object.hasOwnProperty.call(message, "settings"))
                    $root.immudb.schema.DatabaseNullableSettings.encode(message.settings, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.loaded != null && Object.hasOwnProperty.call(message, "loaded"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.loaded);
                return writer;
            };

            /**
             * Encodes the specified DatabaseWithSettings message, length delimited. Does not implicitly {@link immudb.schema.DatabaseWithSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.DatabaseWithSettings
             * @static
             * @param {immudb.schema.IDatabaseWithSettings} message DatabaseWithSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DatabaseWithSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DatabaseWithSettings message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.DatabaseWithSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.DatabaseWithSettings} DatabaseWithSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DatabaseWithSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.DatabaseWithSettings();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.settings = $root.immudb.schema.DatabaseNullableSettings.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.loaded = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DatabaseWithSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.DatabaseWithSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.DatabaseWithSettings} DatabaseWithSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DatabaseWithSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DatabaseWithSettings message.
             * @function verify
             * @memberof immudb.schema.DatabaseWithSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DatabaseWithSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.settings != null && message.hasOwnProperty("settings")) {
                    let error = $root.immudb.schema.DatabaseNullableSettings.verify(message.settings);
                    if (error)
                        return "settings." + error;
                }
                if (message.loaded != null && message.hasOwnProperty("loaded"))
                    if (typeof message.loaded !== "boolean")
                        return "loaded: boolean expected";
                return null;
            };

            /**
             * Creates a DatabaseWithSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.DatabaseWithSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.DatabaseWithSettings} DatabaseWithSettings
             */
            DatabaseWithSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.DatabaseWithSettings)
                    return object;
                let message = new $root.immudb.schema.DatabaseWithSettings();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.settings != null) {
                    if (typeof object.settings !== "object")
                        throw TypeError(".immudb.schema.DatabaseWithSettings.settings: object expected");
                    message.settings = $root.immudb.schema.DatabaseNullableSettings.fromObject(object.settings);
                }
                if (object.loaded != null)
                    message.loaded = Boolean(object.loaded);
                return message;
            };

            /**
             * Creates a plain object from a DatabaseWithSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.DatabaseWithSettings
             * @static
             * @param {immudb.schema.DatabaseWithSettings} message DatabaseWithSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DatabaseWithSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.settings = null;
                    object.loaded = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.settings != null && message.hasOwnProperty("settings"))
                    object.settings = $root.immudb.schema.DatabaseNullableSettings.toObject(message.settings, options);
                if (message.loaded != null && message.hasOwnProperty("loaded"))
                    object.loaded = message.loaded;
                return object;
            };

            /**
             * Converts this DatabaseWithSettings to JSON.
             * @function toJSON
             * @memberof immudb.schema.DatabaseWithSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DatabaseWithSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DatabaseWithSettings
             * @function getTypeUrl
             * @memberof immudb.schema.DatabaseWithSettings
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DatabaseWithSettings.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.DatabaseWithSettings";
            };

            return DatabaseWithSettings;
        })();

        schema.Chunk = (function() {

            /**
             * Properties of a Chunk.
             * @memberof immudb.schema
             * @interface IChunk
             * @property {Uint8Array|null} [content] Chunk content
             */

            /**
             * Constructs a new Chunk.
             * @memberof immudb.schema
             * @classdesc Represents a Chunk.
             * @implements IChunk
             * @constructor
             * @param {immudb.schema.IChunk=} [properties] Properties to set
             */
            function Chunk(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Chunk content.
             * @member {Uint8Array} content
             * @memberof immudb.schema.Chunk
             * @instance
             */
            Chunk.prototype.content = $util.newBuffer([]);

            /**
             * Creates a new Chunk instance using the specified properties.
             * @function create
             * @memberof immudb.schema.Chunk
             * @static
             * @param {immudb.schema.IChunk=} [properties] Properties to set
             * @returns {immudb.schema.Chunk} Chunk instance
             */
            Chunk.create = function create(properties) {
                return new Chunk(properties);
            };

            /**
             * Encodes the specified Chunk message. Does not implicitly {@link immudb.schema.Chunk.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.Chunk
             * @static
             * @param {immudb.schema.IChunk} message Chunk message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Chunk.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.content);
                return writer;
            };

            /**
             * Encodes the specified Chunk message, length delimited. Does not implicitly {@link immudb.schema.Chunk.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.Chunk
             * @static
             * @param {immudb.schema.IChunk} message Chunk message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Chunk.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Chunk message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.Chunk
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.Chunk} Chunk
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Chunk.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.Chunk();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.content = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Chunk message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.Chunk
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.Chunk} Chunk
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Chunk.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Chunk message.
             * @function verify
             * @memberof immudb.schema.Chunk
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Chunk.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.content != null && message.hasOwnProperty("content"))
                    if (!(message.content && typeof message.content.length === "number" || $util.isString(message.content)))
                        return "content: buffer expected";
                return null;
            };

            /**
             * Creates a Chunk message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.Chunk
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.Chunk} Chunk
             */
            Chunk.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.Chunk)
                    return object;
                let message = new $root.immudb.schema.Chunk();
                if (object.content != null)
                    if (typeof object.content === "string")
                        $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                    else if (object.content.length >= 0)
                        message.content = object.content;
                return message;
            };

            /**
             * Creates a plain object from a Chunk message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.Chunk
             * @static
             * @param {immudb.schema.Chunk} message Chunk
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Chunk.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.content = "";
                    else {
                        object.content = [];
                        if (options.bytes !== Array)
                            object.content = $util.newBuffer(object.content);
                    }
                if (message.content != null && message.hasOwnProperty("content"))
                    object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
                return object;
            };

            /**
             * Converts this Chunk to JSON.
             * @function toJSON
             * @memberof immudb.schema.Chunk
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Chunk.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Chunk
             * @function getTypeUrl
             * @memberof immudb.schema.Chunk
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Chunk.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.Chunk";
            };

            return Chunk;
        })();

        schema.UseSnapshotRequest = (function() {

            /**
             * Properties of a UseSnapshotRequest.
             * @memberof immudb.schema
             * @interface IUseSnapshotRequest
             * @property {Long|null} [sinceTx] UseSnapshotRequest sinceTx
             * @property {Long|null} [asBeforeTx] UseSnapshotRequest asBeforeTx
             */

            /**
             * Constructs a new UseSnapshotRequest.
             * @memberof immudb.schema
             * @classdesc Represents a UseSnapshotRequest.
             * @implements IUseSnapshotRequest
             * @constructor
             * @param {immudb.schema.IUseSnapshotRequest=} [properties] Properties to set
             */
            function UseSnapshotRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UseSnapshotRequest sinceTx.
             * @member {Long} sinceTx
             * @memberof immudb.schema.UseSnapshotRequest
             * @instance
             */
            UseSnapshotRequest.prototype.sinceTx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * UseSnapshotRequest asBeforeTx.
             * @member {Long} asBeforeTx
             * @memberof immudb.schema.UseSnapshotRequest
             * @instance
             */
            UseSnapshotRequest.prototype.asBeforeTx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new UseSnapshotRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.UseSnapshotRequest
             * @static
             * @param {immudb.schema.IUseSnapshotRequest=} [properties] Properties to set
             * @returns {immudb.schema.UseSnapshotRequest} UseSnapshotRequest instance
             */
            UseSnapshotRequest.create = function create(properties) {
                return new UseSnapshotRequest(properties);
            };

            /**
             * Encodes the specified UseSnapshotRequest message. Does not implicitly {@link immudb.schema.UseSnapshotRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.UseSnapshotRequest
             * @static
             * @param {immudb.schema.IUseSnapshotRequest} message UseSnapshotRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UseSnapshotRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sinceTx != null && Object.hasOwnProperty.call(message, "sinceTx"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.sinceTx);
                if (message.asBeforeTx != null && Object.hasOwnProperty.call(message, "asBeforeTx"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.asBeforeTx);
                return writer;
            };

            /**
             * Encodes the specified UseSnapshotRequest message, length delimited. Does not implicitly {@link immudb.schema.UseSnapshotRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.UseSnapshotRequest
             * @static
             * @param {immudb.schema.IUseSnapshotRequest} message UseSnapshotRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UseSnapshotRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a UseSnapshotRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.UseSnapshotRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.UseSnapshotRequest} UseSnapshotRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UseSnapshotRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.UseSnapshotRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.sinceTx = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.asBeforeTx = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a UseSnapshotRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.UseSnapshotRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.UseSnapshotRequest} UseSnapshotRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UseSnapshotRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a UseSnapshotRequest message.
             * @function verify
             * @memberof immudb.schema.UseSnapshotRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UseSnapshotRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sinceTx != null && message.hasOwnProperty("sinceTx"))
                    if (!$util.isInteger(message.sinceTx) && !(message.sinceTx && $util.isInteger(message.sinceTx.low) && $util.isInteger(message.sinceTx.high)))
                        return "sinceTx: integer|Long expected";
                if (message.asBeforeTx != null && message.hasOwnProperty("asBeforeTx"))
                    if (!$util.isInteger(message.asBeforeTx) && !(message.asBeforeTx && $util.isInteger(message.asBeforeTx.low) && $util.isInteger(message.asBeforeTx.high)))
                        return "asBeforeTx: integer|Long expected";
                return null;
            };

            /**
             * Creates a UseSnapshotRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.UseSnapshotRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.UseSnapshotRequest} UseSnapshotRequest
             */
            UseSnapshotRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.UseSnapshotRequest)
                    return object;
                let message = new $root.immudb.schema.UseSnapshotRequest();
                if (object.sinceTx != null)
                    if ($util.Long)
                        (message.sinceTx = $util.Long.fromValue(object.sinceTx)).unsigned = true;
                    else if (typeof object.sinceTx === "string")
                        message.sinceTx = parseInt(object.sinceTx, 10);
                    else if (typeof object.sinceTx === "number")
                        message.sinceTx = object.sinceTx;
                    else if (typeof object.sinceTx === "object")
                        message.sinceTx = new $util.LongBits(object.sinceTx.low >>> 0, object.sinceTx.high >>> 0).toNumber(true);
                if (object.asBeforeTx != null)
                    if ($util.Long)
                        (message.asBeforeTx = $util.Long.fromValue(object.asBeforeTx)).unsigned = true;
                    else if (typeof object.asBeforeTx === "string")
                        message.asBeforeTx = parseInt(object.asBeforeTx, 10);
                    else if (typeof object.asBeforeTx === "number")
                        message.asBeforeTx = object.asBeforeTx;
                    else if (typeof object.asBeforeTx === "object")
                        message.asBeforeTx = new $util.LongBits(object.asBeforeTx.low >>> 0, object.asBeforeTx.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a UseSnapshotRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.UseSnapshotRequest
             * @static
             * @param {immudb.schema.UseSnapshotRequest} message UseSnapshotRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UseSnapshotRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.sinceTx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sinceTx = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.asBeforeTx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.asBeforeTx = options.longs === String ? "0" : 0;
                }
                if (message.sinceTx != null && message.hasOwnProperty("sinceTx"))
                    if (typeof message.sinceTx === "number")
                        object.sinceTx = options.longs === String ? String(message.sinceTx) : message.sinceTx;
                    else
                        object.sinceTx = options.longs === String ? $util.Long.prototype.toString.call(message.sinceTx) : options.longs === Number ? new $util.LongBits(message.sinceTx.low >>> 0, message.sinceTx.high >>> 0).toNumber(true) : message.sinceTx;
                if (message.asBeforeTx != null && message.hasOwnProperty("asBeforeTx"))
                    if (typeof message.asBeforeTx === "number")
                        object.asBeforeTx = options.longs === String ? String(message.asBeforeTx) : message.asBeforeTx;
                    else
                        object.asBeforeTx = options.longs === String ? $util.Long.prototype.toString.call(message.asBeforeTx) : options.longs === Number ? new $util.LongBits(message.asBeforeTx.low >>> 0, message.asBeforeTx.high >>> 0).toNumber(true) : message.asBeforeTx;
                return object;
            };

            /**
             * Converts this UseSnapshotRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.UseSnapshotRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UseSnapshotRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UseSnapshotRequest
             * @function getTypeUrl
             * @memberof immudb.schema.UseSnapshotRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UseSnapshotRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.UseSnapshotRequest";
            };

            return UseSnapshotRequest;
        })();

        schema.SQLExecRequest = (function() {

            /**
             * Properties of a SQLExecRequest.
             * @memberof immudb.schema
             * @interface ISQLExecRequest
             * @property {string|null} [sql] SQLExecRequest sql
             * @property {Array.<immudb.schema.INamedParam>|null} [params] SQLExecRequest params
             * @property {boolean|null} [noWait] SQLExecRequest noWait
             */

            /**
             * Constructs a new SQLExecRequest.
             * @memberof immudb.schema
             * @classdesc Represents a SQLExecRequest.
             * @implements ISQLExecRequest
             * @constructor
             * @param {immudb.schema.ISQLExecRequest=} [properties] Properties to set
             */
            function SQLExecRequest(properties) {
                this.params = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SQLExecRequest sql.
             * @member {string} sql
             * @memberof immudb.schema.SQLExecRequest
             * @instance
             */
            SQLExecRequest.prototype.sql = "";

            /**
             * SQLExecRequest params.
             * @member {Array.<immudb.schema.INamedParam>} params
             * @memberof immudb.schema.SQLExecRequest
             * @instance
             */
            SQLExecRequest.prototype.params = $util.emptyArray;

            /**
             * SQLExecRequest noWait.
             * @member {boolean} noWait
             * @memberof immudb.schema.SQLExecRequest
             * @instance
             */
            SQLExecRequest.prototype.noWait = false;

            /**
             * Creates a new SQLExecRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.SQLExecRequest
             * @static
             * @param {immudb.schema.ISQLExecRequest=} [properties] Properties to set
             * @returns {immudb.schema.SQLExecRequest} SQLExecRequest instance
             */
            SQLExecRequest.create = function create(properties) {
                return new SQLExecRequest(properties);
            };

            /**
             * Encodes the specified SQLExecRequest message. Does not implicitly {@link immudb.schema.SQLExecRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.SQLExecRequest
             * @static
             * @param {immudb.schema.ISQLExecRequest} message SQLExecRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SQLExecRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sql != null && Object.hasOwnProperty.call(message, "sql"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sql);
                if (message.params != null && message.params.length)
                    for (let i = 0; i < message.params.length; ++i)
                        $root.immudb.schema.NamedParam.encode(message.params[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.noWait != null && Object.hasOwnProperty.call(message, "noWait"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.noWait);
                return writer;
            };

            /**
             * Encodes the specified SQLExecRequest message, length delimited. Does not implicitly {@link immudb.schema.SQLExecRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.SQLExecRequest
             * @static
             * @param {immudb.schema.ISQLExecRequest} message SQLExecRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SQLExecRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SQLExecRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.SQLExecRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.SQLExecRequest} SQLExecRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SQLExecRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.SQLExecRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.sql = reader.string();
                            break;
                        }
                    case 2: {
                            if (!(message.params && message.params.length))
                                message.params = [];
                            message.params.push($root.immudb.schema.NamedParam.decode(reader, reader.uint32()));
                            break;
                        }
                    case 3: {
                            message.noWait = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SQLExecRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.SQLExecRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.SQLExecRequest} SQLExecRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SQLExecRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SQLExecRequest message.
             * @function verify
             * @memberof immudb.schema.SQLExecRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SQLExecRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sql != null && message.hasOwnProperty("sql"))
                    if (!$util.isString(message.sql))
                        return "sql: string expected";
                if (message.params != null && message.hasOwnProperty("params")) {
                    if (!Array.isArray(message.params))
                        return "params: array expected";
                    for (let i = 0; i < message.params.length; ++i) {
                        let error = $root.immudb.schema.NamedParam.verify(message.params[i]);
                        if (error)
                            return "params." + error;
                    }
                }
                if (message.noWait != null && message.hasOwnProperty("noWait"))
                    if (typeof message.noWait !== "boolean")
                        return "noWait: boolean expected";
                return null;
            };

            /**
             * Creates a SQLExecRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.SQLExecRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.SQLExecRequest} SQLExecRequest
             */
            SQLExecRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.SQLExecRequest)
                    return object;
                let message = new $root.immudb.schema.SQLExecRequest();
                if (object.sql != null)
                    message.sql = String(object.sql);
                if (object.params) {
                    if (!Array.isArray(object.params))
                        throw TypeError(".immudb.schema.SQLExecRequest.params: array expected");
                    message.params = [];
                    for (let i = 0; i < object.params.length; ++i) {
                        if (typeof object.params[i] !== "object")
                            throw TypeError(".immudb.schema.SQLExecRequest.params: object expected");
                        message.params[i] = $root.immudb.schema.NamedParam.fromObject(object.params[i]);
                    }
                }
                if (object.noWait != null)
                    message.noWait = Boolean(object.noWait);
                return message;
            };

            /**
             * Creates a plain object from a SQLExecRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.SQLExecRequest
             * @static
             * @param {immudb.schema.SQLExecRequest} message SQLExecRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SQLExecRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.params = [];
                if (options.defaults) {
                    object.sql = "";
                    object.noWait = false;
                }
                if (message.sql != null && message.hasOwnProperty("sql"))
                    object.sql = message.sql;
                if (message.params && message.params.length) {
                    object.params = [];
                    for (let j = 0; j < message.params.length; ++j)
                        object.params[j] = $root.immudb.schema.NamedParam.toObject(message.params[j], options);
                }
                if (message.noWait != null && message.hasOwnProperty("noWait"))
                    object.noWait = message.noWait;
                return object;
            };

            /**
             * Converts this SQLExecRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.SQLExecRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SQLExecRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SQLExecRequest
             * @function getTypeUrl
             * @memberof immudb.schema.SQLExecRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SQLExecRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.SQLExecRequest";
            };

            return SQLExecRequest;
        })();

        schema.SQLQueryRequest = (function() {

            /**
             * Properties of a SQLQueryRequest.
             * @memberof immudb.schema
             * @interface ISQLQueryRequest
             * @property {string|null} [sql] SQLQueryRequest sql
             * @property {Array.<immudb.schema.INamedParam>|null} [params] SQLQueryRequest params
             * @property {boolean|null} [reuseSnapshot] SQLQueryRequest reuseSnapshot
             */

            /**
             * Constructs a new SQLQueryRequest.
             * @memberof immudb.schema
             * @classdesc Represents a SQLQueryRequest.
             * @implements ISQLQueryRequest
             * @constructor
             * @param {immudb.schema.ISQLQueryRequest=} [properties] Properties to set
             */
            function SQLQueryRequest(properties) {
                this.params = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SQLQueryRequest sql.
             * @member {string} sql
             * @memberof immudb.schema.SQLQueryRequest
             * @instance
             */
            SQLQueryRequest.prototype.sql = "";

            /**
             * SQLQueryRequest params.
             * @member {Array.<immudb.schema.INamedParam>} params
             * @memberof immudb.schema.SQLQueryRequest
             * @instance
             */
            SQLQueryRequest.prototype.params = $util.emptyArray;

            /**
             * SQLQueryRequest reuseSnapshot.
             * @member {boolean} reuseSnapshot
             * @memberof immudb.schema.SQLQueryRequest
             * @instance
             */
            SQLQueryRequest.prototype.reuseSnapshot = false;

            /**
             * Creates a new SQLQueryRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.SQLQueryRequest
             * @static
             * @param {immudb.schema.ISQLQueryRequest=} [properties] Properties to set
             * @returns {immudb.schema.SQLQueryRequest} SQLQueryRequest instance
             */
            SQLQueryRequest.create = function create(properties) {
                return new SQLQueryRequest(properties);
            };

            /**
             * Encodes the specified SQLQueryRequest message. Does not implicitly {@link immudb.schema.SQLQueryRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.SQLQueryRequest
             * @static
             * @param {immudb.schema.ISQLQueryRequest} message SQLQueryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SQLQueryRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sql != null && Object.hasOwnProperty.call(message, "sql"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sql);
                if (message.params != null && message.params.length)
                    for (let i = 0; i < message.params.length; ++i)
                        $root.immudb.schema.NamedParam.encode(message.params[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.reuseSnapshot != null && Object.hasOwnProperty.call(message, "reuseSnapshot"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.reuseSnapshot);
                return writer;
            };

            /**
             * Encodes the specified SQLQueryRequest message, length delimited. Does not implicitly {@link immudb.schema.SQLQueryRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.SQLQueryRequest
             * @static
             * @param {immudb.schema.ISQLQueryRequest} message SQLQueryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SQLQueryRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SQLQueryRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.SQLQueryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.SQLQueryRequest} SQLQueryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SQLQueryRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.SQLQueryRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.sql = reader.string();
                            break;
                        }
                    case 2: {
                            if (!(message.params && message.params.length))
                                message.params = [];
                            message.params.push($root.immudb.schema.NamedParam.decode(reader, reader.uint32()));
                            break;
                        }
                    case 3: {
                            message.reuseSnapshot = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SQLQueryRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.SQLQueryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.SQLQueryRequest} SQLQueryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SQLQueryRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SQLQueryRequest message.
             * @function verify
             * @memberof immudb.schema.SQLQueryRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SQLQueryRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sql != null && message.hasOwnProperty("sql"))
                    if (!$util.isString(message.sql))
                        return "sql: string expected";
                if (message.params != null && message.hasOwnProperty("params")) {
                    if (!Array.isArray(message.params))
                        return "params: array expected";
                    for (let i = 0; i < message.params.length; ++i) {
                        let error = $root.immudb.schema.NamedParam.verify(message.params[i]);
                        if (error)
                            return "params." + error;
                    }
                }
                if (message.reuseSnapshot != null && message.hasOwnProperty("reuseSnapshot"))
                    if (typeof message.reuseSnapshot !== "boolean")
                        return "reuseSnapshot: boolean expected";
                return null;
            };

            /**
             * Creates a SQLQueryRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.SQLQueryRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.SQLQueryRequest} SQLQueryRequest
             */
            SQLQueryRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.SQLQueryRequest)
                    return object;
                let message = new $root.immudb.schema.SQLQueryRequest();
                if (object.sql != null)
                    message.sql = String(object.sql);
                if (object.params) {
                    if (!Array.isArray(object.params))
                        throw TypeError(".immudb.schema.SQLQueryRequest.params: array expected");
                    message.params = [];
                    for (let i = 0; i < object.params.length; ++i) {
                        if (typeof object.params[i] !== "object")
                            throw TypeError(".immudb.schema.SQLQueryRequest.params: object expected");
                        message.params[i] = $root.immudb.schema.NamedParam.fromObject(object.params[i]);
                    }
                }
                if (object.reuseSnapshot != null)
                    message.reuseSnapshot = Boolean(object.reuseSnapshot);
                return message;
            };

            /**
             * Creates a plain object from a SQLQueryRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.SQLQueryRequest
             * @static
             * @param {immudb.schema.SQLQueryRequest} message SQLQueryRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SQLQueryRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.params = [];
                if (options.defaults) {
                    object.sql = "";
                    object.reuseSnapshot = false;
                }
                if (message.sql != null && message.hasOwnProperty("sql"))
                    object.sql = message.sql;
                if (message.params && message.params.length) {
                    object.params = [];
                    for (let j = 0; j < message.params.length; ++j)
                        object.params[j] = $root.immudb.schema.NamedParam.toObject(message.params[j], options);
                }
                if (message.reuseSnapshot != null && message.hasOwnProperty("reuseSnapshot"))
                    object.reuseSnapshot = message.reuseSnapshot;
                return object;
            };

            /**
             * Converts this SQLQueryRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.SQLQueryRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SQLQueryRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SQLQueryRequest
             * @function getTypeUrl
             * @memberof immudb.schema.SQLQueryRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SQLQueryRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.SQLQueryRequest";
            };

            return SQLQueryRequest;
        })();

        schema.NamedParam = (function() {

            /**
             * Properties of a NamedParam.
             * @memberof immudb.schema
             * @interface INamedParam
             * @property {string|null} [name] NamedParam name
             * @property {immudb.schema.ISQLValue|null} [value] NamedParam value
             */

            /**
             * Constructs a new NamedParam.
             * @memberof immudb.schema
             * @classdesc Represents a NamedParam.
             * @implements INamedParam
             * @constructor
             * @param {immudb.schema.INamedParam=} [properties] Properties to set
             */
            function NamedParam(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NamedParam name.
             * @member {string} name
             * @memberof immudb.schema.NamedParam
             * @instance
             */
            NamedParam.prototype.name = "";

            /**
             * NamedParam value.
             * @member {immudb.schema.ISQLValue|null|undefined} value
             * @memberof immudb.schema.NamedParam
             * @instance
             */
            NamedParam.prototype.value = null;

            /**
             * Creates a new NamedParam instance using the specified properties.
             * @function create
             * @memberof immudb.schema.NamedParam
             * @static
             * @param {immudb.schema.INamedParam=} [properties] Properties to set
             * @returns {immudb.schema.NamedParam} NamedParam instance
             */
            NamedParam.create = function create(properties) {
                return new NamedParam(properties);
            };

            /**
             * Encodes the specified NamedParam message. Does not implicitly {@link immudb.schema.NamedParam.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.NamedParam
             * @static
             * @param {immudb.schema.INamedParam} message NamedParam message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NamedParam.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    $root.immudb.schema.SQLValue.encode(message.value, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified NamedParam message, length delimited. Does not implicitly {@link immudb.schema.NamedParam.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.NamedParam
             * @static
             * @param {immudb.schema.INamedParam} message NamedParam message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NamedParam.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NamedParam message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.NamedParam
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.NamedParam} NamedParam
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NamedParam.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.NamedParam();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.value = $root.immudb.schema.SQLValue.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NamedParam message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.NamedParam
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.NamedParam} NamedParam
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NamedParam.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NamedParam message.
             * @function verify
             * @memberof immudb.schema.NamedParam
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NamedParam.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.value != null && message.hasOwnProperty("value")) {
                    let error = $root.immudb.schema.SQLValue.verify(message.value);
                    if (error)
                        return "value." + error;
                }
                return null;
            };

            /**
             * Creates a NamedParam message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.NamedParam
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.NamedParam} NamedParam
             */
            NamedParam.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.NamedParam)
                    return object;
                let message = new $root.immudb.schema.NamedParam();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.value != null) {
                    if (typeof object.value !== "object")
                        throw TypeError(".immudb.schema.NamedParam.value: object expected");
                    message.value = $root.immudb.schema.SQLValue.fromObject(object.value);
                }
                return message;
            };

            /**
             * Creates a plain object from a NamedParam message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.NamedParam
             * @static
             * @param {immudb.schema.NamedParam} message NamedParam
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NamedParam.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.value = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = $root.immudb.schema.SQLValue.toObject(message.value, options);
                return object;
            };

            /**
             * Converts this NamedParam to JSON.
             * @function toJSON
             * @memberof immudb.schema.NamedParam
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NamedParam.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for NamedParam
             * @function getTypeUrl
             * @memberof immudb.schema.NamedParam
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            NamedParam.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.NamedParam";
            };

            return NamedParam;
        })();

        schema.SQLExecResult = (function() {

            /**
             * Properties of a SQLExecResult.
             * @memberof immudb.schema
             * @interface ISQLExecResult
             * @property {Array.<immudb.schema.ICommittedSQLTx>|null} [txs] SQLExecResult txs
             * @property {boolean|null} [ongoingTx] SQLExecResult ongoingTx
             */

            /**
             * Constructs a new SQLExecResult.
             * @memberof immudb.schema
             * @classdesc Represents a SQLExecResult.
             * @implements ISQLExecResult
             * @constructor
             * @param {immudb.schema.ISQLExecResult=} [properties] Properties to set
             */
            function SQLExecResult(properties) {
                this.txs = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SQLExecResult txs.
             * @member {Array.<immudb.schema.ICommittedSQLTx>} txs
             * @memberof immudb.schema.SQLExecResult
             * @instance
             */
            SQLExecResult.prototype.txs = $util.emptyArray;

            /**
             * SQLExecResult ongoingTx.
             * @member {boolean} ongoingTx
             * @memberof immudb.schema.SQLExecResult
             * @instance
             */
            SQLExecResult.prototype.ongoingTx = false;

            /**
             * Creates a new SQLExecResult instance using the specified properties.
             * @function create
             * @memberof immudb.schema.SQLExecResult
             * @static
             * @param {immudb.schema.ISQLExecResult=} [properties] Properties to set
             * @returns {immudb.schema.SQLExecResult} SQLExecResult instance
             */
            SQLExecResult.create = function create(properties) {
                return new SQLExecResult(properties);
            };

            /**
             * Encodes the specified SQLExecResult message. Does not implicitly {@link immudb.schema.SQLExecResult.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.SQLExecResult
             * @static
             * @param {immudb.schema.ISQLExecResult} message SQLExecResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SQLExecResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.txs != null && message.txs.length)
                    for (let i = 0; i < message.txs.length; ++i)
                        $root.immudb.schema.CommittedSQLTx.encode(message.txs[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.ongoingTx != null && Object.hasOwnProperty.call(message, "ongoingTx"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.ongoingTx);
                return writer;
            };

            /**
             * Encodes the specified SQLExecResult message, length delimited. Does not implicitly {@link immudb.schema.SQLExecResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.SQLExecResult
             * @static
             * @param {immudb.schema.ISQLExecResult} message SQLExecResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SQLExecResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SQLExecResult message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.SQLExecResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.SQLExecResult} SQLExecResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SQLExecResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.SQLExecResult();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 5: {
                            if (!(message.txs && message.txs.length))
                                message.txs = [];
                            message.txs.push($root.immudb.schema.CommittedSQLTx.decode(reader, reader.uint32()));
                            break;
                        }
                    case 6: {
                            message.ongoingTx = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SQLExecResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.SQLExecResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.SQLExecResult} SQLExecResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SQLExecResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SQLExecResult message.
             * @function verify
             * @memberof immudb.schema.SQLExecResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SQLExecResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.txs != null && message.hasOwnProperty("txs")) {
                    if (!Array.isArray(message.txs))
                        return "txs: array expected";
                    for (let i = 0; i < message.txs.length; ++i) {
                        let error = $root.immudb.schema.CommittedSQLTx.verify(message.txs[i]);
                        if (error)
                            return "txs." + error;
                    }
                }
                if (message.ongoingTx != null && message.hasOwnProperty("ongoingTx"))
                    if (typeof message.ongoingTx !== "boolean")
                        return "ongoingTx: boolean expected";
                return null;
            };

            /**
             * Creates a SQLExecResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.SQLExecResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.SQLExecResult} SQLExecResult
             */
            SQLExecResult.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.SQLExecResult)
                    return object;
                let message = new $root.immudb.schema.SQLExecResult();
                if (object.txs) {
                    if (!Array.isArray(object.txs))
                        throw TypeError(".immudb.schema.SQLExecResult.txs: array expected");
                    message.txs = [];
                    for (let i = 0; i < object.txs.length; ++i) {
                        if (typeof object.txs[i] !== "object")
                            throw TypeError(".immudb.schema.SQLExecResult.txs: object expected");
                        message.txs[i] = $root.immudb.schema.CommittedSQLTx.fromObject(object.txs[i]);
                    }
                }
                if (object.ongoingTx != null)
                    message.ongoingTx = Boolean(object.ongoingTx);
                return message;
            };

            /**
             * Creates a plain object from a SQLExecResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.SQLExecResult
             * @static
             * @param {immudb.schema.SQLExecResult} message SQLExecResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SQLExecResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.txs = [];
                if (options.defaults)
                    object.ongoingTx = false;
                if (message.txs && message.txs.length) {
                    object.txs = [];
                    for (let j = 0; j < message.txs.length; ++j)
                        object.txs[j] = $root.immudb.schema.CommittedSQLTx.toObject(message.txs[j], options);
                }
                if (message.ongoingTx != null && message.hasOwnProperty("ongoingTx"))
                    object.ongoingTx = message.ongoingTx;
                return object;
            };

            /**
             * Converts this SQLExecResult to JSON.
             * @function toJSON
             * @memberof immudb.schema.SQLExecResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SQLExecResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SQLExecResult
             * @function getTypeUrl
             * @memberof immudb.schema.SQLExecResult
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SQLExecResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.SQLExecResult";
            };

            return SQLExecResult;
        })();

        schema.CommittedSQLTx = (function() {

            /**
             * Properties of a CommittedSQLTx.
             * @memberof immudb.schema
             * @interface ICommittedSQLTx
             * @property {immudb.schema.ITxHeader|null} [header] CommittedSQLTx header
             * @property {number|null} [updatedRows] CommittedSQLTx updatedRows
             * @property {Object.<string,immudb.schema.ISQLValue>|null} [lastInsertedPKs] CommittedSQLTx lastInsertedPKs
             * @property {Object.<string,immudb.schema.ISQLValue>|null} [firstInsertedPKs] CommittedSQLTx firstInsertedPKs
             */

            /**
             * Constructs a new CommittedSQLTx.
             * @memberof immudb.schema
             * @classdesc Represents a CommittedSQLTx.
             * @implements ICommittedSQLTx
             * @constructor
             * @param {immudb.schema.ICommittedSQLTx=} [properties] Properties to set
             */
            function CommittedSQLTx(properties) {
                this.lastInsertedPKs = {};
                this.firstInsertedPKs = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CommittedSQLTx header.
             * @member {immudb.schema.ITxHeader|null|undefined} header
             * @memberof immudb.schema.CommittedSQLTx
             * @instance
             */
            CommittedSQLTx.prototype.header = null;

            /**
             * CommittedSQLTx updatedRows.
             * @member {number} updatedRows
             * @memberof immudb.schema.CommittedSQLTx
             * @instance
             */
            CommittedSQLTx.prototype.updatedRows = 0;

            /**
             * CommittedSQLTx lastInsertedPKs.
             * @member {Object.<string,immudb.schema.ISQLValue>} lastInsertedPKs
             * @memberof immudb.schema.CommittedSQLTx
             * @instance
             */
            CommittedSQLTx.prototype.lastInsertedPKs = $util.emptyObject;

            /**
             * CommittedSQLTx firstInsertedPKs.
             * @member {Object.<string,immudb.schema.ISQLValue>} firstInsertedPKs
             * @memberof immudb.schema.CommittedSQLTx
             * @instance
             */
            CommittedSQLTx.prototype.firstInsertedPKs = $util.emptyObject;

            /**
             * Creates a new CommittedSQLTx instance using the specified properties.
             * @function create
             * @memberof immudb.schema.CommittedSQLTx
             * @static
             * @param {immudb.schema.ICommittedSQLTx=} [properties] Properties to set
             * @returns {immudb.schema.CommittedSQLTx} CommittedSQLTx instance
             */
            CommittedSQLTx.create = function create(properties) {
                return new CommittedSQLTx(properties);
            };

            /**
             * Encodes the specified CommittedSQLTx message. Does not implicitly {@link immudb.schema.CommittedSQLTx.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.CommittedSQLTx
             * @static
             * @param {immudb.schema.ICommittedSQLTx} message CommittedSQLTx message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommittedSQLTx.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.header != null && Object.hasOwnProperty.call(message, "header"))
                    $root.immudb.schema.TxHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.updatedRows != null && Object.hasOwnProperty.call(message, "updatedRows"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.updatedRows);
                if (message.lastInsertedPKs != null && Object.hasOwnProperty.call(message, "lastInsertedPKs"))
                    for (let keys = Object.keys(message.lastInsertedPKs), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.immudb.schema.SQLValue.encode(message.lastInsertedPKs[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                if (message.firstInsertedPKs != null && Object.hasOwnProperty.call(message, "firstInsertedPKs"))
                    for (let keys = Object.keys(message.firstInsertedPKs), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.immudb.schema.SQLValue.encode(message.firstInsertedPKs[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Encodes the specified CommittedSQLTx message, length delimited. Does not implicitly {@link immudb.schema.CommittedSQLTx.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.CommittedSQLTx
             * @static
             * @param {immudb.schema.ICommittedSQLTx} message CommittedSQLTx message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommittedSQLTx.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CommittedSQLTx message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.CommittedSQLTx
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.CommittedSQLTx} CommittedSQLTx
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommittedSQLTx.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.CommittedSQLTx(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.header = $root.immudb.schema.TxHeader.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.updatedRows = reader.uint32();
                            break;
                        }
                    case 3: {
                            if (message.lastInsertedPKs === $util.emptyObject)
                                message.lastInsertedPKs = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = null;
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = $root.immudb.schema.SQLValue.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.lastInsertedPKs[key] = value;
                            break;
                        }
                    case 4: {
                            if (message.firstInsertedPKs === $util.emptyObject)
                                message.firstInsertedPKs = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = null;
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = $root.immudb.schema.SQLValue.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.firstInsertedPKs[key] = value;
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CommittedSQLTx message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.CommittedSQLTx
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.CommittedSQLTx} CommittedSQLTx
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommittedSQLTx.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CommittedSQLTx message.
             * @function verify
             * @memberof immudb.schema.CommittedSQLTx
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CommittedSQLTx.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.header != null && message.hasOwnProperty("header")) {
                    let error = $root.immudb.schema.TxHeader.verify(message.header);
                    if (error)
                        return "header." + error;
                }
                if (message.updatedRows != null && message.hasOwnProperty("updatedRows"))
                    if (!$util.isInteger(message.updatedRows))
                        return "updatedRows: integer expected";
                if (message.lastInsertedPKs != null && message.hasOwnProperty("lastInsertedPKs")) {
                    if (!$util.isObject(message.lastInsertedPKs))
                        return "lastInsertedPKs: object expected";
                    let key = Object.keys(message.lastInsertedPKs);
                    for (let i = 0; i < key.length; ++i) {
                        let error = $root.immudb.schema.SQLValue.verify(message.lastInsertedPKs[key[i]]);
                        if (error)
                            return "lastInsertedPKs." + error;
                    }
                }
                if (message.firstInsertedPKs != null && message.hasOwnProperty("firstInsertedPKs")) {
                    if (!$util.isObject(message.firstInsertedPKs))
                        return "firstInsertedPKs: object expected";
                    let key = Object.keys(message.firstInsertedPKs);
                    for (let i = 0; i < key.length; ++i) {
                        let error = $root.immudb.schema.SQLValue.verify(message.firstInsertedPKs[key[i]]);
                        if (error)
                            return "firstInsertedPKs." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a CommittedSQLTx message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.CommittedSQLTx
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.CommittedSQLTx} CommittedSQLTx
             */
            CommittedSQLTx.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.CommittedSQLTx)
                    return object;
                let message = new $root.immudb.schema.CommittedSQLTx();
                if (object.header != null) {
                    if (typeof object.header !== "object")
                        throw TypeError(".immudb.schema.CommittedSQLTx.header: object expected");
                    message.header = $root.immudb.schema.TxHeader.fromObject(object.header);
                }
                if (object.updatedRows != null)
                    message.updatedRows = object.updatedRows >>> 0;
                if (object.lastInsertedPKs) {
                    if (typeof object.lastInsertedPKs !== "object")
                        throw TypeError(".immudb.schema.CommittedSQLTx.lastInsertedPKs: object expected");
                    message.lastInsertedPKs = {};
                    for (let keys = Object.keys(object.lastInsertedPKs), i = 0; i < keys.length; ++i) {
                        if (typeof object.lastInsertedPKs[keys[i]] !== "object")
                            throw TypeError(".immudb.schema.CommittedSQLTx.lastInsertedPKs: object expected");
                        message.lastInsertedPKs[keys[i]] = $root.immudb.schema.SQLValue.fromObject(object.lastInsertedPKs[keys[i]]);
                    }
                }
                if (object.firstInsertedPKs) {
                    if (typeof object.firstInsertedPKs !== "object")
                        throw TypeError(".immudb.schema.CommittedSQLTx.firstInsertedPKs: object expected");
                    message.firstInsertedPKs = {};
                    for (let keys = Object.keys(object.firstInsertedPKs), i = 0; i < keys.length; ++i) {
                        if (typeof object.firstInsertedPKs[keys[i]] !== "object")
                            throw TypeError(".immudb.schema.CommittedSQLTx.firstInsertedPKs: object expected");
                        message.firstInsertedPKs[keys[i]] = $root.immudb.schema.SQLValue.fromObject(object.firstInsertedPKs[keys[i]]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a CommittedSQLTx message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.CommittedSQLTx
             * @static
             * @param {immudb.schema.CommittedSQLTx} message CommittedSQLTx
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CommittedSQLTx.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.objects || options.defaults) {
                    object.lastInsertedPKs = {};
                    object.firstInsertedPKs = {};
                }
                if (options.defaults) {
                    object.header = null;
                    object.updatedRows = 0;
                }
                if (message.header != null && message.hasOwnProperty("header"))
                    object.header = $root.immudb.schema.TxHeader.toObject(message.header, options);
                if (message.updatedRows != null && message.hasOwnProperty("updatedRows"))
                    object.updatedRows = message.updatedRows;
                let keys2;
                if (message.lastInsertedPKs && (keys2 = Object.keys(message.lastInsertedPKs)).length) {
                    object.lastInsertedPKs = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.lastInsertedPKs[keys2[j]] = $root.immudb.schema.SQLValue.toObject(message.lastInsertedPKs[keys2[j]], options);
                }
                if (message.firstInsertedPKs && (keys2 = Object.keys(message.firstInsertedPKs)).length) {
                    object.firstInsertedPKs = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.firstInsertedPKs[keys2[j]] = $root.immudb.schema.SQLValue.toObject(message.firstInsertedPKs[keys2[j]], options);
                }
                return object;
            };

            /**
             * Converts this CommittedSQLTx to JSON.
             * @function toJSON
             * @memberof immudb.schema.CommittedSQLTx
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CommittedSQLTx.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CommittedSQLTx
             * @function getTypeUrl
             * @memberof immudb.schema.CommittedSQLTx
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CommittedSQLTx.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.CommittedSQLTx";
            };

            return CommittedSQLTx;
        })();

        schema.SQLQueryResult = (function() {

            /**
             * Properties of a SQLQueryResult.
             * @memberof immudb.schema
             * @interface ISQLQueryResult
             * @property {Array.<immudb.schema.IColumn>|null} [columns] SQLQueryResult columns
             * @property {Array.<immudb.schema.IRow>|null} [rows] SQLQueryResult rows
             */

            /**
             * Constructs a new SQLQueryResult.
             * @memberof immudb.schema
             * @classdesc Represents a SQLQueryResult.
             * @implements ISQLQueryResult
             * @constructor
             * @param {immudb.schema.ISQLQueryResult=} [properties] Properties to set
             */
            function SQLQueryResult(properties) {
                this.columns = [];
                this.rows = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SQLQueryResult columns.
             * @member {Array.<immudb.schema.IColumn>} columns
             * @memberof immudb.schema.SQLQueryResult
             * @instance
             */
            SQLQueryResult.prototype.columns = $util.emptyArray;

            /**
             * SQLQueryResult rows.
             * @member {Array.<immudb.schema.IRow>} rows
             * @memberof immudb.schema.SQLQueryResult
             * @instance
             */
            SQLQueryResult.prototype.rows = $util.emptyArray;

            /**
             * Creates a new SQLQueryResult instance using the specified properties.
             * @function create
             * @memberof immudb.schema.SQLQueryResult
             * @static
             * @param {immudb.schema.ISQLQueryResult=} [properties] Properties to set
             * @returns {immudb.schema.SQLQueryResult} SQLQueryResult instance
             */
            SQLQueryResult.create = function create(properties) {
                return new SQLQueryResult(properties);
            };

            /**
             * Encodes the specified SQLQueryResult message. Does not implicitly {@link immudb.schema.SQLQueryResult.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.SQLQueryResult
             * @static
             * @param {immudb.schema.ISQLQueryResult} message SQLQueryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SQLQueryResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rows != null && message.rows.length)
                    for (let i = 0; i < message.rows.length; ++i)
                        $root.immudb.schema.Row.encode(message.rows[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.columns != null && message.columns.length)
                    for (let i = 0; i < message.columns.length; ++i)
                        $root.immudb.schema.Column.encode(message.columns[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SQLQueryResult message, length delimited. Does not implicitly {@link immudb.schema.SQLQueryResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.SQLQueryResult
             * @static
             * @param {immudb.schema.ISQLQueryResult} message SQLQueryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SQLQueryResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SQLQueryResult message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.SQLQueryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.SQLQueryResult} SQLQueryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SQLQueryResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.SQLQueryResult();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2: {
                            if (!(message.columns && message.columns.length))
                                message.columns = [];
                            message.columns.push($root.immudb.schema.Column.decode(reader, reader.uint32()));
                            break;
                        }
                    case 1: {
                            if (!(message.rows && message.rows.length))
                                message.rows = [];
                            message.rows.push($root.immudb.schema.Row.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SQLQueryResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.SQLQueryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.SQLQueryResult} SQLQueryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SQLQueryResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SQLQueryResult message.
             * @function verify
             * @memberof immudb.schema.SQLQueryResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SQLQueryResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.columns != null && message.hasOwnProperty("columns")) {
                    if (!Array.isArray(message.columns))
                        return "columns: array expected";
                    for (let i = 0; i < message.columns.length; ++i) {
                        let error = $root.immudb.schema.Column.verify(message.columns[i]);
                        if (error)
                            return "columns." + error;
                    }
                }
                if (message.rows != null && message.hasOwnProperty("rows")) {
                    if (!Array.isArray(message.rows))
                        return "rows: array expected";
                    for (let i = 0; i < message.rows.length; ++i) {
                        let error = $root.immudb.schema.Row.verify(message.rows[i]);
                        if (error)
                            return "rows." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a SQLQueryResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.SQLQueryResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.SQLQueryResult} SQLQueryResult
             */
            SQLQueryResult.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.SQLQueryResult)
                    return object;
                let message = new $root.immudb.schema.SQLQueryResult();
                if (object.columns) {
                    if (!Array.isArray(object.columns))
                        throw TypeError(".immudb.schema.SQLQueryResult.columns: array expected");
                    message.columns = [];
                    for (let i = 0; i < object.columns.length; ++i) {
                        if (typeof object.columns[i] !== "object")
                            throw TypeError(".immudb.schema.SQLQueryResult.columns: object expected");
                        message.columns[i] = $root.immudb.schema.Column.fromObject(object.columns[i]);
                    }
                }
                if (object.rows) {
                    if (!Array.isArray(object.rows))
                        throw TypeError(".immudb.schema.SQLQueryResult.rows: array expected");
                    message.rows = [];
                    for (let i = 0; i < object.rows.length; ++i) {
                        if (typeof object.rows[i] !== "object")
                            throw TypeError(".immudb.schema.SQLQueryResult.rows: object expected");
                        message.rows[i] = $root.immudb.schema.Row.fromObject(object.rows[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a SQLQueryResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.SQLQueryResult
             * @static
             * @param {immudb.schema.SQLQueryResult} message SQLQueryResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SQLQueryResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.rows = [];
                    object.columns = [];
                }
                if (message.rows && message.rows.length) {
                    object.rows = [];
                    for (let j = 0; j < message.rows.length; ++j)
                        object.rows[j] = $root.immudb.schema.Row.toObject(message.rows[j], options);
                }
                if (message.columns && message.columns.length) {
                    object.columns = [];
                    for (let j = 0; j < message.columns.length; ++j)
                        object.columns[j] = $root.immudb.schema.Column.toObject(message.columns[j], options);
                }
                return object;
            };

            /**
             * Converts this SQLQueryResult to JSON.
             * @function toJSON
             * @memberof immudb.schema.SQLQueryResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SQLQueryResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SQLQueryResult
             * @function getTypeUrl
             * @memberof immudb.schema.SQLQueryResult
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SQLQueryResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.SQLQueryResult";
            };

            return SQLQueryResult;
        })();

        schema.Column = (function() {

            /**
             * Properties of a Column.
             * @memberof immudb.schema
             * @interface IColumn
             * @property {string|null} [name] Column name
             * @property {string|null} [type] Column type
             */

            /**
             * Constructs a new Column.
             * @memberof immudb.schema
             * @classdesc Represents a Column.
             * @implements IColumn
             * @constructor
             * @param {immudb.schema.IColumn=} [properties] Properties to set
             */
            function Column(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Column name.
             * @member {string} name
             * @memberof immudb.schema.Column
             * @instance
             */
            Column.prototype.name = "";

            /**
             * Column type.
             * @member {string} type
             * @memberof immudb.schema.Column
             * @instance
             */
            Column.prototype.type = "";

            /**
             * Creates a new Column instance using the specified properties.
             * @function create
             * @memberof immudb.schema.Column
             * @static
             * @param {immudb.schema.IColumn=} [properties] Properties to set
             * @returns {immudb.schema.Column} Column instance
             */
            Column.create = function create(properties) {
                return new Column(properties);
            };

            /**
             * Encodes the specified Column message. Does not implicitly {@link immudb.schema.Column.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.Column
             * @static
             * @param {immudb.schema.IColumn} message Column message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Column.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.type);
                return writer;
            };

            /**
             * Encodes the specified Column message, length delimited. Does not implicitly {@link immudb.schema.Column.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.Column
             * @static
             * @param {immudb.schema.IColumn} message Column message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Column.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Column message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.Column
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.Column} Column
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Column.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.Column();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.type = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Column message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.Column
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.Column} Column
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Column.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Column message.
             * @function verify
             * @memberof immudb.schema.Column
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Column.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isString(message.type))
                        return "type: string expected";
                return null;
            };

            /**
             * Creates a Column message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.Column
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.Column} Column
             */
            Column.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.Column)
                    return object;
                let message = new $root.immudb.schema.Column();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.type != null)
                    message.type = String(object.type);
                return message;
            };

            /**
             * Creates a plain object from a Column message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.Column
             * @static
             * @param {immudb.schema.Column} message Column
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Column.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.type = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                return object;
            };

            /**
             * Converts this Column to JSON.
             * @function toJSON
             * @memberof immudb.schema.Column
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Column.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Column
             * @function getTypeUrl
             * @memberof immudb.schema.Column
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Column.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.Column";
            };

            return Column;
        })();

        schema.Row = (function() {

            /**
             * Properties of a Row.
             * @memberof immudb.schema
             * @interface IRow
             * @property {Array.<string>|null} [columns] Row columns
             * @property {Array.<immudb.schema.ISQLValue>|null} [values] Row values
             */

            /**
             * Constructs a new Row.
             * @memberof immudb.schema
             * @classdesc Represents a Row.
             * @implements IRow
             * @constructor
             * @param {immudb.schema.IRow=} [properties] Properties to set
             */
            function Row(properties) {
                this.columns = [];
                this.values = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Row columns.
             * @member {Array.<string>} columns
             * @memberof immudb.schema.Row
             * @instance
             */
            Row.prototype.columns = $util.emptyArray;

            /**
             * Row values.
             * @member {Array.<immudb.schema.ISQLValue>} values
             * @memberof immudb.schema.Row
             * @instance
             */
            Row.prototype.values = $util.emptyArray;

            /**
             * Creates a new Row instance using the specified properties.
             * @function create
             * @memberof immudb.schema.Row
             * @static
             * @param {immudb.schema.IRow=} [properties] Properties to set
             * @returns {immudb.schema.Row} Row instance
             */
            Row.create = function create(properties) {
                return new Row(properties);
            };

            /**
             * Encodes the specified Row message. Does not implicitly {@link immudb.schema.Row.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.Row
             * @static
             * @param {immudb.schema.IRow} message Row message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Row.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.columns != null && message.columns.length)
                    for (let i = 0; i < message.columns.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.columns[i]);
                if (message.values != null && message.values.length)
                    for (let i = 0; i < message.values.length; ++i)
                        $root.immudb.schema.SQLValue.encode(message.values[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Row message, length delimited. Does not implicitly {@link immudb.schema.Row.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.Row
             * @static
             * @param {immudb.schema.IRow} message Row message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Row.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Row message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.Row
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.Row} Row
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Row.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.Row();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.columns && message.columns.length))
                                message.columns = [];
                            message.columns.push(reader.string());
                            break;
                        }
                    case 2: {
                            if (!(message.values && message.values.length))
                                message.values = [];
                            message.values.push($root.immudb.schema.SQLValue.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Row message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.Row
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.Row} Row
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Row.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Row message.
             * @function verify
             * @memberof immudb.schema.Row
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Row.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.columns != null && message.hasOwnProperty("columns")) {
                    if (!Array.isArray(message.columns))
                        return "columns: array expected";
                    for (let i = 0; i < message.columns.length; ++i)
                        if (!$util.isString(message.columns[i]))
                            return "columns: string[] expected";
                }
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (let i = 0; i < message.values.length; ++i) {
                        let error = $root.immudb.schema.SQLValue.verify(message.values[i]);
                        if (error)
                            return "values." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Row message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.Row
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.Row} Row
             */
            Row.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.Row)
                    return object;
                let message = new $root.immudb.schema.Row();
                if (object.columns) {
                    if (!Array.isArray(object.columns))
                        throw TypeError(".immudb.schema.Row.columns: array expected");
                    message.columns = [];
                    for (let i = 0; i < object.columns.length; ++i)
                        message.columns[i] = String(object.columns[i]);
                }
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".immudb.schema.Row.values: array expected");
                    message.values = [];
                    for (let i = 0; i < object.values.length; ++i) {
                        if (typeof object.values[i] !== "object")
                            throw TypeError(".immudb.schema.Row.values: object expected");
                        message.values[i] = $root.immudb.schema.SQLValue.fromObject(object.values[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Row message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.Row
             * @static
             * @param {immudb.schema.Row} message Row
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Row.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.columns = [];
                    object.values = [];
                }
                if (message.columns && message.columns.length) {
                    object.columns = [];
                    for (let j = 0; j < message.columns.length; ++j)
                        object.columns[j] = message.columns[j];
                }
                if (message.values && message.values.length) {
                    object.values = [];
                    for (let j = 0; j < message.values.length; ++j)
                        object.values[j] = $root.immudb.schema.SQLValue.toObject(message.values[j], options);
                }
                return object;
            };

            /**
             * Converts this Row to JSON.
             * @function toJSON
             * @memberof immudb.schema.Row
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Row.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Row
             * @function getTypeUrl
             * @memberof immudb.schema.Row
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Row.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.Row";
            };

            return Row;
        })();

        schema.SQLValue = (function() {

            /**
             * Properties of a SQLValue.
             * @memberof immudb.schema
             * @interface ISQLValue
             * @property {google.protobuf.NullValue|null} ["null"] SQLValue null
             * @property {Long|null} [n] SQLValue n
             * @property {string|null} [s] SQLValue s
             * @property {boolean|null} [b] SQLValue b
             * @property {Uint8Array|null} [bs] SQLValue bs
             * @property {Long|null} [ts] SQLValue ts
             */

            /**
             * Constructs a new SQLValue.
             * @memberof immudb.schema
             * @classdesc Represents a SQLValue.
             * @implements ISQLValue
             * @constructor
             * @param {immudb.schema.ISQLValue=} [properties] Properties to set
             */
            function SQLValue(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SQLValue null.
             * @member {google.protobuf.NullValue|null|undefined} null
             * @memberof immudb.schema.SQLValue
             * @instance
             */
            SQLValue.prototype["null"] = null;

            /**
             * SQLValue n.
             * @member {Long|null|undefined} n
             * @memberof immudb.schema.SQLValue
             * @instance
             */
            SQLValue.prototype.n = null;

            /**
             * SQLValue s.
             * @member {string|null|undefined} s
             * @memberof immudb.schema.SQLValue
             * @instance
             */
            SQLValue.prototype.s = null;

            /**
             * SQLValue b.
             * @member {boolean|null|undefined} b
             * @memberof immudb.schema.SQLValue
             * @instance
             */
            SQLValue.prototype.b = null;

            /**
             * SQLValue bs.
             * @member {Uint8Array|null|undefined} bs
             * @memberof immudb.schema.SQLValue
             * @instance
             */
            SQLValue.prototype.bs = null;

            /**
             * SQLValue ts.
             * @member {Long|null|undefined} ts
             * @memberof immudb.schema.SQLValue
             * @instance
             */
            SQLValue.prototype.ts = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * SQLValue value.
             * @member {"null"|"n"|"s"|"b"|"bs"|"ts"|undefined} value
             * @memberof immudb.schema.SQLValue
             * @instance
             */
            Object.defineProperty(SQLValue.prototype, "value", {
                get: $util.oneOfGetter($oneOfFields = ["null", "n", "s", "b", "bs", "ts"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SQLValue instance using the specified properties.
             * @function create
             * @memberof immudb.schema.SQLValue
             * @static
             * @param {immudb.schema.ISQLValue=} [properties] Properties to set
             * @returns {immudb.schema.SQLValue} SQLValue instance
             */
            SQLValue.create = function create(properties) {
                return new SQLValue(properties);
            };

            /**
             * Encodes the specified SQLValue message. Does not implicitly {@link immudb.schema.SQLValue.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.SQLValue
             * @static
             * @param {immudb.schema.ISQLValue} message SQLValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SQLValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message["null"] != null && Object.hasOwnProperty.call(message, "null"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message["null"]);
                if (message.n != null && Object.hasOwnProperty.call(message, "n"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.n);
                if (message.s != null && Object.hasOwnProperty.call(message, "s"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.s);
                if (message.b != null && Object.hasOwnProperty.call(message, "b"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.b);
                if (message.bs != null && Object.hasOwnProperty.call(message, "bs"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.bs);
                if (message.ts != null && Object.hasOwnProperty.call(message, "ts"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.ts);
                return writer;
            };

            /**
             * Encodes the specified SQLValue message, length delimited. Does not implicitly {@link immudb.schema.SQLValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.SQLValue
             * @static
             * @param {immudb.schema.ISQLValue} message SQLValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SQLValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SQLValue message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.SQLValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.SQLValue} SQLValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SQLValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.SQLValue();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message["null"] = reader.int32();
                            break;
                        }
                    case 2: {
                            message.n = reader.int64();
                            break;
                        }
                    case 3: {
                            message.s = reader.string();
                            break;
                        }
                    case 4: {
                            message.b = reader.bool();
                            break;
                        }
                    case 5: {
                            message.bs = reader.bytes();
                            break;
                        }
                    case 6: {
                            message.ts = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SQLValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.SQLValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.SQLValue} SQLValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SQLValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SQLValue message.
             * @function verify
             * @memberof immudb.schema.SQLValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SQLValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message["null"] != null && message.hasOwnProperty("null")) {
                    properties.value = 1;
                    switch (message["null"]) {
                    default:
                        return "null: enum value expected";
                    case 0:
                        break;
                    }
                }
                if (message.n != null && message.hasOwnProperty("n")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    if (!$util.isInteger(message.n) && !(message.n && $util.isInteger(message.n.low) && $util.isInteger(message.n.high)))
                        return "n: integer|Long expected";
                }
                if (message.s != null && message.hasOwnProperty("s")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    if (!$util.isString(message.s))
                        return "s: string expected";
                }
                if (message.b != null && message.hasOwnProperty("b")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    if (typeof message.b !== "boolean")
                        return "b: boolean expected";
                }
                if (message.bs != null && message.hasOwnProperty("bs")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    if (!(message.bs && typeof message.bs.length === "number" || $util.isString(message.bs)))
                        return "bs: buffer expected";
                }
                if (message.ts != null && message.hasOwnProperty("ts")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    if (!$util.isInteger(message.ts) && !(message.ts && $util.isInteger(message.ts.low) && $util.isInteger(message.ts.high)))
                        return "ts: integer|Long expected";
                }
                return null;
            };

            /**
             * Creates a SQLValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.SQLValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.SQLValue} SQLValue
             */
            SQLValue.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.SQLValue)
                    return object;
                let message = new $root.immudb.schema.SQLValue();
                switch (object["null"]) {
                default:
                    if (typeof object["null"] === "number") {
                        message["null"] = object["null"];
                        break;
                    }
                    break;
                case "NULL_VALUE":
                case 0:
                    message["null"] = 0;
                    break;
                }
                if (object.n != null)
                    if ($util.Long)
                        (message.n = $util.Long.fromValue(object.n)).unsigned = false;
                    else if (typeof object.n === "string")
                        message.n = parseInt(object.n, 10);
                    else if (typeof object.n === "number")
                        message.n = object.n;
                    else if (typeof object.n === "object")
                        message.n = new $util.LongBits(object.n.low >>> 0, object.n.high >>> 0).toNumber();
                if (object.s != null)
                    message.s = String(object.s);
                if (object.b != null)
                    message.b = Boolean(object.b);
                if (object.bs != null)
                    if (typeof object.bs === "string")
                        $util.base64.decode(object.bs, message.bs = $util.newBuffer($util.base64.length(object.bs)), 0);
                    else if (object.bs.length >= 0)
                        message.bs = object.bs;
                if (object.ts != null)
                    if ($util.Long)
                        (message.ts = $util.Long.fromValue(object.ts)).unsigned = false;
                    else if (typeof object.ts === "string")
                        message.ts = parseInt(object.ts, 10);
                    else if (typeof object.ts === "number")
                        message.ts = object.ts;
                    else if (typeof object.ts === "object")
                        message.ts = new $util.LongBits(object.ts.low >>> 0, object.ts.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a SQLValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.SQLValue
             * @static
             * @param {immudb.schema.SQLValue} message SQLValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SQLValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message["null"] != null && message.hasOwnProperty("null")) {
                    object["null"] = options.enums === String ? $root.google.protobuf.NullValue[message["null"]] === undefined ? message["null"] : $root.google.protobuf.NullValue[message["null"]] : message["null"];
                    if (options.oneofs)
                        object.value = "null";
                }
                if (message.n != null && message.hasOwnProperty("n")) {
                    if (typeof message.n === "number")
                        object.n = options.longs === String ? String(message.n) : message.n;
                    else
                        object.n = options.longs === String ? $util.Long.prototype.toString.call(message.n) : options.longs === Number ? new $util.LongBits(message.n.low >>> 0, message.n.high >>> 0).toNumber() : message.n;
                    if (options.oneofs)
                        object.value = "n";
                }
                if (message.s != null && message.hasOwnProperty("s")) {
                    object.s = message.s;
                    if (options.oneofs)
                        object.value = "s";
                }
                if (message.b != null && message.hasOwnProperty("b")) {
                    object.b = message.b;
                    if (options.oneofs)
                        object.value = "b";
                }
                if (message.bs != null && message.hasOwnProperty("bs")) {
                    object.bs = options.bytes === String ? $util.base64.encode(message.bs, 0, message.bs.length) : options.bytes === Array ? Array.prototype.slice.call(message.bs) : message.bs;
                    if (options.oneofs)
                        object.value = "bs";
                }
                if (message.ts != null && message.hasOwnProperty("ts")) {
                    if (typeof message.ts === "number")
                        object.ts = options.longs === String ? String(message.ts) : message.ts;
                    else
                        object.ts = options.longs === String ? $util.Long.prototype.toString.call(message.ts) : options.longs === Number ? new $util.LongBits(message.ts.low >>> 0, message.ts.high >>> 0).toNumber() : message.ts;
                    if (options.oneofs)
                        object.value = "ts";
                }
                return object;
            };

            /**
             * Converts this SQLValue to JSON.
             * @function toJSON
             * @memberof immudb.schema.SQLValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SQLValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SQLValue
             * @function getTypeUrl
             * @memberof immudb.schema.SQLValue
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SQLValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.SQLValue";
            };

            return SQLValue;
        })();

        /**
         * TxMode enum.
         * @name immudb.schema.TxMode
         * @enum {number}
         * @property {number} ReadOnly=0 ReadOnly value
         * @property {number} WriteOnly=1 WriteOnly value
         * @property {number} ReadWrite=2 ReadWrite value
         */
        schema.TxMode = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ReadOnly"] = 0;
            values[valuesById[1] = "WriteOnly"] = 1;
            values[valuesById[2] = "ReadWrite"] = 2;
            return values;
        })();

        schema.NewTxRequest = (function() {

            /**
             * Properties of a NewTxRequest.
             * @memberof immudb.schema
             * @interface INewTxRequest
             * @property {immudb.schema.TxMode|null} [mode] NewTxRequest mode
             */

            /**
             * Constructs a new NewTxRequest.
             * @memberof immudb.schema
             * @classdesc Represents a NewTxRequest.
             * @implements INewTxRequest
             * @constructor
             * @param {immudb.schema.INewTxRequest=} [properties] Properties to set
             */
            function NewTxRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NewTxRequest mode.
             * @member {immudb.schema.TxMode} mode
             * @memberof immudb.schema.NewTxRequest
             * @instance
             */
            NewTxRequest.prototype.mode = 0;

            /**
             * Creates a new NewTxRequest instance using the specified properties.
             * @function create
             * @memberof immudb.schema.NewTxRequest
             * @static
             * @param {immudb.schema.INewTxRequest=} [properties] Properties to set
             * @returns {immudb.schema.NewTxRequest} NewTxRequest instance
             */
            NewTxRequest.create = function create(properties) {
                return new NewTxRequest(properties);
            };

            /**
             * Encodes the specified NewTxRequest message. Does not implicitly {@link immudb.schema.NewTxRequest.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.NewTxRequest
             * @static
             * @param {immudb.schema.INewTxRequest} message NewTxRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NewTxRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mode);
                return writer;
            };

            /**
             * Encodes the specified NewTxRequest message, length delimited. Does not implicitly {@link immudb.schema.NewTxRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.NewTxRequest
             * @static
             * @param {immudb.schema.INewTxRequest} message NewTxRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NewTxRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NewTxRequest message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.NewTxRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.NewTxRequest} NewTxRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NewTxRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.NewTxRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.mode = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NewTxRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.NewTxRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.NewTxRequest} NewTxRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NewTxRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NewTxRequest message.
             * @function verify
             * @memberof immudb.schema.NewTxRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NewTxRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.mode != null && message.hasOwnProperty("mode"))
                    switch (message.mode) {
                    default:
                        return "mode: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates a NewTxRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.NewTxRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.NewTxRequest} NewTxRequest
             */
            NewTxRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.NewTxRequest)
                    return object;
                let message = new $root.immudb.schema.NewTxRequest();
                switch (object.mode) {
                default:
                    if (typeof object.mode === "number") {
                        message.mode = object.mode;
                        break;
                    }
                    break;
                case "ReadOnly":
                case 0:
                    message.mode = 0;
                    break;
                case "WriteOnly":
                case 1:
                    message.mode = 1;
                    break;
                case "ReadWrite":
                case 2:
                    message.mode = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a NewTxRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.NewTxRequest
             * @static
             * @param {immudb.schema.NewTxRequest} message NewTxRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NewTxRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.mode = options.enums === String ? "ReadOnly" : 0;
                if (message.mode != null && message.hasOwnProperty("mode"))
                    object.mode = options.enums === String ? $root.immudb.schema.TxMode[message.mode] === undefined ? message.mode : $root.immudb.schema.TxMode[message.mode] : message.mode;
                return object;
            };

            /**
             * Converts this NewTxRequest to JSON.
             * @function toJSON
             * @memberof immudb.schema.NewTxRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NewTxRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for NewTxRequest
             * @function getTypeUrl
             * @memberof immudb.schema.NewTxRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            NewTxRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.NewTxRequest";
            };

            return NewTxRequest;
        })();

        schema.NewTxResponse = (function() {

            /**
             * Properties of a NewTxResponse.
             * @memberof immudb.schema
             * @interface INewTxResponse
             * @property {string|null} [transactionID] NewTxResponse transactionID
             */

            /**
             * Constructs a new NewTxResponse.
             * @memberof immudb.schema
             * @classdesc Represents a NewTxResponse.
             * @implements INewTxResponse
             * @constructor
             * @param {immudb.schema.INewTxResponse=} [properties] Properties to set
             */
            function NewTxResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NewTxResponse transactionID.
             * @member {string} transactionID
             * @memberof immudb.schema.NewTxResponse
             * @instance
             */
            NewTxResponse.prototype.transactionID = "";

            /**
             * Creates a new NewTxResponse instance using the specified properties.
             * @function create
             * @memberof immudb.schema.NewTxResponse
             * @static
             * @param {immudb.schema.INewTxResponse=} [properties] Properties to set
             * @returns {immudb.schema.NewTxResponse} NewTxResponse instance
             */
            NewTxResponse.create = function create(properties) {
                return new NewTxResponse(properties);
            };

            /**
             * Encodes the specified NewTxResponse message. Does not implicitly {@link immudb.schema.NewTxResponse.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.NewTxResponse
             * @static
             * @param {immudb.schema.INewTxResponse} message NewTxResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NewTxResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.transactionID != null && Object.hasOwnProperty.call(message, "transactionID"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.transactionID);
                return writer;
            };

            /**
             * Encodes the specified NewTxResponse message, length delimited. Does not implicitly {@link immudb.schema.NewTxResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.NewTxResponse
             * @static
             * @param {immudb.schema.INewTxResponse} message NewTxResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NewTxResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NewTxResponse message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.NewTxResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.NewTxResponse} NewTxResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NewTxResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.NewTxResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.transactionID = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NewTxResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.NewTxResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.NewTxResponse} NewTxResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NewTxResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NewTxResponse message.
             * @function verify
             * @memberof immudb.schema.NewTxResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NewTxResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.transactionID != null && message.hasOwnProperty("transactionID"))
                    if (!$util.isString(message.transactionID))
                        return "transactionID: string expected";
                return null;
            };

            /**
             * Creates a NewTxResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.NewTxResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.NewTxResponse} NewTxResponse
             */
            NewTxResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.NewTxResponse)
                    return object;
                let message = new $root.immudb.schema.NewTxResponse();
                if (object.transactionID != null)
                    message.transactionID = String(object.transactionID);
                return message;
            };

            /**
             * Creates a plain object from a NewTxResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.NewTxResponse
             * @static
             * @param {immudb.schema.NewTxResponse} message NewTxResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NewTxResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.transactionID = "";
                if (message.transactionID != null && message.hasOwnProperty("transactionID"))
                    object.transactionID = message.transactionID;
                return object;
            };

            /**
             * Converts this NewTxResponse to JSON.
             * @function toJSON
             * @memberof immudb.schema.NewTxResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NewTxResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for NewTxResponse
             * @function getTypeUrl
             * @memberof immudb.schema.NewTxResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            NewTxResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.NewTxResponse";
            };

            return NewTxResponse;
        })();

        schema.ErrorInfo = (function() {

            /**
             * Properties of an ErrorInfo.
             * @memberof immudb.schema
             * @interface IErrorInfo
             * @property {string|null} [code] ErrorInfo code
             * @property {string|null} [cause] ErrorInfo cause
             */

            /**
             * Constructs a new ErrorInfo.
             * @memberof immudb.schema
             * @classdesc Represents an ErrorInfo.
             * @implements IErrorInfo
             * @constructor
             * @param {immudb.schema.IErrorInfo=} [properties] Properties to set
             */
            function ErrorInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ErrorInfo code.
             * @member {string} code
             * @memberof immudb.schema.ErrorInfo
             * @instance
             */
            ErrorInfo.prototype.code = "";

            /**
             * ErrorInfo cause.
             * @member {string} cause
             * @memberof immudb.schema.ErrorInfo
             * @instance
             */
            ErrorInfo.prototype.cause = "";

            /**
             * Creates a new ErrorInfo instance using the specified properties.
             * @function create
             * @memberof immudb.schema.ErrorInfo
             * @static
             * @param {immudb.schema.IErrorInfo=} [properties] Properties to set
             * @returns {immudb.schema.ErrorInfo} ErrorInfo instance
             */
            ErrorInfo.create = function create(properties) {
                return new ErrorInfo(properties);
            };

            /**
             * Encodes the specified ErrorInfo message. Does not implicitly {@link immudb.schema.ErrorInfo.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.ErrorInfo
             * @static
             * @param {immudb.schema.IErrorInfo} message ErrorInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ErrorInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.code);
                if (message.cause != null && Object.hasOwnProperty.call(message, "cause"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.cause);
                return writer;
            };

            /**
             * Encodes the specified ErrorInfo message, length delimited. Does not implicitly {@link immudb.schema.ErrorInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.ErrorInfo
             * @static
             * @param {immudb.schema.IErrorInfo} message ErrorInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ErrorInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ErrorInfo message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.ErrorInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.ErrorInfo} ErrorInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ErrorInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.ErrorInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.code = reader.string();
                            break;
                        }
                    case 2: {
                            message.cause = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ErrorInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.ErrorInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.ErrorInfo} ErrorInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ErrorInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ErrorInfo message.
             * @function verify
             * @memberof immudb.schema.ErrorInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ErrorInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.code != null && message.hasOwnProperty("code"))
                    if (!$util.isString(message.code))
                        return "code: string expected";
                if (message.cause != null && message.hasOwnProperty("cause"))
                    if (!$util.isString(message.cause))
                        return "cause: string expected";
                return null;
            };

            /**
             * Creates an ErrorInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.ErrorInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.ErrorInfo} ErrorInfo
             */
            ErrorInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.ErrorInfo)
                    return object;
                let message = new $root.immudb.schema.ErrorInfo();
                if (object.code != null)
                    message.code = String(object.code);
                if (object.cause != null)
                    message.cause = String(object.cause);
                return message;
            };

            /**
             * Creates a plain object from an ErrorInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.ErrorInfo
             * @static
             * @param {immudb.schema.ErrorInfo} message ErrorInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ErrorInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.code = "";
                    object.cause = "";
                }
                if (message.code != null && message.hasOwnProperty("code"))
                    object.code = message.code;
                if (message.cause != null && message.hasOwnProperty("cause"))
                    object.cause = message.cause;
                return object;
            };

            /**
             * Converts this ErrorInfo to JSON.
             * @function toJSON
             * @memberof immudb.schema.ErrorInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ErrorInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ErrorInfo
             * @function getTypeUrl
             * @memberof immudb.schema.ErrorInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ErrorInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.ErrorInfo";
            };

            return ErrorInfo;
        })();

        schema.DebugInfo = (function() {

            /**
             * Properties of a DebugInfo.
             * @memberof immudb.schema
             * @interface IDebugInfo
             * @property {string|null} [stack] DebugInfo stack
             */

            /**
             * Constructs a new DebugInfo.
             * @memberof immudb.schema
             * @classdesc Represents a DebugInfo.
             * @implements IDebugInfo
             * @constructor
             * @param {immudb.schema.IDebugInfo=} [properties] Properties to set
             */
            function DebugInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DebugInfo stack.
             * @member {string} stack
             * @memberof immudb.schema.DebugInfo
             * @instance
             */
            DebugInfo.prototype.stack = "";

            /**
             * Creates a new DebugInfo instance using the specified properties.
             * @function create
             * @memberof immudb.schema.DebugInfo
             * @static
             * @param {immudb.schema.IDebugInfo=} [properties] Properties to set
             * @returns {immudb.schema.DebugInfo} DebugInfo instance
             */
            DebugInfo.create = function create(properties) {
                return new DebugInfo(properties);
            };

            /**
             * Encodes the specified DebugInfo message. Does not implicitly {@link immudb.schema.DebugInfo.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.DebugInfo
             * @static
             * @param {immudb.schema.IDebugInfo} message DebugInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebugInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stack != null && Object.hasOwnProperty.call(message, "stack"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.stack);
                return writer;
            };

            /**
             * Encodes the specified DebugInfo message, length delimited. Does not implicitly {@link immudb.schema.DebugInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.DebugInfo
             * @static
             * @param {immudb.schema.IDebugInfo} message DebugInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DebugInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DebugInfo message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.DebugInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.DebugInfo} DebugInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebugInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.DebugInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.stack = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DebugInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.DebugInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.DebugInfo} DebugInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DebugInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DebugInfo message.
             * @function verify
             * @memberof immudb.schema.DebugInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DebugInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.stack != null && message.hasOwnProperty("stack"))
                    if (!$util.isString(message.stack))
                        return "stack: string expected";
                return null;
            };

            /**
             * Creates a DebugInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.DebugInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.DebugInfo} DebugInfo
             */
            DebugInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.DebugInfo)
                    return object;
                let message = new $root.immudb.schema.DebugInfo();
                if (object.stack != null)
                    message.stack = String(object.stack);
                return message;
            };

            /**
             * Creates a plain object from a DebugInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.DebugInfo
             * @static
             * @param {immudb.schema.DebugInfo} message DebugInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DebugInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.stack = "";
                if (message.stack != null && message.hasOwnProperty("stack"))
                    object.stack = message.stack;
                return object;
            };

            /**
             * Converts this DebugInfo to JSON.
             * @function toJSON
             * @memberof immudb.schema.DebugInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DebugInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DebugInfo
             * @function getTypeUrl
             * @memberof immudb.schema.DebugInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DebugInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.DebugInfo";
            };

            return DebugInfo;
        })();

        schema.RetryInfo = (function() {

            /**
             * Properties of a RetryInfo.
             * @memberof immudb.schema
             * @interface IRetryInfo
             * @property {number|null} [retryDelay] RetryInfo retryDelay
             */

            /**
             * Constructs a new RetryInfo.
             * @memberof immudb.schema
             * @classdesc Represents a RetryInfo.
             * @implements IRetryInfo
             * @constructor
             * @param {immudb.schema.IRetryInfo=} [properties] Properties to set
             */
            function RetryInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RetryInfo retryDelay.
             * @member {number} retryDelay
             * @memberof immudb.schema.RetryInfo
             * @instance
             */
            RetryInfo.prototype.retryDelay = 0;

            /**
             * Creates a new RetryInfo instance using the specified properties.
             * @function create
             * @memberof immudb.schema.RetryInfo
             * @static
             * @param {immudb.schema.IRetryInfo=} [properties] Properties to set
             * @returns {immudb.schema.RetryInfo} RetryInfo instance
             */
            RetryInfo.create = function create(properties) {
                return new RetryInfo(properties);
            };

            /**
             * Encodes the specified RetryInfo message. Does not implicitly {@link immudb.schema.RetryInfo.verify|verify} messages.
             * @function encode
             * @memberof immudb.schema.RetryInfo
             * @static
             * @param {immudb.schema.IRetryInfo} message RetryInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RetryInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.retryDelay != null && Object.hasOwnProperty.call(message, "retryDelay"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retryDelay);
                return writer;
            };

            /**
             * Encodes the specified RetryInfo message, length delimited. Does not implicitly {@link immudb.schema.RetryInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof immudb.schema.RetryInfo
             * @static
             * @param {immudb.schema.IRetryInfo} message RetryInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RetryInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RetryInfo message from the specified reader or buffer.
             * @function decode
             * @memberof immudb.schema.RetryInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {immudb.schema.RetryInfo} RetryInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RetryInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.immudb.schema.RetryInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.retryDelay = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RetryInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof immudb.schema.RetryInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {immudb.schema.RetryInfo} RetryInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RetryInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RetryInfo message.
             * @function verify
             * @memberof immudb.schema.RetryInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RetryInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.retryDelay != null && message.hasOwnProperty("retryDelay"))
                    if (!$util.isInteger(message.retryDelay))
                        return "retryDelay: integer expected";
                return null;
            };

            /**
             * Creates a RetryInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof immudb.schema.RetryInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {immudb.schema.RetryInfo} RetryInfo
             */
            RetryInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.immudb.schema.RetryInfo)
                    return object;
                let message = new $root.immudb.schema.RetryInfo();
                if (object.retryDelay != null)
                    message.retryDelay = object.retryDelay | 0;
                return message;
            };

            /**
             * Creates a plain object from a RetryInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof immudb.schema.RetryInfo
             * @static
             * @param {immudb.schema.RetryInfo} message RetryInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RetryInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.retryDelay = 0;
                if (message.retryDelay != null && message.hasOwnProperty("retryDelay"))
                    object.retryDelay = message.retryDelay;
                return object;
            };

            /**
             * Converts this RetryInfo to JSON.
             * @function toJSON
             * @memberof immudb.schema.RetryInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RetryInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RetryInfo
             * @function getTypeUrl
             * @memberof immudb.schema.RetryInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RetryInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/immudb.schema.RetryInfo";
            };

            return RetryInfo;
        })();

        schema.ImmuService = (function() {

            /**
             * Constructs a new ImmuService service.
             * @memberof immudb.schema
             * @classdesc Represents an ImmuService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function ImmuService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (ImmuService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ImmuService;

            /**
             * Creates new ImmuService service using the specified rpc implementation.
             * @function create
             * @memberof immudb.schema.ImmuService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {ImmuService} RPC service. Useful where requests and/or responses are streamed.
             */
            ImmuService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link immudb.schema.ImmuService#listUsers}.
             * @memberof immudb.schema.ImmuService
             * @typedef ListUsersCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.UserList} [response] UserList
             */

            /**
             * Calls ListUsers.
             * @function listUsers
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {immudb.schema.ImmuService.ListUsersCallback} callback Node-style callback called with the error, if any, and UserList
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.listUsers = function listUsers(request, callback) {
                return this.rpcCall(listUsers, $root.google.protobuf.Empty, $root.immudb.schema.UserList, request, callback);
            }, "name", { value: "ListUsers" });

            /**
             * Calls ListUsers.
             * @function listUsers
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<immudb.schema.UserList>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#createUser}.
             * @memberof immudb.schema.ImmuService
             * @typedef CreateUserCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls CreateUser.
             * @function createUser
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.ICreateUserRequest} request CreateUserRequest message or plain object
             * @param {immudb.schema.ImmuService.CreateUserCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.createUser = function createUser(request, callback) {
                return this.rpcCall(createUser, $root.immudb.schema.CreateUserRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "CreateUser" });

            /**
             * Calls CreateUser.
             * @function createUser
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.ICreateUserRequest} request CreateUserRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#changePassword}.
             * @memberof immudb.schema.ImmuService
             * @typedef ChangePasswordCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls ChangePassword.
             * @function changePassword
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IChangePasswordRequest} request ChangePasswordRequest message or plain object
             * @param {immudb.schema.ImmuService.ChangePasswordCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.changePassword = function changePassword(request, callback) {
                return this.rpcCall(changePassword, $root.immudb.schema.ChangePasswordRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "ChangePassword" });

            /**
             * Calls ChangePassword.
             * @function changePassword
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IChangePasswordRequest} request ChangePasswordRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#changePermission}.
             * @memberof immudb.schema.ImmuService
             * @typedef ChangePermissionCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls ChangePermission.
             * @function changePermission
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IChangePermissionRequest} request ChangePermissionRequest message or plain object
             * @param {immudb.schema.ImmuService.ChangePermissionCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.changePermission = function changePermission(request, callback) {
                return this.rpcCall(changePermission, $root.immudb.schema.ChangePermissionRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "ChangePermission" });

            /**
             * Calls ChangePermission.
             * @function changePermission
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IChangePermissionRequest} request ChangePermissionRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#setActiveUser}.
             * @memberof immudb.schema.ImmuService
             * @typedef SetActiveUserCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetActiveUser.
             * @function setActiveUser
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.ISetActiveUserRequest} request SetActiveUserRequest message or plain object
             * @param {immudb.schema.ImmuService.SetActiveUserCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.setActiveUser = function setActiveUser(request, callback) {
                return this.rpcCall(setActiveUser, $root.immudb.schema.SetActiveUserRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetActiveUser" });

            /**
             * Calls SetActiveUser.
             * @function setActiveUser
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.ISetActiveUserRequest} request SetActiveUserRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#updateAuthConfig}.
             * @memberof immudb.schema.ImmuService
             * @typedef UpdateAuthConfigCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls UpdateAuthConfig.
             * @function updateAuthConfig
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IAuthConfig} request AuthConfig message or plain object
             * @param {immudb.schema.ImmuService.UpdateAuthConfigCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.updateAuthConfig = function updateAuthConfig(request, callback) {
                return this.rpcCall(updateAuthConfig, $root.immudb.schema.AuthConfig, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "UpdateAuthConfig" });

            /**
             * Calls UpdateAuthConfig.
             * @function updateAuthConfig
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IAuthConfig} request AuthConfig message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#updateMTLSConfig}.
             * @memberof immudb.schema.ImmuService
             * @typedef UpdateMTLSConfigCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls UpdateMTLSConfig.
             * @function updateMTLSConfig
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IMTLSConfig} request MTLSConfig message or plain object
             * @param {immudb.schema.ImmuService.UpdateMTLSConfigCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.updateMTLSConfig = function updateMTLSConfig(request, callback) {
                return this.rpcCall(updateMTLSConfig, $root.immudb.schema.MTLSConfig, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "UpdateMTLSConfig" });

            /**
             * Calls UpdateMTLSConfig.
             * @function updateMTLSConfig
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IMTLSConfig} request MTLSConfig message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#openSession}.
             * @memberof immudb.schema.ImmuService
             * @typedef OpenSessionCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.OpenSessionResponse} [response] OpenSessionResponse
             */

            /**
             * Calls OpenSession.
             * @function openSession
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IOpenSessionRequest} request OpenSessionRequest message or plain object
             * @param {immudb.schema.ImmuService.OpenSessionCallback} callback Node-style callback called with the error, if any, and OpenSessionResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.openSession = function openSession(request, callback) {
                return this.rpcCall(openSession, $root.immudb.schema.OpenSessionRequest, $root.immudb.schema.OpenSessionResponse, request, callback);
            }, "name", { value: "OpenSession" });

            /**
             * Calls OpenSession.
             * @function openSession
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IOpenSessionRequest} request OpenSessionRequest message or plain object
             * @returns {Promise<immudb.schema.OpenSessionResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#closeSession}.
             * @memberof immudb.schema.ImmuService
             * @typedef CloseSessionCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls CloseSession.
             * @function closeSession
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {immudb.schema.ImmuService.CloseSessionCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.closeSession = function closeSession(request, callback) {
                return this.rpcCall(closeSession, $root.google.protobuf.Empty, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "CloseSession" });

            /**
             * Calls CloseSession.
             * @function closeSession
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#keepAlive}.
             * @memberof immudb.schema.ImmuService
             * @typedef KeepAliveCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls KeepAlive.
             * @function keepAlive
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {immudb.schema.ImmuService.KeepAliveCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.keepAlive = function keepAlive(request, callback) {
                return this.rpcCall(keepAlive, $root.google.protobuf.Empty, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "KeepAlive" });

            /**
             * Calls KeepAlive.
             * @function keepAlive
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#newTx}.
             * @memberof immudb.schema.ImmuService
             * @typedef NewTxCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.NewTxResponse} [response] NewTxResponse
             */

            /**
             * Calls NewTx.
             * @function newTx
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.INewTxRequest} request NewTxRequest message or plain object
             * @param {immudb.schema.ImmuService.NewTxCallback} callback Node-style callback called with the error, if any, and NewTxResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.newTx = function newTx(request, callback) {
                return this.rpcCall(newTx, $root.immudb.schema.NewTxRequest, $root.immudb.schema.NewTxResponse, request, callback);
            }, "name", { value: "NewTx" });

            /**
             * Calls NewTx.
             * @function newTx
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.INewTxRequest} request NewTxRequest message or plain object
             * @returns {Promise<immudb.schema.NewTxResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#commit}.
             * @memberof immudb.schema.ImmuService
             * @typedef CommitCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.CommittedSQLTx} [response] CommittedSQLTx
             */

            /**
             * Calls Commit.
             * @function commit
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {immudb.schema.ImmuService.CommitCallback} callback Node-style callback called with the error, if any, and CommittedSQLTx
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.commit = function commit(request, callback) {
                return this.rpcCall(commit, $root.google.protobuf.Empty, $root.immudb.schema.CommittedSQLTx, request, callback);
            }, "name", { value: "Commit" });

            /**
             * Calls Commit.
             * @function commit
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<immudb.schema.CommittedSQLTx>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#rollback}.
             * @memberof immudb.schema.ImmuService
             * @typedef RollbackCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls Rollback.
             * @function rollback
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {immudb.schema.ImmuService.RollbackCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.rollback = function rollback(request, callback) {
                return this.rpcCall(rollback, $root.google.protobuf.Empty, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "Rollback" });

            /**
             * Calls Rollback.
             * @function rollback
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#txSQLExec}.
             * @memberof immudb.schema.ImmuService
             * @typedef TxSQLExecCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls TxSQLExec.
             * @function txSQLExec
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.ISQLExecRequest} request SQLExecRequest message or plain object
             * @param {immudb.schema.ImmuService.TxSQLExecCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.txSQLExec = function txSQLExec(request, callback) {
                return this.rpcCall(txSQLExec, $root.immudb.schema.SQLExecRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "TxSQLExec" });

            /**
             * Calls TxSQLExec.
             * @function txSQLExec
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.ISQLExecRequest} request SQLExecRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#txSQLQuery}.
             * @memberof immudb.schema.ImmuService
             * @typedef TxSQLQueryCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.SQLQueryResult} [response] SQLQueryResult
             */

            /**
             * Calls TxSQLQuery.
             * @function txSQLQuery
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.ISQLQueryRequest} request SQLQueryRequest message or plain object
             * @param {immudb.schema.ImmuService.TxSQLQueryCallback} callback Node-style callback called with the error, if any, and SQLQueryResult
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.txSQLQuery = function txSQLQuery(request, callback) {
                return this.rpcCall(txSQLQuery, $root.immudb.schema.SQLQueryRequest, $root.immudb.schema.SQLQueryResult, request, callback);
            }, "name", { value: "TxSQLQuery" });

            /**
             * Calls TxSQLQuery.
             * @function txSQLQuery
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.ISQLQueryRequest} request SQLQueryRequest message or plain object
             * @returns {Promise<immudb.schema.SQLQueryResult>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#login}.
             * @memberof immudb.schema.ImmuService
             * @typedef LoginCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.LoginResponse} [response] LoginResponse
             */

            /**
             * Calls Login.
             * @function login
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.ILoginRequest} request LoginRequest message or plain object
             * @param {immudb.schema.ImmuService.LoginCallback} callback Node-style callback called with the error, if any, and LoginResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.login = function login(request, callback) {
                return this.rpcCall(login, $root.immudb.schema.LoginRequest, $root.immudb.schema.LoginResponse, request, callback);
            }, "name", { value: "Login" });

            /**
             * Calls Login.
             * @function login
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.ILoginRequest} request LoginRequest message or plain object
             * @returns {Promise<immudb.schema.LoginResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#logout}.
             * @memberof immudb.schema.ImmuService
             * @typedef LogoutCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls Logout.
             * @function logout
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {immudb.schema.ImmuService.LogoutCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.logout = function logout(request, callback) {
                return this.rpcCall(logout, $root.google.protobuf.Empty, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "Logout" });

            /**
             * Calls Logout.
             * @function logout
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#set}.
             * @memberof immudb.schema.ImmuService
             * @typedef SetCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.TxHeader} [response] TxHeader
             */

            /**
             * Calls Set.
             * @function set
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.ISetRequest} request SetRequest message or plain object
             * @param {immudb.schema.ImmuService.SetCallback} callback Node-style callback called with the error, if any, and TxHeader
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.set = function set(request, callback) {
                return this.rpcCall(set, $root.immudb.schema.SetRequest, $root.immudb.schema.TxHeader, request, callback);
            }, "name", { value: "Set" });

            /**
             * Calls Set.
             * @function set
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.ISetRequest} request SetRequest message or plain object
             * @returns {Promise<immudb.schema.TxHeader>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#verifiableSet}.
             * @memberof immudb.schema.ImmuService
             * @typedef VerifiableSetCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.VerifiableTx} [response] VerifiableTx
             */

            /**
             * Calls VerifiableSet.
             * @function verifiableSet
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IVerifiableSetRequest} request VerifiableSetRequest message or plain object
             * @param {immudb.schema.ImmuService.VerifiableSetCallback} callback Node-style callback called with the error, if any, and VerifiableTx
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.verifiableSet = function verifiableSet(request, callback) {
                return this.rpcCall(verifiableSet, $root.immudb.schema.VerifiableSetRequest, $root.immudb.schema.VerifiableTx, request, callback);
            }, "name", { value: "VerifiableSet" });

            /**
             * Calls VerifiableSet.
             * @function verifiableSet
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IVerifiableSetRequest} request VerifiableSetRequest message or plain object
             * @returns {Promise<immudb.schema.VerifiableTx>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#get}.
             * @memberof immudb.schema.ImmuService
             * @typedef GetCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.Entry} [response] Entry
             */

            /**
             * Calls Get.
             * @function get
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IKeyRequest} request KeyRequest message or plain object
             * @param {immudb.schema.ImmuService.GetCallback} callback Node-style callback called with the error, if any, and Entry
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.get = function get(request, callback) {
                return this.rpcCall(get, $root.immudb.schema.KeyRequest, $root.immudb.schema.Entry, request, callback);
            }, "name", { value: "Get" });

            /**
             * Calls Get.
             * @function get
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IKeyRequest} request KeyRequest message or plain object
             * @returns {Promise<immudb.schema.Entry>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#verifiableGet}.
             * @memberof immudb.schema.ImmuService
             * @typedef VerifiableGetCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.VerifiableEntry} [response] VerifiableEntry
             */

            /**
             * Calls VerifiableGet.
             * @function verifiableGet
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IVerifiableGetRequest} request VerifiableGetRequest message or plain object
             * @param {immudb.schema.ImmuService.VerifiableGetCallback} callback Node-style callback called with the error, if any, and VerifiableEntry
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.verifiableGet = function verifiableGet(request, callback) {
                return this.rpcCall(verifiableGet, $root.immudb.schema.VerifiableGetRequest, $root.immudb.schema.VerifiableEntry, request, callback);
            }, "name", { value: "VerifiableGet" });

            /**
             * Calls VerifiableGet.
             * @function verifiableGet
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IVerifiableGetRequest} request VerifiableGetRequest message or plain object
             * @returns {Promise<immudb.schema.VerifiableEntry>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#delete_}.
             * @memberof immudb.schema.ImmuService
             * @typedef DeleteCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.TxHeader} [response] TxHeader
             */

            /**
             * Calls Delete.
             * @function delete
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IDeleteKeysRequest} request DeleteKeysRequest message or plain object
             * @param {immudb.schema.ImmuService.DeleteCallback} callback Node-style callback called with the error, if any, and TxHeader
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype["delete"] = function delete_(request, callback) {
                return this.rpcCall(delete_, $root.immudb.schema.DeleteKeysRequest, $root.immudb.schema.TxHeader, request, callback);
            }, "name", { value: "Delete" });

            /**
             * Calls Delete.
             * @function delete
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IDeleteKeysRequest} request DeleteKeysRequest message or plain object
             * @returns {Promise<immudb.schema.TxHeader>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#getAll}.
             * @memberof immudb.schema.ImmuService
             * @typedef GetAllCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.Entries} [response] Entries
             */

            /**
             * Calls GetAll.
             * @function getAll
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IKeyListRequest} request KeyListRequest message or plain object
             * @param {immudb.schema.ImmuService.GetAllCallback} callback Node-style callback called with the error, if any, and Entries
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.getAll = function getAll(request, callback) {
                return this.rpcCall(getAll, $root.immudb.schema.KeyListRequest, $root.immudb.schema.Entries, request, callback);
            }, "name", { value: "GetAll" });

            /**
             * Calls GetAll.
             * @function getAll
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IKeyListRequest} request KeyListRequest message or plain object
             * @returns {Promise<immudb.schema.Entries>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#execAll}.
             * @memberof immudb.schema.ImmuService
             * @typedef ExecAllCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.TxHeader} [response] TxHeader
             */

            /**
             * Calls ExecAll.
             * @function execAll
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IExecAllRequest} request ExecAllRequest message or plain object
             * @param {immudb.schema.ImmuService.ExecAllCallback} callback Node-style callback called with the error, if any, and TxHeader
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.execAll = function execAll(request, callback) {
                return this.rpcCall(execAll, $root.immudb.schema.ExecAllRequest, $root.immudb.schema.TxHeader, request, callback);
            }, "name", { value: "ExecAll" });

            /**
             * Calls ExecAll.
             * @function execAll
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IExecAllRequest} request ExecAllRequest message or plain object
             * @returns {Promise<immudb.schema.TxHeader>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#scan}.
             * @memberof immudb.schema.ImmuService
             * @typedef ScanCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.Entries} [response] Entries
             */

            /**
             * Calls Scan.
             * @function scan
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IScanRequest} request ScanRequest message or plain object
             * @param {immudb.schema.ImmuService.ScanCallback} callback Node-style callback called with the error, if any, and Entries
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.scan = function scan(request, callback) {
                return this.rpcCall(scan, $root.immudb.schema.ScanRequest, $root.immudb.schema.Entries, request, callback);
            }, "name", { value: "Scan" });

            /**
             * Calls Scan.
             * @function scan
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IScanRequest} request ScanRequest message or plain object
             * @returns {Promise<immudb.schema.Entries>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#count}.
             * @memberof immudb.schema.ImmuService
             * @typedef CountCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.EntryCount} [response] EntryCount
             */

            /**
             * Calls Count.
             * @function count
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IKeyPrefix} request KeyPrefix message or plain object
             * @param {immudb.schema.ImmuService.CountCallback} callback Node-style callback called with the error, if any, and EntryCount
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.count = function count(request, callback) {
                return this.rpcCall(count, $root.immudb.schema.KeyPrefix, $root.immudb.schema.EntryCount, request, callback);
            }, "name", { value: "Count" });

            /**
             * Calls Count.
             * @function count
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IKeyPrefix} request KeyPrefix message or plain object
             * @returns {Promise<immudb.schema.EntryCount>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#countAll}.
             * @memberof immudb.schema.ImmuService
             * @typedef CountAllCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.EntryCount} [response] EntryCount
             */

            /**
             * Calls CountAll.
             * @function countAll
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {immudb.schema.ImmuService.CountAllCallback} callback Node-style callback called with the error, if any, and EntryCount
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.countAll = function countAll(request, callback) {
                return this.rpcCall(countAll, $root.google.protobuf.Empty, $root.immudb.schema.EntryCount, request, callback);
            }, "name", { value: "CountAll" });

            /**
             * Calls CountAll.
             * @function countAll
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<immudb.schema.EntryCount>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#txById}.
             * @memberof immudb.schema.ImmuService
             * @typedef TxByIdCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.Tx} [response] Tx
             */

            /**
             * Calls TxById.
             * @function txById
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.ITxRequest} request TxRequest message or plain object
             * @param {immudb.schema.ImmuService.TxByIdCallback} callback Node-style callback called with the error, if any, and Tx
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.txById = function txById(request, callback) {
                return this.rpcCall(txById, $root.immudb.schema.TxRequest, $root.immudb.schema.Tx, request, callback);
            }, "name", { value: "TxById" });

            /**
             * Calls TxById.
             * @function txById
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.ITxRequest} request TxRequest message or plain object
             * @returns {Promise<immudb.schema.Tx>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#verifiableTxById}.
             * @memberof immudb.schema.ImmuService
             * @typedef VerifiableTxByIdCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.VerifiableTx} [response] VerifiableTx
             */

            /**
             * Calls VerifiableTxById.
             * @function verifiableTxById
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IVerifiableTxRequest} request VerifiableTxRequest message or plain object
             * @param {immudb.schema.ImmuService.VerifiableTxByIdCallback} callback Node-style callback called with the error, if any, and VerifiableTx
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.verifiableTxById = function verifiableTxById(request, callback) {
                return this.rpcCall(verifiableTxById, $root.immudb.schema.VerifiableTxRequest, $root.immudb.schema.VerifiableTx, request, callback);
            }, "name", { value: "VerifiableTxById" });

            /**
             * Calls VerifiableTxById.
             * @function verifiableTxById
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IVerifiableTxRequest} request VerifiableTxRequest message or plain object
             * @returns {Promise<immudb.schema.VerifiableTx>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#txScan}.
             * @memberof immudb.schema.ImmuService
             * @typedef TxScanCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.TxList} [response] TxList
             */

            /**
             * Calls TxScan.
             * @function txScan
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.ITxScanRequest} request TxScanRequest message or plain object
             * @param {immudb.schema.ImmuService.TxScanCallback} callback Node-style callback called with the error, if any, and TxList
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.txScan = function txScan(request, callback) {
                return this.rpcCall(txScan, $root.immudb.schema.TxScanRequest, $root.immudb.schema.TxList, request, callback);
            }, "name", { value: "TxScan" });

            /**
             * Calls TxScan.
             * @function txScan
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.ITxScanRequest} request TxScanRequest message or plain object
             * @returns {Promise<immudb.schema.TxList>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#history}.
             * @memberof immudb.schema.ImmuService
             * @typedef HistoryCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.Entries} [response] Entries
             */

            /**
             * Calls History.
             * @function history
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IHistoryRequest} request HistoryRequest message or plain object
             * @param {immudb.schema.ImmuService.HistoryCallback} callback Node-style callback called with the error, if any, and Entries
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.history = function history(request, callback) {
                return this.rpcCall(history, $root.immudb.schema.HistoryRequest, $root.immudb.schema.Entries, request, callback);
            }, "name", { value: "History" });

            /**
             * Calls History.
             * @function history
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IHistoryRequest} request HistoryRequest message or plain object
             * @returns {Promise<immudb.schema.Entries>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#health}.
             * @memberof immudb.schema.ImmuService
             * @typedef HealthCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.HealthResponse} [response] HealthResponse
             */

            /**
             * Calls Health.
             * @function health
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {immudb.schema.ImmuService.HealthCallback} callback Node-style callback called with the error, if any, and HealthResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.health = function health(request, callback) {
                return this.rpcCall(health, $root.google.protobuf.Empty, $root.immudb.schema.HealthResponse, request, callback);
            }, "name", { value: "Health" });

            /**
             * Calls Health.
             * @function health
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<immudb.schema.HealthResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#databaseHealth}.
             * @memberof immudb.schema.ImmuService
             * @typedef DatabaseHealthCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.DatabaseHealthResponse} [response] DatabaseHealthResponse
             */

            /**
             * Calls DatabaseHealth.
             * @function databaseHealth
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {immudb.schema.ImmuService.DatabaseHealthCallback} callback Node-style callback called with the error, if any, and DatabaseHealthResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.databaseHealth = function databaseHealth(request, callback) {
                return this.rpcCall(databaseHealth, $root.google.protobuf.Empty, $root.immudb.schema.DatabaseHealthResponse, request, callback);
            }, "name", { value: "DatabaseHealth" });

            /**
             * Calls DatabaseHealth.
             * @function databaseHealth
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<immudb.schema.DatabaseHealthResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#currentState}.
             * @memberof immudb.schema.ImmuService
             * @typedef CurrentStateCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.ImmutableState} [response] ImmutableState
             */

            /**
             * Calls CurrentState.
             * @function currentState
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {immudb.schema.ImmuService.CurrentStateCallback} callback Node-style callback called with the error, if any, and ImmutableState
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.currentState = function currentState(request, callback) {
                return this.rpcCall(currentState, $root.google.protobuf.Empty, $root.immudb.schema.ImmutableState, request, callback);
            }, "name", { value: "CurrentState" });

            /**
             * Calls CurrentState.
             * @function currentState
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<immudb.schema.ImmutableState>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#setReference}.
             * @memberof immudb.schema.ImmuService
             * @typedef SetReferenceCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.TxHeader} [response] TxHeader
             */

            /**
             * Calls SetReference.
             * @function setReference
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IReferenceRequest} request ReferenceRequest message or plain object
             * @param {immudb.schema.ImmuService.SetReferenceCallback} callback Node-style callback called with the error, if any, and TxHeader
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.setReference = function setReference(request, callback) {
                return this.rpcCall(setReference, $root.immudb.schema.ReferenceRequest, $root.immudb.schema.TxHeader, request, callback);
            }, "name", { value: "SetReference" });

            /**
             * Calls SetReference.
             * @function setReference
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IReferenceRequest} request ReferenceRequest message or plain object
             * @returns {Promise<immudb.schema.TxHeader>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#verifiableSetReference}.
             * @memberof immudb.schema.ImmuService
             * @typedef VerifiableSetReferenceCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.VerifiableTx} [response] VerifiableTx
             */

            /**
             * Calls VerifiableSetReference.
             * @function verifiableSetReference
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IVerifiableReferenceRequest} request VerifiableReferenceRequest message or plain object
             * @param {immudb.schema.ImmuService.VerifiableSetReferenceCallback} callback Node-style callback called with the error, if any, and VerifiableTx
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.verifiableSetReference = function verifiableSetReference(request, callback) {
                return this.rpcCall(verifiableSetReference, $root.immudb.schema.VerifiableReferenceRequest, $root.immudb.schema.VerifiableTx, request, callback);
            }, "name", { value: "VerifiableSetReference" });

            /**
             * Calls VerifiableSetReference.
             * @function verifiableSetReference
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IVerifiableReferenceRequest} request VerifiableReferenceRequest message or plain object
             * @returns {Promise<immudb.schema.VerifiableTx>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#zAdd}.
             * @memberof immudb.schema.ImmuService
             * @typedef ZAddCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.TxHeader} [response] TxHeader
             */

            /**
             * Calls ZAdd.
             * @function zAdd
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IZAddRequest} request ZAddRequest message or plain object
             * @param {immudb.schema.ImmuService.ZAddCallback} callback Node-style callback called with the error, if any, and TxHeader
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.zAdd = function zAdd(request, callback) {
                return this.rpcCall(zAdd, $root.immudb.schema.ZAddRequest, $root.immudb.schema.TxHeader, request, callback);
            }, "name", { value: "ZAdd" });

            /**
             * Calls ZAdd.
             * @function zAdd
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IZAddRequest} request ZAddRequest message or plain object
             * @returns {Promise<immudb.schema.TxHeader>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#verifiableZAdd}.
             * @memberof immudb.schema.ImmuService
             * @typedef VerifiableZAddCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.VerifiableTx} [response] VerifiableTx
             */

            /**
             * Calls VerifiableZAdd.
             * @function verifiableZAdd
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IVerifiableZAddRequest} request VerifiableZAddRequest message or plain object
             * @param {immudb.schema.ImmuService.VerifiableZAddCallback} callback Node-style callback called with the error, if any, and VerifiableTx
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.verifiableZAdd = function verifiableZAdd(request, callback) {
                return this.rpcCall(verifiableZAdd, $root.immudb.schema.VerifiableZAddRequest, $root.immudb.schema.VerifiableTx, request, callback);
            }, "name", { value: "VerifiableZAdd" });

            /**
             * Calls VerifiableZAdd.
             * @function verifiableZAdd
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IVerifiableZAddRequest} request VerifiableZAddRequest message or plain object
             * @returns {Promise<immudb.schema.VerifiableTx>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#zScan}.
             * @memberof immudb.schema.ImmuService
             * @typedef ZScanCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.ZEntries} [response] ZEntries
             */

            /**
             * Calls ZScan.
             * @function zScan
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IZScanRequest} request ZScanRequest message or plain object
             * @param {immudb.schema.ImmuService.ZScanCallback} callback Node-style callback called with the error, if any, and ZEntries
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.zScan = function zScan(request, callback) {
                return this.rpcCall(zScan, $root.immudb.schema.ZScanRequest, $root.immudb.schema.ZEntries, request, callback);
            }, "name", { value: "ZScan" });

            /**
             * Calls ZScan.
             * @function zScan
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IZScanRequest} request ZScanRequest message or plain object
             * @returns {Promise<immudb.schema.ZEntries>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#createDatabase}.
             * @memberof immudb.schema.ImmuService
             * @typedef CreateDatabaseCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls CreateDatabase.
             * @function createDatabase
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IDatabase} request Database message or plain object
             * @param {immudb.schema.ImmuService.CreateDatabaseCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.createDatabase = function createDatabase(request, callback) {
                return this.rpcCall(createDatabase, $root.immudb.schema.Database, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "CreateDatabase" });

            /**
             * Calls CreateDatabase.
             * @function createDatabase
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IDatabase} request Database message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#createDatabaseWith}.
             * @memberof immudb.schema.ImmuService
             * @typedef CreateDatabaseWithCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls CreateDatabaseWith.
             * @function createDatabaseWith
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IDatabaseSettings} request DatabaseSettings message or plain object
             * @param {immudb.schema.ImmuService.CreateDatabaseWithCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.createDatabaseWith = function createDatabaseWith(request, callback) {
                return this.rpcCall(createDatabaseWith, $root.immudb.schema.DatabaseSettings, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "CreateDatabaseWith" });

            /**
             * Calls CreateDatabaseWith.
             * @function createDatabaseWith
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IDatabaseSettings} request DatabaseSettings message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#createDatabaseV2}.
             * @memberof immudb.schema.ImmuService
             * @typedef CreateDatabaseV2Callback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.CreateDatabaseResponse} [response] CreateDatabaseResponse
             */

            /**
             * Calls CreateDatabaseV2.
             * @function createDatabaseV2
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.ICreateDatabaseRequest} request CreateDatabaseRequest message or plain object
             * @param {immudb.schema.ImmuService.CreateDatabaseV2Callback} callback Node-style callback called with the error, if any, and CreateDatabaseResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.createDatabaseV2 = function createDatabaseV2(request, callback) {
                return this.rpcCall(createDatabaseV2, $root.immudb.schema.CreateDatabaseRequest, $root.immudb.schema.CreateDatabaseResponse, request, callback);
            }, "name", { value: "CreateDatabaseV2" });

            /**
             * Calls CreateDatabaseV2.
             * @function createDatabaseV2
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.ICreateDatabaseRequest} request CreateDatabaseRequest message or plain object
             * @returns {Promise<immudb.schema.CreateDatabaseResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#loadDatabase}.
             * @memberof immudb.schema.ImmuService
             * @typedef LoadDatabaseCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.LoadDatabaseResponse} [response] LoadDatabaseResponse
             */

            /**
             * Calls LoadDatabase.
             * @function loadDatabase
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.ILoadDatabaseRequest} request LoadDatabaseRequest message or plain object
             * @param {immudb.schema.ImmuService.LoadDatabaseCallback} callback Node-style callback called with the error, if any, and LoadDatabaseResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.loadDatabase = function loadDatabase(request, callback) {
                return this.rpcCall(loadDatabase, $root.immudb.schema.LoadDatabaseRequest, $root.immudb.schema.LoadDatabaseResponse, request, callback);
            }, "name", { value: "LoadDatabase" });

            /**
             * Calls LoadDatabase.
             * @function loadDatabase
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.ILoadDatabaseRequest} request LoadDatabaseRequest message or plain object
             * @returns {Promise<immudb.schema.LoadDatabaseResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#unloadDatabase}.
             * @memberof immudb.schema.ImmuService
             * @typedef UnloadDatabaseCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.UnloadDatabaseResponse} [response] UnloadDatabaseResponse
             */

            /**
             * Calls UnloadDatabase.
             * @function unloadDatabase
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IUnloadDatabaseRequest} request UnloadDatabaseRequest message or plain object
             * @param {immudb.schema.ImmuService.UnloadDatabaseCallback} callback Node-style callback called with the error, if any, and UnloadDatabaseResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.unloadDatabase = function unloadDatabase(request, callback) {
                return this.rpcCall(unloadDatabase, $root.immudb.schema.UnloadDatabaseRequest, $root.immudb.schema.UnloadDatabaseResponse, request, callback);
            }, "name", { value: "UnloadDatabase" });

            /**
             * Calls UnloadDatabase.
             * @function unloadDatabase
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IUnloadDatabaseRequest} request UnloadDatabaseRequest message or plain object
             * @returns {Promise<immudb.schema.UnloadDatabaseResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#deleteDatabase}.
             * @memberof immudb.schema.ImmuService
             * @typedef DeleteDatabaseCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.DeleteDatabaseResponse} [response] DeleteDatabaseResponse
             */

            /**
             * Calls DeleteDatabase.
             * @function deleteDatabase
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IDeleteDatabaseRequest} request DeleteDatabaseRequest message or plain object
             * @param {immudb.schema.ImmuService.DeleteDatabaseCallback} callback Node-style callback called with the error, if any, and DeleteDatabaseResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.deleteDatabase = function deleteDatabase(request, callback) {
                return this.rpcCall(deleteDatabase, $root.immudb.schema.DeleteDatabaseRequest, $root.immudb.schema.DeleteDatabaseResponse, request, callback);
            }, "name", { value: "DeleteDatabase" });

            /**
             * Calls DeleteDatabase.
             * @function deleteDatabase
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IDeleteDatabaseRequest} request DeleteDatabaseRequest message or plain object
             * @returns {Promise<immudb.schema.DeleteDatabaseResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#databaseList}.
             * @memberof immudb.schema.ImmuService
             * @typedef DatabaseListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.DatabaseListResponse} [response] DatabaseListResponse
             */

            /**
             * Calls DatabaseList.
             * @function databaseList
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {immudb.schema.ImmuService.DatabaseListCallback} callback Node-style callback called with the error, if any, and DatabaseListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.databaseList = function databaseList(request, callback) {
                return this.rpcCall(databaseList, $root.google.protobuf.Empty, $root.immudb.schema.DatabaseListResponse, request, callback);
            }, "name", { value: "DatabaseList" });

            /**
             * Calls DatabaseList.
             * @function databaseList
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<immudb.schema.DatabaseListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#databaseListV2}.
             * @memberof immudb.schema.ImmuService
             * @typedef DatabaseListV2Callback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.DatabaseListResponseV2} [response] DatabaseListResponseV2
             */

            /**
             * Calls DatabaseListV2.
             * @function databaseListV2
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IDatabaseListRequestV2} request DatabaseListRequestV2 message or plain object
             * @param {immudb.schema.ImmuService.DatabaseListV2Callback} callback Node-style callback called with the error, if any, and DatabaseListResponseV2
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.databaseListV2 = function databaseListV2(request, callback) {
                return this.rpcCall(databaseListV2, $root.immudb.schema.DatabaseListRequestV2, $root.immudb.schema.DatabaseListResponseV2, request, callback);
            }, "name", { value: "DatabaseListV2" });

            /**
             * Calls DatabaseListV2.
             * @function databaseListV2
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IDatabaseListRequestV2} request DatabaseListRequestV2 message or plain object
             * @returns {Promise<immudb.schema.DatabaseListResponseV2>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#useDatabase}.
             * @memberof immudb.schema.ImmuService
             * @typedef UseDatabaseCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.UseDatabaseReply} [response] UseDatabaseReply
             */

            /**
             * Calls UseDatabase.
             * @function useDatabase
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IDatabase} request Database message or plain object
             * @param {immudb.schema.ImmuService.UseDatabaseCallback} callback Node-style callback called with the error, if any, and UseDatabaseReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.useDatabase = function useDatabase(request, callback) {
                return this.rpcCall(useDatabase, $root.immudb.schema.Database, $root.immudb.schema.UseDatabaseReply, request, callback);
            }, "name", { value: "UseDatabase" });

            /**
             * Calls UseDatabase.
             * @function useDatabase
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IDatabase} request Database message or plain object
             * @returns {Promise<immudb.schema.UseDatabaseReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#updateDatabase}.
             * @memberof immudb.schema.ImmuService
             * @typedef UpdateDatabaseCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls UpdateDatabase.
             * @function updateDatabase
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IDatabaseSettings} request DatabaseSettings message or plain object
             * @param {immudb.schema.ImmuService.UpdateDatabaseCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.updateDatabase = function updateDatabase(request, callback) {
                return this.rpcCall(updateDatabase, $root.immudb.schema.DatabaseSettings, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "UpdateDatabase" });

            /**
             * Calls UpdateDatabase.
             * @function updateDatabase
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IDatabaseSettings} request DatabaseSettings message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#updateDatabaseV2}.
             * @memberof immudb.schema.ImmuService
             * @typedef UpdateDatabaseV2Callback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.UpdateDatabaseResponse} [response] UpdateDatabaseResponse
             */

            /**
             * Calls UpdateDatabaseV2.
             * @function updateDatabaseV2
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IUpdateDatabaseRequest} request UpdateDatabaseRequest message or plain object
             * @param {immudb.schema.ImmuService.UpdateDatabaseV2Callback} callback Node-style callback called with the error, if any, and UpdateDatabaseResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.updateDatabaseV2 = function updateDatabaseV2(request, callback) {
                return this.rpcCall(updateDatabaseV2, $root.immudb.schema.UpdateDatabaseRequest, $root.immudb.schema.UpdateDatabaseResponse, request, callback);
            }, "name", { value: "UpdateDatabaseV2" });

            /**
             * Calls UpdateDatabaseV2.
             * @function updateDatabaseV2
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IUpdateDatabaseRequest} request UpdateDatabaseRequest message or plain object
             * @returns {Promise<immudb.schema.UpdateDatabaseResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#getDatabaseSettings}.
             * @memberof immudb.schema.ImmuService
             * @typedef GetDatabaseSettingsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.DatabaseSettings} [response] DatabaseSettings
             */

            /**
             * Calls GetDatabaseSettings.
             * @function getDatabaseSettings
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {immudb.schema.ImmuService.GetDatabaseSettingsCallback} callback Node-style callback called with the error, if any, and DatabaseSettings
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.getDatabaseSettings = function getDatabaseSettings(request, callback) {
                return this.rpcCall(getDatabaseSettings, $root.google.protobuf.Empty, $root.immudb.schema.DatabaseSettings, request, callback);
            }, "name", { value: "GetDatabaseSettings" });

            /**
             * Calls GetDatabaseSettings.
             * @function getDatabaseSettings
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<immudb.schema.DatabaseSettings>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#getDatabaseSettingsV2}.
             * @memberof immudb.schema.ImmuService
             * @typedef GetDatabaseSettingsV2Callback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.DatabaseSettingsResponse} [response] DatabaseSettingsResponse
             */

            /**
             * Calls GetDatabaseSettingsV2.
             * @function getDatabaseSettingsV2
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IDatabaseSettingsRequest} request DatabaseSettingsRequest message or plain object
             * @param {immudb.schema.ImmuService.GetDatabaseSettingsV2Callback} callback Node-style callback called with the error, if any, and DatabaseSettingsResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.getDatabaseSettingsV2 = function getDatabaseSettingsV2(request, callback) {
                return this.rpcCall(getDatabaseSettingsV2, $root.immudb.schema.DatabaseSettingsRequest, $root.immudb.schema.DatabaseSettingsResponse, request, callback);
            }, "name", { value: "GetDatabaseSettingsV2" });

            /**
             * Calls GetDatabaseSettingsV2.
             * @function getDatabaseSettingsV2
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IDatabaseSettingsRequest} request DatabaseSettingsRequest message or plain object
             * @returns {Promise<immudb.schema.DatabaseSettingsResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#flushIndex}.
             * @memberof immudb.schema.ImmuService
             * @typedef FlushIndexCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.FlushIndexResponse} [response] FlushIndexResponse
             */

            /**
             * Calls FlushIndex.
             * @function flushIndex
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IFlushIndexRequest} request FlushIndexRequest message or plain object
             * @param {immudb.schema.ImmuService.FlushIndexCallback} callback Node-style callback called with the error, if any, and FlushIndexResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.flushIndex = function flushIndex(request, callback) {
                return this.rpcCall(flushIndex, $root.immudb.schema.FlushIndexRequest, $root.immudb.schema.FlushIndexResponse, request, callback);
            }, "name", { value: "FlushIndex" });

            /**
             * Calls FlushIndex.
             * @function flushIndex
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IFlushIndexRequest} request FlushIndexRequest message or plain object
             * @returns {Promise<immudb.schema.FlushIndexResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#compactIndex}.
             * @memberof immudb.schema.ImmuService
             * @typedef CompactIndexCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls CompactIndex.
             * @function compactIndex
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {immudb.schema.ImmuService.CompactIndexCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.compactIndex = function compactIndex(request, callback) {
                return this.rpcCall(compactIndex, $root.google.protobuf.Empty, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "CompactIndex" });

            /**
             * Calls CompactIndex.
             * @function compactIndex
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#streamGet}.
             * @memberof immudb.schema.ImmuService
             * @typedef streamGetCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.Chunk} [response] Chunk
             */

            /**
             * Calls streamGet.
             * @function streamGet
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IKeyRequest} request KeyRequest message or plain object
             * @param {immudb.schema.ImmuService.streamGetCallback} callback Node-style callback called with the error, if any, and Chunk
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.streamGet = function streamGet(request, callback) {
                return this.rpcCall(streamGet, $root.immudb.schema.KeyRequest, $root.immudb.schema.Chunk, request, callback);
            }, "name", { value: "streamGet" });

            /**
             * Calls streamGet.
             * @function streamGet
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IKeyRequest} request KeyRequest message or plain object
             * @returns {Promise<immudb.schema.Chunk>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#streamSet}.
             * @memberof immudb.schema.ImmuService
             * @typedef streamSetCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.TxHeader} [response] TxHeader
             */

            /**
             * Calls streamSet.
             * @function streamSet
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IChunk} request Chunk message or plain object
             * @param {immudb.schema.ImmuService.streamSetCallback} callback Node-style callback called with the error, if any, and TxHeader
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.streamSet = function streamSet(request, callback) {
                return this.rpcCall(streamSet, $root.immudb.schema.Chunk, $root.immudb.schema.TxHeader, request, callback);
            }, "name", { value: "streamSet" });

            /**
             * Calls streamSet.
             * @function streamSet
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IChunk} request Chunk message or plain object
             * @returns {Promise<immudb.schema.TxHeader>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#streamVerifiableGet}.
             * @memberof immudb.schema.ImmuService
             * @typedef streamVerifiableGetCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.Chunk} [response] Chunk
             */

            /**
             * Calls streamVerifiableGet.
             * @function streamVerifiableGet
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IVerifiableGetRequest} request VerifiableGetRequest message or plain object
             * @param {immudb.schema.ImmuService.streamVerifiableGetCallback} callback Node-style callback called with the error, if any, and Chunk
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.streamVerifiableGet = function streamVerifiableGet(request, callback) {
                return this.rpcCall(streamVerifiableGet, $root.immudb.schema.VerifiableGetRequest, $root.immudb.schema.Chunk, request, callback);
            }, "name", { value: "streamVerifiableGet" });

            /**
             * Calls streamVerifiableGet.
             * @function streamVerifiableGet
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IVerifiableGetRequest} request VerifiableGetRequest message or plain object
             * @returns {Promise<immudb.schema.Chunk>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#streamVerifiableSet}.
             * @memberof immudb.schema.ImmuService
             * @typedef streamVerifiableSetCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.VerifiableTx} [response] VerifiableTx
             */

            /**
             * Calls streamVerifiableSet.
             * @function streamVerifiableSet
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IChunk} request Chunk message or plain object
             * @param {immudb.schema.ImmuService.streamVerifiableSetCallback} callback Node-style callback called with the error, if any, and VerifiableTx
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.streamVerifiableSet = function streamVerifiableSet(request, callback) {
                return this.rpcCall(streamVerifiableSet, $root.immudb.schema.Chunk, $root.immudb.schema.VerifiableTx, request, callback);
            }, "name", { value: "streamVerifiableSet" });

            /**
             * Calls streamVerifiableSet.
             * @function streamVerifiableSet
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IChunk} request Chunk message or plain object
             * @returns {Promise<immudb.schema.VerifiableTx>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#streamScan}.
             * @memberof immudb.schema.ImmuService
             * @typedef streamScanCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.Chunk} [response] Chunk
             */

            /**
             * Calls streamScan.
             * @function streamScan
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IScanRequest} request ScanRequest message or plain object
             * @param {immudb.schema.ImmuService.streamScanCallback} callback Node-style callback called with the error, if any, and Chunk
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.streamScan = function streamScan(request, callback) {
                return this.rpcCall(streamScan, $root.immudb.schema.ScanRequest, $root.immudb.schema.Chunk, request, callback);
            }, "name", { value: "streamScan" });

            /**
             * Calls streamScan.
             * @function streamScan
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IScanRequest} request ScanRequest message or plain object
             * @returns {Promise<immudb.schema.Chunk>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#streamZScan}.
             * @memberof immudb.schema.ImmuService
             * @typedef streamZScanCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.Chunk} [response] Chunk
             */

            /**
             * Calls streamZScan.
             * @function streamZScan
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IZScanRequest} request ZScanRequest message or plain object
             * @param {immudb.schema.ImmuService.streamZScanCallback} callback Node-style callback called with the error, if any, and Chunk
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.streamZScan = function streamZScan(request, callback) {
                return this.rpcCall(streamZScan, $root.immudb.schema.ZScanRequest, $root.immudb.schema.Chunk, request, callback);
            }, "name", { value: "streamZScan" });

            /**
             * Calls streamZScan.
             * @function streamZScan
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IZScanRequest} request ZScanRequest message or plain object
             * @returns {Promise<immudb.schema.Chunk>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#streamHistory}.
             * @memberof immudb.schema.ImmuService
             * @typedef streamHistoryCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.Chunk} [response] Chunk
             */

            /**
             * Calls streamHistory.
             * @function streamHistory
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IHistoryRequest} request HistoryRequest message or plain object
             * @param {immudb.schema.ImmuService.streamHistoryCallback} callback Node-style callback called with the error, if any, and Chunk
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.streamHistory = function streamHistory(request, callback) {
                return this.rpcCall(streamHistory, $root.immudb.schema.HistoryRequest, $root.immudb.schema.Chunk, request, callback);
            }, "name", { value: "streamHistory" });

            /**
             * Calls streamHistory.
             * @function streamHistory
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IHistoryRequest} request HistoryRequest message or plain object
             * @returns {Promise<immudb.schema.Chunk>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#streamExecAll}.
             * @memberof immudb.schema.ImmuService
             * @typedef streamExecAllCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.TxHeader} [response] TxHeader
             */

            /**
             * Calls streamExecAll.
             * @function streamExecAll
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IChunk} request Chunk message or plain object
             * @param {immudb.schema.ImmuService.streamExecAllCallback} callback Node-style callback called with the error, if any, and TxHeader
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.streamExecAll = function streamExecAll(request, callback) {
                return this.rpcCall(streamExecAll, $root.immudb.schema.Chunk, $root.immudb.schema.TxHeader, request, callback);
            }, "name", { value: "streamExecAll" });

            /**
             * Calls streamExecAll.
             * @function streamExecAll
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IChunk} request Chunk message or plain object
             * @returns {Promise<immudb.schema.TxHeader>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#exportTx}.
             * @memberof immudb.schema.ImmuService
             * @typedef exportTxCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.Chunk} [response] Chunk
             */

            /**
             * Calls exportTx.
             * @function exportTx
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IExportTxRequest} request ExportTxRequest message or plain object
             * @param {immudb.schema.ImmuService.exportTxCallback} callback Node-style callback called with the error, if any, and Chunk
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.exportTx = function exportTx(request, callback) {
                return this.rpcCall(exportTx, $root.immudb.schema.ExportTxRequest, $root.immudb.schema.Chunk, request, callback);
            }, "name", { value: "exportTx" });

            /**
             * Calls exportTx.
             * @function exportTx
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IExportTxRequest} request ExportTxRequest message or plain object
             * @returns {Promise<immudb.schema.Chunk>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#replicateTx}.
             * @memberof immudb.schema.ImmuService
             * @typedef replicateTxCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.TxHeader} [response] TxHeader
             */

            /**
             * Calls replicateTx.
             * @function replicateTx
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IChunk} request Chunk message or plain object
             * @param {immudb.schema.ImmuService.replicateTxCallback} callback Node-style callback called with the error, if any, and TxHeader
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.replicateTx = function replicateTx(request, callback) {
                return this.rpcCall(replicateTx, $root.immudb.schema.Chunk, $root.immudb.schema.TxHeader, request, callback);
            }, "name", { value: "replicateTx" });

            /**
             * Calls replicateTx.
             * @function replicateTx
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IChunk} request Chunk message or plain object
             * @returns {Promise<immudb.schema.TxHeader>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#sQLExec}.
             * @memberof immudb.schema.ImmuService
             * @typedef SQLExecCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.SQLExecResult} [response] SQLExecResult
             */

            /**
             * Calls SQLExec.
             * @function sQLExec
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.ISQLExecRequest} request SQLExecRequest message or plain object
             * @param {immudb.schema.ImmuService.SQLExecCallback} callback Node-style callback called with the error, if any, and SQLExecResult
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.sQLExec = function sQLExec(request, callback) {
                return this.rpcCall(sQLExec, $root.immudb.schema.SQLExecRequest, $root.immudb.schema.SQLExecResult, request, callback);
            }, "name", { value: "SQLExec" });

            /**
             * Calls SQLExec.
             * @function sQLExec
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.ISQLExecRequest} request SQLExecRequest message or plain object
             * @returns {Promise<immudb.schema.SQLExecResult>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#sQLQuery}.
             * @memberof immudb.schema.ImmuService
             * @typedef SQLQueryCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.SQLQueryResult} [response] SQLQueryResult
             */

            /**
             * Calls SQLQuery.
             * @function sQLQuery
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.ISQLQueryRequest} request SQLQueryRequest message or plain object
             * @param {immudb.schema.ImmuService.SQLQueryCallback} callback Node-style callback called with the error, if any, and SQLQueryResult
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.sQLQuery = function sQLQuery(request, callback) {
                return this.rpcCall(sQLQuery, $root.immudb.schema.SQLQueryRequest, $root.immudb.schema.SQLQueryResult, request, callback);
            }, "name", { value: "SQLQuery" });

            /**
             * Calls SQLQuery.
             * @function sQLQuery
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.ISQLQueryRequest} request SQLQueryRequest message or plain object
             * @returns {Promise<immudb.schema.SQLQueryResult>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#listTables}.
             * @memberof immudb.schema.ImmuService
             * @typedef ListTablesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.SQLQueryResult} [response] SQLQueryResult
             */

            /**
             * Calls ListTables.
             * @function listTables
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {immudb.schema.ImmuService.ListTablesCallback} callback Node-style callback called with the error, if any, and SQLQueryResult
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.listTables = function listTables(request, callback) {
                return this.rpcCall(listTables, $root.google.protobuf.Empty, $root.immudb.schema.SQLQueryResult, request, callback);
            }, "name", { value: "ListTables" });

            /**
             * Calls ListTables.
             * @function listTables
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<immudb.schema.SQLQueryResult>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#describeTable}.
             * @memberof immudb.schema.ImmuService
             * @typedef DescribeTableCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.SQLQueryResult} [response] SQLQueryResult
             */

            /**
             * Calls DescribeTable.
             * @function describeTable
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.ITable} request Table message or plain object
             * @param {immudb.schema.ImmuService.DescribeTableCallback} callback Node-style callback called with the error, if any, and SQLQueryResult
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.describeTable = function describeTable(request, callback) {
                return this.rpcCall(describeTable, $root.immudb.schema.Table, $root.immudb.schema.SQLQueryResult, request, callback);
            }, "name", { value: "DescribeTable" });

            /**
             * Calls DescribeTable.
             * @function describeTable
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.ITable} request Table message or plain object
             * @returns {Promise<immudb.schema.SQLQueryResult>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link immudb.schema.ImmuService#verifiableSQLGet}.
             * @memberof immudb.schema.ImmuService
             * @typedef VerifiableSQLGetCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {immudb.schema.VerifiableSQLEntry} [response] VerifiableSQLEntry
             */

            /**
             * Calls VerifiableSQLGet.
             * @function verifiableSQLGet
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IVerifiableSQLGetRequest} request VerifiableSQLGetRequest message or plain object
             * @param {immudb.schema.ImmuService.VerifiableSQLGetCallback} callback Node-style callback called with the error, if any, and VerifiableSQLEntry
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ImmuService.prototype.verifiableSQLGet = function verifiableSQLGet(request, callback) {
                return this.rpcCall(verifiableSQLGet, $root.immudb.schema.VerifiableSQLGetRequest, $root.immudb.schema.VerifiableSQLEntry, request, callback);
            }, "name", { value: "VerifiableSQLGet" });

            /**
             * Calls VerifiableSQLGet.
             * @function verifiableSQLGet
             * @memberof immudb.schema.ImmuService
             * @instance
             * @param {immudb.schema.IVerifiableSQLGetRequest} request VerifiableSQLGetRequest message or plain object
             * @returns {Promise<immudb.schema.VerifiableSQLEntry>} Promise
             * @variation 2
             */

            return ImmuService;
        })();

        return schema;
    })();

    return immudb;
})();

export const google = $root.google = (() => {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    const google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        const protobuf = {};

        protobuf.Empty = (function() {

            /**
             * Properties of an Empty.
             * @memberof google.protobuf
             * @interface IEmpty
             */

            /**
             * Constructs a new Empty.
             * @memberof google.protobuf
             * @classdesc Represents an Empty.
             * @implements IEmpty
             * @constructor
             * @param {google.protobuf.IEmpty=} [properties] Properties to set
             */
            function Empty(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Empty instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty=} [properties] Properties to set
             * @returns {google.protobuf.Empty} Empty instance
             */
            Empty.create = function create(properties) {
                return new Empty(properties);
            };

            /**
             * Encodes the specified Empty message. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Empty message, length delimited. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Empty message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Empty();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Empty message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Empty message.
             * @function verify
             * @memberof google.protobuf.Empty
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Empty.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an Empty message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Empty
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Empty} Empty
             */
            Empty.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Empty)
                    return object;
                return new $root.google.protobuf.Empty();
            };

            /**
             * Creates a plain object from an Empty message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.Empty} message Empty
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Empty.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Empty to JSON.
             * @function toJSON
             * @memberof google.protobuf.Empty
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Empty.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Empty
             * @function getTypeUrl
             * @memberof google.protobuf.Empty
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Empty.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.Empty";
            };

            return Empty;
        })();

        protobuf.Struct = (function() {

            /**
             * Properties of a Struct.
             * @memberof google.protobuf
             * @interface IStruct
             * @property {Object.<string,google.protobuf.IValue>|null} [fields] Struct fields
             */

            /**
             * Constructs a new Struct.
             * @memberof google.protobuf
             * @classdesc Represents a Struct.
             * @implements IStruct
             * @constructor
             * @param {google.protobuf.IStruct=} [properties] Properties to set
             */
            function Struct(properties) {
                this.fields = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Struct fields.
             * @member {Object.<string,google.protobuf.IValue>} fields
             * @memberof google.protobuf.Struct
             * @instance
             */
            Struct.prototype.fields = $util.emptyObject;

            /**
             * Creates a new Struct instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Struct
             * @static
             * @param {google.protobuf.IStruct=} [properties] Properties to set
             * @returns {google.protobuf.Struct} Struct instance
             */
            Struct.create = function create(properties) {
                return new Struct(properties);
            };

            /**
             * Encodes the specified Struct message. Does not implicitly {@link google.protobuf.Struct.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Struct
             * @static
             * @param {google.protobuf.IStruct} message Struct message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Struct.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fields != null && Object.hasOwnProperty.call(message, "fields"))
                    for (let keys = Object.keys(message.fields), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.google.protobuf.Value.encode(message.fields[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Encodes the specified Struct message, length delimited. Does not implicitly {@link google.protobuf.Struct.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Struct
             * @static
             * @param {google.protobuf.IStruct} message Struct message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Struct.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Struct message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Struct
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Struct} Struct
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Struct.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Struct(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (message.fields === $util.emptyObject)
                                message.fields = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = null;
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = $root.google.protobuf.Value.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.fields[key] = value;
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Struct message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Struct
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Struct} Struct
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Struct.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Struct message.
             * @function verify
             * @memberof google.protobuf.Struct
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Struct.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fields != null && message.hasOwnProperty("fields")) {
                    if (!$util.isObject(message.fields))
                        return "fields: object expected";
                    let key = Object.keys(message.fields);
                    for (let i = 0; i < key.length; ++i) {
                        let error = $root.google.protobuf.Value.verify(message.fields[key[i]]);
                        if (error)
                            return "fields." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Struct message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Struct
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Struct} Struct
             */
            Struct.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Struct)
                    return object;
                let message = new $root.google.protobuf.Struct();
                if (object.fields) {
                    if (typeof object.fields !== "object")
                        throw TypeError(".google.protobuf.Struct.fields: object expected");
                    message.fields = {};
                    for (let keys = Object.keys(object.fields), i = 0; i < keys.length; ++i) {
                        if (typeof object.fields[keys[i]] !== "object")
                            throw TypeError(".google.protobuf.Struct.fields: object expected");
                        message.fields[keys[i]] = $root.google.protobuf.Value.fromObject(object.fields[keys[i]]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Struct message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Struct
             * @static
             * @param {google.protobuf.Struct} message Struct
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Struct.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.objects || options.defaults)
                    object.fields = {};
                let keys2;
                if (message.fields && (keys2 = Object.keys(message.fields)).length) {
                    object.fields = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.fields[keys2[j]] = $root.google.protobuf.Value.toObject(message.fields[keys2[j]], options);
                }
                return object;
            };

            /**
             * Converts this Struct to JSON.
             * @function toJSON
             * @memberof google.protobuf.Struct
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Struct.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Struct
             * @function getTypeUrl
             * @memberof google.protobuf.Struct
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Struct.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.Struct";
            };

            return Struct;
        })();

        protobuf.Value = (function() {

            /**
             * Properties of a Value.
             * @memberof google.protobuf
             * @interface IValue
             * @property {google.protobuf.NullValue|null} [nullValue] Value nullValue
             * @property {number|null} [numberValue] Value numberValue
             * @property {string|null} [stringValue] Value stringValue
             * @property {boolean|null} [boolValue] Value boolValue
             * @property {google.protobuf.IStruct|null} [structValue] Value structValue
             * @property {google.protobuf.IListValue|null} [listValue] Value listValue
             */

            /**
             * Constructs a new Value.
             * @memberof google.protobuf
             * @classdesc Represents a Value.
             * @implements IValue
             * @constructor
             * @param {google.protobuf.IValue=} [properties] Properties to set
             */
            function Value(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Value nullValue.
             * @member {google.protobuf.NullValue|null|undefined} nullValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.nullValue = null;

            /**
             * Value numberValue.
             * @member {number|null|undefined} numberValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.numberValue = null;

            /**
             * Value stringValue.
             * @member {string|null|undefined} stringValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.stringValue = null;

            /**
             * Value boolValue.
             * @member {boolean|null|undefined} boolValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.boolValue = null;

            /**
             * Value structValue.
             * @member {google.protobuf.IStruct|null|undefined} structValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.structValue = null;

            /**
             * Value listValue.
             * @member {google.protobuf.IListValue|null|undefined} listValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.listValue = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Value kind.
             * @member {"nullValue"|"numberValue"|"stringValue"|"boolValue"|"structValue"|"listValue"|undefined} kind
             * @memberof google.protobuf.Value
             * @instance
             */
            Object.defineProperty(Value.prototype, "kind", {
                get: $util.oneOfGetter($oneOfFields = ["nullValue", "numberValue", "stringValue", "boolValue", "structValue", "listValue"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Value instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Value
             * @static
             * @param {google.protobuf.IValue=} [properties] Properties to set
             * @returns {google.protobuf.Value} Value instance
             */
            Value.create = function create(properties) {
                return new Value(properties);
            };

            /**
             * Encodes the specified Value message. Does not implicitly {@link google.protobuf.Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Value
             * @static
             * @param {google.protobuf.IValue} message Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Value.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nullValue != null && Object.hasOwnProperty.call(message, "nullValue"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.nullValue);
                if (message.numberValue != null && Object.hasOwnProperty.call(message, "numberValue"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.numberValue);
                if (message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.stringValue);
                if (message.boolValue != null && Object.hasOwnProperty.call(message, "boolValue"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.boolValue);
                if (message.structValue != null && Object.hasOwnProperty.call(message, "structValue"))
                    $root.google.protobuf.Struct.encode(message.structValue, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.listValue != null && Object.hasOwnProperty.call(message, "listValue"))
                    $root.google.protobuf.ListValue.encode(message.listValue, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Value message, length delimited. Does not implicitly {@link google.protobuf.Value.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Value
             * @static
             * @param {google.protobuf.IValue} message Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Value.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Value} Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Value.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Value();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.nullValue = reader.int32();
                            break;
                        }
                    case 2: {
                            message.numberValue = reader.double();
                            break;
                        }
                    case 3: {
                            message.stringValue = reader.string();
                            break;
                        }
                    case 4: {
                            message.boolValue = reader.bool();
                            break;
                        }
                    case 5: {
                            message.structValue = $root.google.protobuf.Struct.decode(reader, reader.uint32());
                            break;
                        }
                    case 6: {
                            message.listValue = $root.google.protobuf.ListValue.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Value message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Value} Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Value.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Value message.
             * @function verify
             * @memberof google.protobuf.Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.nullValue != null && message.hasOwnProperty("nullValue")) {
                    properties.kind = 1;
                    switch (message.nullValue) {
                    default:
                        return "nullValue: enum value expected";
                    case 0:
                        break;
                    }
                }
                if (message.numberValue != null && message.hasOwnProperty("numberValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    if (typeof message.numberValue !== "number")
                        return "numberValue: number expected";
                }
                if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    if (!$util.isString(message.stringValue))
                        return "stringValue: string expected";
                }
                if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    if (typeof message.boolValue !== "boolean")
                        return "boolValue: boolean expected";
                }
                if (message.structValue != null && message.hasOwnProperty("structValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    {
                        let error = $root.google.protobuf.Struct.verify(message.structValue);
                        if (error)
                            return "structValue." + error;
                    }
                }
                if (message.listValue != null && message.hasOwnProperty("listValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    {
                        let error = $root.google.protobuf.ListValue.verify(message.listValue);
                        if (error)
                            return "listValue." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Value} Value
             */
            Value.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Value)
                    return object;
                let message = new $root.google.protobuf.Value();
                switch (object.nullValue) {
                default:
                    if (typeof object.nullValue === "number") {
                        message.nullValue = object.nullValue;
                        break;
                    }
                    break;
                case "NULL_VALUE":
                case 0:
                    message.nullValue = 0;
                    break;
                }
                if (object.numberValue != null)
                    message.numberValue = Number(object.numberValue);
                if (object.stringValue != null)
                    message.stringValue = String(object.stringValue);
                if (object.boolValue != null)
                    message.boolValue = Boolean(object.boolValue);
                if (object.structValue != null) {
                    if (typeof object.structValue !== "object")
                        throw TypeError(".google.protobuf.Value.structValue: object expected");
                    message.structValue = $root.google.protobuf.Struct.fromObject(object.structValue);
                }
                if (object.listValue != null) {
                    if (typeof object.listValue !== "object")
                        throw TypeError(".google.protobuf.Value.listValue: object expected");
                    message.listValue = $root.google.protobuf.ListValue.fromObject(object.listValue);
                }
                return message;
            };

            /**
             * Creates a plain object from a Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Value
             * @static
             * @param {google.protobuf.Value} message Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.nullValue != null && message.hasOwnProperty("nullValue")) {
                    object.nullValue = options.enums === String ? $root.google.protobuf.NullValue[message.nullValue] === undefined ? message.nullValue : $root.google.protobuf.NullValue[message.nullValue] : message.nullValue;
                    if (options.oneofs)
                        object.kind = "nullValue";
                }
                if (message.numberValue != null && message.hasOwnProperty("numberValue")) {
                    object.numberValue = options.json && !isFinite(message.numberValue) ? String(message.numberValue) : message.numberValue;
                    if (options.oneofs)
                        object.kind = "numberValue";
                }
                if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                    object.stringValue = message.stringValue;
                    if (options.oneofs)
                        object.kind = "stringValue";
                }
                if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                    object.boolValue = message.boolValue;
                    if (options.oneofs)
                        object.kind = "boolValue";
                }
                if (message.structValue != null && message.hasOwnProperty("structValue")) {
                    object.structValue = $root.google.protobuf.Struct.toObject(message.structValue, options);
                    if (options.oneofs)
                        object.kind = "structValue";
                }
                if (message.listValue != null && message.hasOwnProperty("listValue")) {
                    object.listValue = $root.google.protobuf.ListValue.toObject(message.listValue, options);
                    if (options.oneofs)
                        object.kind = "listValue";
                }
                return object;
            };

            /**
             * Converts this Value to JSON.
             * @function toJSON
             * @memberof google.protobuf.Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Value
             * @function getTypeUrl
             * @memberof google.protobuf.Value
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Value.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.Value";
            };

            return Value;
        })();

        /**
         * NullValue enum.
         * @name google.protobuf.NullValue
         * @enum {number}
         * @property {number} NULL_VALUE=0 NULL_VALUE value
         */
        protobuf.NullValue = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NULL_VALUE"] = 0;
            return values;
        })();

        protobuf.ListValue = (function() {

            /**
             * Properties of a ListValue.
             * @memberof google.protobuf
             * @interface IListValue
             * @property {Array.<google.protobuf.IValue>|null} [values] ListValue values
             */

            /**
             * Constructs a new ListValue.
             * @memberof google.protobuf
             * @classdesc Represents a ListValue.
             * @implements IListValue
             * @constructor
             * @param {google.protobuf.IListValue=} [properties] Properties to set
             */
            function ListValue(properties) {
                this.values = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListValue values.
             * @member {Array.<google.protobuf.IValue>} values
             * @memberof google.protobuf.ListValue
             * @instance
             */
            ListValue.prototype.values = $util.emptyArray;

            /**
             * Creates a new ListValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.ListValue
             * @static
             * @param {google.protobuf.IListValue=} [properties] Properties to set
             * @returns {google.protobuf.ListValue} ListValue instance
             */
            ListValue.create = function create(properties) {
                return new ListValue(properties);
            };

            /**
             * Encodes the specified ListValue message. Does not implicitly {@link google.protobuf.ListValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ListValue
             * @static
             * @param {google.protobuf.IListValue} message ListValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.values.length)
                    for (let i = 0; i < message.values.length; ++i)
                        $root.google.protobuf.Value.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ListValue message, length delimited. Does not implicitly {@link google.protobuf.ListValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.ListValue
             * @static
             * @param {google.protobuf.IListValue} message ListValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ListValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ListValue} ListValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ListValue();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.values && message.values.length))
                                message.values = [];
                            message.values.push($root.google.protobuf.Value.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.ListValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ListValue} ListValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListValue message.
             * @function verify
             * @memberof google.protobuf.ListValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (let i = 0; i < message.values.length; ++i) {
                        let error = $root.google.protobuf.Value.verify(message.values[i]);
                        if (error)
                            return "values." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ListValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ListValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ListValue} ListValue
             */
            ListValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ListValue)
                    return object;
                let message = new $root.google.protobuf.ListValue();
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".google.protobuf.ListValue.values: array expected");
                    message.values = [];
                    for (let i = 0; i < object.values.length; ++i) {
                        if (typeof object.values[i] !== "object")
                            throw TypeError(".google.protobuf.ListValue.values: object expected");
                        message.values[i] = $root.google.protobuf.Value.fromObject(object.values[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ListValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ListValue
             * @static
             * @param {google.protobuf.ListValue} message ListValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (message.values && message.values.length) {
                    object.values = [];
                    for (let j = 0; j < message.values.length; ++j)
                        object.values[j] = $root.google.protobuf.Value.toObject(message.values[j], options);
                }
                return object;
            };

            /**
             * Converts this ListValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.ListValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ListValue
             * @function getTypeUrl
             * @memberof google.protobuf.ListValue
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ListValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.ListValue";
            };

            return ListValue;
        })();

        return protobuf;
    })();

    return google;
})();

export { $root as default };
